<?xml version="1.0" encoding="utf-8"?>
<!--v1.7: Aligned with HWRM v2.4 and CONDUCTOR v1.0.0_RC-->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Alif Semiconductor</vendor>
  <vendorID>ALIF</vendorID>
  <name>AE302F40C1537LE_CM55_HP_View</name>
  <series>E3</series>
  <version>1.0</version>
  <description>
 The families of fusion processors and microcontrollers (MCUs) from Alif Semiconductor create a scalable and
 compatible continuum of highly integrated embedded processor devices for use in low-end to high-end
 intelligent IoT end-point applications. Architected for power efficiency and long battery life, these devices
 deliver high computation and ML/AI capability, multi-layered security, computer vision, and highly interactive
 human-machine interface.
</description>
  <licenseText>
 THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED\n
 OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.\n
 ALIF SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR\n
 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
</licenseText>
  <cpu>
    <name>CM55</name>
    <revision>r1p0</revision>
    <endian>selectable</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <fpuDP>true</fpuDP>
    <dspPresent>true</dspPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>8</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
    <sauNumRegions>1</sauNumRegions>
    <pmuPresent>true</pmuPresent>
    <pmuNumEventCnt>8</pmuNumEventCnt>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>CLKCTL_SYS</name>
      <baseAddress>0x1A010000</baseAddress>
      <addressBlock>
        <offset>1280</offset>
        <size>808</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SYS_LCTRL_ST</name>
          <description>System Lock Control Status Register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_CLR_DIS</name>
              <description>SYS_LCTRL_CLR register behavior indicator</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Writes to the SYS_LCTRL_CLR register take effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Writes to the SYS_LCTRL_CLR register are ignored</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_RTR_LOCK</name>
              <description>IRQRTR lockdown interface indicator</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IRQRTR lockdown interface is de-asserted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IRQRTR lockdown interface is asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_LCTRL_SET</name>
          <description>System Lock Control Set Register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_CLR_DIS</name>
              <description>Writing 0x1 to this bit sets the SYS_LCTRL_ST[LOCK_CLR_DIS] bit to 0x1
Writing 0x0 to this bit has no effect on the value of the SYS_LCTRL_ST[LOCK_CLR_DIS] bit
This bit always reads as 0x0</description>
              <bitRange>[31:31]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INT_RTR_LOCK</name>
              <description>Writing 0x1 to this bit sets the SYS_LCTRL_ST[INT_RTR_LOCK] bit to 0x1
Writing 0x0 to this bit has no effect on the value of the SYS_LCTRL_ST[INT_RTR_LOCK] bit
This bit always reads as 0x0</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_LCTRL_CLR</name>
          <description>System Lock Control Clear Register</description>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_RTR_LOCK</name>
              <description>Writing 0x1 to this bit sets the SYS_LCTRL_ST[INT_RTR_LOCK] bit to 0x0
Writing 0x0 to this bit has no effect on the value of the SYS_LCTRL_ST[INT_RTR_LOCK] bit
This bit always reads as 0x0</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACLK_CTRL</name>
          <description>SYST_ACLK Clock Control Register</description>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>ENTRY_DELAY</name>
              <description>Configure number of idle clock cycles before clock is gated.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSELECT_CUR</name>
              <description>Currently selected clock source for SYST_ACLK
All other values are reserved.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock gated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SYST_REFCLK</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>SYSPLL_CLK divided by ACLK_DIV0[CLKDIV]</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLKSELECT</name>
              <description>Select the clock source for SYST_ACLK
All other values are reserved.
Selecting a reserved value can cause a deadlock.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock gated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SYST_REFCLK</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>SYSPLL_CLK divided by ACLK_DIV0[CLKDIV]</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ACLK_DIV0</name>
          <description>SYST_ACLK Clock Divider 0 Register</description>
          <addressOffset>0x824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE0FFFF</resetMask>
          <fields>
            <field>
              <name>CLKDIV_CUR</name>
              <description>Current value of integer divider applied to SYSPLL_CLK</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divided by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Divided by 32</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLKDIV</name>
              <description>Select the value of the integer divider applied to SYSPLL_CLK</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Divide by 32</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IRQRTR</name>
      <baseAddress>0x1A500000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4020</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IRQRTR_CTRL</name>
          <description>IRQRTR Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR</name>
              <description>Configures the response for configuration accesses which generate a configuration access
error:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_LD_CTRL</name>
          <description>IRQRTR Lockdown Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFB</resetMask>
          <fields>
            <field>
              <name>LDI_ST</name>
              <description>Indicates the current status of the lockdown interface:
NOTE: Depends on the value of the [INT_RTR_LOCK] bit in the system lock control registers {SYS_LCTRL_ST, SYS_LCTRL_SET, SYS_LCTRL_CLR}.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Lockdown interface is de-asserted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Lockdown interface is asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Indicates the lock state of the IRQRTR:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Open lockdown state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Partial lockdown state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Full lockdown state</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_INFO</name>
          <description>IRQRTR Shared Interrupt Information Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>ICI_DST</name>
              <description>Interrupt Controller Destination.
Each bit indicates whether the interrupt selected by the IRQRTR_SHD_INT_SEL[INT_SEL] field canbe routed to the ICI interface associated with the bit, starting with bit 0 for ICI0 to bit 3 for ICI3:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared interrupt cannot be routed to the ICI[n]</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shared interrupt can be routed to the ICI[n]</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_CFG</name>
          <description>IRQRTR Shared Interrupt Configuration Register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>ICI_EN</name>
              <description>Interrupt Controller Enable.
Each bit indicates whether the interrupt selected by the IRQRTR_SHD_INT_SEL[INT_SEL] field isrouted to the ICI interface associated with the bit, starting with bit 0 for ICI0 to bit 3 for ICI3:
Note: Bits where the respective bit in the IRQRTR_SHD_INT_INFO[ICI_DST] field is 0x0 are reserved andtreated as RAZ/WI.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared interrupt is not routed to the ICI[n]</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shared interrupt is routed to the ICI[n]</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_LCTRL</name>
          <description>IRQRTR Shared Interrupt Lock Control Register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Controls the lock status of the interrupt selected by the IRQRTR_SHD_INT_SEL[INT_SEL] field:
This field becomes read-only when this field is set to 0x1 and the IRQRTR_LD_CTRL[LOCK] field isset to 0x2 (partial lockdown) or 0x3 (full lockdown).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared interrupt is not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shared interrupt is locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_SHD_INT_SEL</name>
          <description>IRQRTR Shared Interrupt Select Register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_SEL</name>
              <description>Selects which interrupt the IRQRTR_SHD_INT_INFO, IRQRTR_SHD_INT_CFG and IRQRTR_SHD_INT_LCTRL registersrefer to.
When the value in this field is greater than the value in the IRQRTR_CFG[NUM_SHD_INT] field, the fields in IRQRTR_SHD_INT_INFO,IRQRTR_SHD_INT_CFG and IRQRTR_SHD_INT_LCTRL are reserved and treated as RAZ/WI.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_TMP_ST</name>
          <description>IRQRTR Tamper Status Register</description>
          <addressOffset>0xE90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF003</resetMask>
          <fields>
            <field>
              <name>TMP_ST_VLD</name>
              <description>Indicates whether the IRQRTR_TMP_ST register contains valid data or not.
This field is 'write-1-to-clear'. Writing 0 has no effect.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IRQRTR_TMP_ST does not contain valid data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IRQRTR_TMP_ST contains valid data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMP_ST_OVERFLW</name>
              <description>Indicates whether a tamper transaction occurred, while the
IRQRTR_TMP_ST[TMP_ST_VLD] was 0x1:
This field is 'write-1-to-clear'. Writing 0 has no effect.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No tamper transaction overflow occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tamper transaction overflow occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMP_TRANS_ADDR</name>
              <description>Address of the register accessed by the tamper transaction.
When TMP_ST_VLD is 0, this field is not valid.</description>
              <bitRange>[11:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_CAP</name>
          <description>IRQRTR Capability Register</description>
          <addressOffset>0xFA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDE_LVL</name>
              <description>Level of the Lockdown Extension implemented by the IRQRTR.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>LDE.2 (open, partial and full lockdown support).</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQRTR_CFG</name>
          <description>IRQRTR Configuration Register</description>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000301AA</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_ICI</name>
              <description>Number of ICIs supported by the IRQRTR:</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 ICIs</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_SHD_INT</name>
              <description>Number of shared interrupts supported by the IRQRTR:</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1AA</name>
                  <description>427 shared interrupts</description>
                  <value>0x1AA</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CGU</name>
      <baseAddress>0x1A602000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>36</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>OSC_CTRL</name>
          <description>Oscillator Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110011</resetMask>
          <fields>
            <field>
              <name>XTAL_DEAD</name>
              <description>38.4 MHz crystal-oscillator clock monitor status</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No crystal clock dead found</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Crystal clock dead detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLKMON_ENA</name>
              <description>Enable 38.4 MHz crystal-oscillator clock monitor</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock monitor</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock monitor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERIPH_XTAL_SEL</name>
              <description>Select oscillator clock source for HFOSC_CLK</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 38.4 MHz (76.8 MHz / 2) ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS_XTAL_SEL</name>
              <description>Select oscillator clock source for SYSPLL_CLK, and SYST_REFCLK</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_LOCK_CTRL</name>
          <description>PLL Lock Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>PLL_CALIB</name>
              <description>PLL calibration status</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PLL not in calibration</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PLL in calibration</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL_LOCK</name>
              <description>PLL lock control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PLL not locked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PLL locked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CLK_SEL</name>
          <description>PLL Clock Select Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110111</resetMask>
          <fields>
            <field>
              <name>ES1</name>
              <description>Select the source for RTSS_HE_CLK</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select a value specified by the ESCLK_SEL[ES1_OSC] field</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select a value specified by the ESCLK_SEL[ES1_PLL] field</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0</name>
              <description>Select the source for RTSS_HP_CLK</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select a value specified by the ESCLK_SEL[ES0_OSC] field</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select a value specified by the ESCLK_SEL[ES0_PLL] field</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS</name>
              <description>Select the source for SYSPLL_CLK</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select oscillator clock source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select PLL clock source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSREF</name>
              <description>Select the source for SYST_REFCLK</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select oscillator clock source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select PLL clock source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCLK_SEL</name>
          <description>Clock Select Register for M55-HP and M55-HE</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x00003333</resetMask>
          <fields>
            <field>
              <name>ES1_OSC</name>
              <description>Select oscillator clock frequency for RTSS_HE_CLK</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz ring-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select 76.8 MHz crystal-oscillator clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0_OSC</name>
              <description>Select oscillator clock frequency for RTSS_HP_CLK</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz ring-oscillator clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 38.4 MHz ring-oscillator clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select 76.8 MHz crystal-oscillator clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select 38.4 MHz crystal-oscillator clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES1_PLL</name>
              <description>Select PLL clock frequency for RTSS_HE_CLK</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Select 60 MHz PLL clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Select 80 MHz PLL clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> Select 120 MHz PLL clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description> Select 160 MHz PLL clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0_PLL</name>
              <description>Select PLL clock frequency for RTSS_HP_CLK</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Select 100 MHz PLL clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Select 200 MHz PLL clock</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> Select 300 MHz PLL clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description> Select 400 MHz PLL clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ENA</name>
          <description>Clock Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x11033111</resetValue>
          <resetMask>0x11F73111</resetMask>
          <fields>
            <field>
              <name>OCVM</name>
              <description>Enable SRAM1 clock</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CVM</name>
              <description>Enable SRAM0 clock</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK38P4M</name>
              <description>Enable HFOSC_CLK</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK20M</name>
              <description>Enable USB_CLK and 10M_CLK</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK100M</name>
              <description>Enable 100M_CLK</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK160M</name>
              <description>Enable 160M_CLK</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFXO</name>
              <description>Enable clock to the HFXO_OUT pin</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES1</name>
              <description>Enable RTSS_HE_CLK</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ES0</name>
              <description>Enable RTSS_HP_CLK</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSPLL</name>
              <description>Enable SYSPLL_CLK</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CGU_IRQ</name>
          <description>CGU Interrupt Status Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>XTAL_DEAD</name>
              <description>38.4 MHz crystal-oscillator dead. Active high, read to clear.
Note: The XTAL_DEAD interrupt is mapped to the Secure Enclave.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PINMUX</name>
      <baseAddress>0x1A603000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>480</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>15</dim>
          <dimIncrement>32</dimIncrement>
          <name>PINMUX_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>P_0</name>
            <description>Control Register for Port n, Pin 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_0
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_0 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_1</name>
            <description>Control Register for Port n, Pin 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_1
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_1 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_2</name>
            <description>Control Register for Port n, Pin 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_2
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_2 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_3</name>
            <description>Control Register for Port n, Pin 3</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_3
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_3 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_4</name>
            <description>Control Register for Port n, Pin 4</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_4
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_4 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_5</name>
            <description>Control Register for Port n, Pin 5</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_5
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_5 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_6</name>
            <description>Control Register for Port n, Pin 6</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_6
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_6 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>P_7</name>
            <description>Control Register for Port n, Pin 7</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00220000</resetValue>
            <resetMask>0x00FF0007</resetMask>
            <fields>
              <field>
                <name>DRV</name>
                <description>Driver type</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Push-pull</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Open drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>E</name>
                <description>Output drive strength
NOTE: Reset value is 0x3 (12 mA) for registers P4_4, P4_5, P4_6, P4_7</description>
                <bitRange>[22:21]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>2 mA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>4 mA</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>8 mA</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>12 mA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>P</name>
                <description>Driver disabled state control</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>High-Z</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Bus keeper</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SR</name>
                <description>Slew rate</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Slow</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Fast</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMT</name>
                <description>Schmitt trigger (hysteresis) enable</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No hysteresis</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Hysteresis enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REN</name>
                <description>Receiver enable
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Receiver disabled, pin reads return 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Receiver enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINMUX</name>
                <description>Pin multiplexing control field
0x1-0xN: Selects other peripherals as shown in table Pin Function Multiplexing of the device series-specific Datasheet.
Un-mapped: Select GPIOn_7
NOTE: Reset value is 0x1 for registers P4_4, P4_5, P4_6, P4_7, P8_5, P8_6, P8_7, P9_0</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Selects GPIOn_7 signal from GPIOn peripheral</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>AON</name>
      <baseAddress>0x1A604000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>68</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RTSS_HP_CTRL</name>
          <description>M55-HP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000301</resetMask>
          <fields>
            <field>
              <name>WIC</name>
              <description>Control bits mapped to WICCONTROL[1:0] configuration signal of M55-HP. Bit [9] is mapped to WICCONTROL[1]. Bit [8] is mapped to WICCONTROL[0]. For more information, refer to Arm(R) Cortex(R)-M55 Processor Technical Reference Manual.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLD_WAKEUP</name>
              <description>Set this bit to wake up M55-HP power domain during cold boot or waking-up from stop mode, clear it once power-on sequence is complete to enable dynamic power transitions of M55-HP.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HP_RESET</name>
          <description>M55-HP Reset Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>RESETSYNDROME</name>
              <description>Reset status set by hardware and cleared by software</description>
              <bitRange>[5:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The last reset of M55-HP was caused by POR or Secure Enclave initiated reset </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The last reset of M55-HP was caused by NSRST pin being asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>The last reset of M55-HP was caused by a reset request to the power domain</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HE_CTRL</name>
          <description>M55-HE Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000301</resetMask>
          <fields>
            <field>
              <name>WIC</name>
              <description>Control bits mapped to WICCONTROL[1:0] configuration signal of M55-HE. Bit [9] is mapped to WICCONTROL[1]. Bit [8] is mapped to WICCONTROL[0]. For more information, refer to Arm(R) Cortex(R)-M55 Processor Technical Reference Manual.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COLD_WAKEUP</name>
              <description>Set this bit to wake up M55-HE power domain during cold boot or waking-up from stop mode, clear it once power-on sequence is complete to enable dynamic power transitions of M55-HE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HE_RESET</name>
          <description>M55-HE Reset Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>RESETSYNDROME</name>
              <description>Reset status set by hardware and cleared by software</description>
              <bitRange>[5:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The last reset of M55-HE was caused by POR or Secure Enclave initiated reset </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The last reset of M55-HE was caused by NSRST pin being asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>The last reset of M55-HE was caused by a reset request to the power domain</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSS_HE_LPUART_CKEN</name>
          <description>LPUART Clock Enable Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>UART_CKEN</name>
              <description>Enable clock for LPUART</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTOP_CLK_DIV</name>
          <description>System Bus Clock Divider Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000102</resetValue>
          <resetMask>0x00000303</resetMask>
          <fields>
            <field>
              <name>HCLK_DIVISOR</name>
              <description>SYST_HCLK clock divisor</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLK_DIVISOR</name>
              <description>SYST_PCLK clock divisor</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 4</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_REG1</name>
          <description>HFXO Divider Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001E000</resetMask>
          <fields>
            <field>
              <name>CLKDIV</name>
              <description>HFXO divisor</description>
              <bitRange>[16:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divide by 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divide by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 8</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Divide by 16</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Divide by 32</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Divide by 64</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Divide by 128</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Divide by 1</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Divide by 2</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Divide by 4</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Divide by 16</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Divide by 64</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Divide by 128</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Divide by 256</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Divide by 1024</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_PERIPH</name>
          <description>ADC Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00459555</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC24_BIAS</name>
              <description>ADC24 bias control</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC24_PGA_GAIN</name>
              <description>ADC24 PGA gain value</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 dB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>6 dB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>12 dB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>18 dB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24 dB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>30 dB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>36 dB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>42 dB</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC24_PGA_EN</name>
              <description>ADC24 PGA enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC24_OUTPUT_RATE</name>
              <description>ADC24 output rate select</description>
              <bitRange>[15:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC24_EN</name>
              <description>ADC24 enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_PGA_GAIN</name>
              <description>ADC122 PGA gain value select</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 dB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>6 dB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>12 dB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>18 dB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24 dB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>30 dB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>36 dB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>42 dB</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_PGA_EN</name>
              <description>ADC122 PGA enable
Note: ADC122 must be put into differential mode when PGA is enabled</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_PGA_GAIN</name>
              <description>ADC121 PGA gain value select</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 dB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>6 dB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>12 dB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>18 dB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24 dB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>30 dB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>36 dB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>42 dB</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_PGA_EN</name>
              <description>ADC121 PGA enable
Note: ADC121 must be put into differential mode when PGA is enabled</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_PGA_GAIN</name>
              <description>ADC120 PGA gain value select</description>
              <bitRange>[3:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 dB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>6 dB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>12 dB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>18 dB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24 dB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>30 dB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>36 dB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>42 dB</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_PGA_EN</name>
              <description>ADC120 PGA enable
Note: ADC120 must be put into differential mode when PGA is enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>VBAT</name>
      <baseAddress>0x1A609000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIO_CTRL</name>
          <description>GPIO 1.8 V / 3.3 V Power Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>VOLT</name>
              <description>Select voltage level for the 1.8-V/3.3-V (flex) I/O pins</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I/O pin will be used with a 3.3-V power </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I/O pin will be used with a 1.8-V power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMER_CLKSEL</name>
          <description>LPTIMER Clock Select Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003333</resetMask>
          <fields>
            <field>
              <name>SEL4</name>
              <description>LPTIMER3 clock select</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR3_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>LPTIMER2 toggle output (LPTMR2_OUT)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL3</name>
              <description>LPTIMER2 clock select</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR2_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>S32K_CLK</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL2</name>
              <description>LPTIMER1 clock select</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR1_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>LPTIMER0 toggle output (LPTMR0_OUT)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL1</name>
              <description>LPTIMER0 clock select</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S32K_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128K_CLK (128 kHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>External clock from LPTMR0_CLK_IO pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>S32K_CLK</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTRL</name>
          <description>Power Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00031333</resetValue>
          <resetMask>0x00033333</resetMask>
          <fields>
            <field>
              <name>UPHY_ISO</name>
              <description>Enable isolation for USB PHY</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UPHY_PWR_MASK</name>
              <description>Mask off the power for USB PHY</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPHY_VPH_1P8_PWR_BYP_VAL</name>
              <description>dphy_vph_1p8_pwr_byp_val</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPHY_VPH_1P8_PWR_BYP_EN</name>
              <description>dphy_vph_1p8_pwr_byp_en</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPHY_PLL_ISO</name>
              <description>Enable isolation for MIPI PLL</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPHY_PLL_PWR_MASK</name>
              <description>Mask off the power for MIPI PLL</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_DPHY_ISO</name>
              <description>Enable isolation for MIPI RX DPHY</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_DPHY_PWR_MASK</name>
              <description>Mask off the power for MIPI RX DPHY</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_DPHY_ISO</name>
              <description>Enable isolation for MIPI TX DPHY</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_DPHY_PWR_MASK</name>
              <description>Mask off the power for MIPI TX DPHY</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power not masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power masked off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RET_CTRL</name>
          <description>Memory Retention Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000F3</resetValue>
          <resetMask>0x000000F3</resetMask>
          <fields>
            <field>
              <name>HETCM_RET2_FORCE</name>
              <description>Memory retention force for M55-HE TCM RET2</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HETCM_RET2_MASK</name>
              <description>Memory retention mask for M55-HE TCM RET2</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HETCM_RET1_FORCE</name>
              <description>Memory retention force for M55-HE TCM RET1</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HETCM_RET1_MASK</name>
              <description>Memory retention mask for M55-HE TCM RET1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKRAM_RET_FORCE</name>
              <description>Memory retention force for Backup SRAM</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Force enabling the memory retention</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No force</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKRAM_RET_MASK</name>
              <description>Memory retention mask for Backup SRAM</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable the memory retention</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_CLK_EN</name>
          <description>LPRTC Clock Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CLK_EN</name>
              <description>Enable SYST_PCLK and S32K_CLK for LPRTC. This bit must be set before any programming to LPRTC.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable LPRTC clocks</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable LPRTC clocks</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ANA</name>
      <baseAddress>0x1A60A000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>68</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MISC_CTRL</name>
          <description>VBAT Misc Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SEL_32K</name>
              <description>Select 32KHz clock source</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Select Ring-Oscillator (LFRC)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Select Crystal-Oscillator (LFXO)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WKUP_CTRL</name>
          <description>VBAT Wake-up Source Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000011</resetValue>
          <resetMask>0x00FF0FFF</resetMask>
          <fields>
            <field>
              <name>LPGPIO</name>
              <description>Each bit controls enable/disable of a wake-up source from LPGPIO</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPTIMER</name>
              <description>Each bit controls enable/disable of a wake-up source from LPTIMER</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BROWN_OUT</name>
              <description>Controls enable/disable of wake-up source from Brown-Out Detect (Falling Edge).
This register bit is also used to clear the wake-up source by SE CPU.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and Clear wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPCMP</name>
              <description>Controls enable/disable of wake-up source from LPCMP</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTCA</name>
              <description>Controls enable/disable of wake-up source from LPRTC</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable wake-up source</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable wake-up source</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_REG1</name>
          <description>DC/DC Control Register 1</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x614DE693</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_CRAMP</name>
              <description>Feed forward ramp capacitor adjust</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMP_CONT</name>
              <description>Select VDD_MAIN feed forward ramp current.
For VDD_MAIN = 3.6 V:
Min: 000 = 6 uA
Max: 111 = 13 uA 
Step: 1 uA
This current is proportional to VDD_MAIN voltage.</description>
              <bitRange>[29:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_MIN_TON</name>
              <description>If = 1, disables the minimum 'ON time' of HS FET (PMOS), and minimum 'ON time' of LS FET (NMOS).</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_SS_DLY_CONT</name>
              <description>Trim EN_SS signal delay:
 Min is 0000: 0 clock cycle delay
 Max is 1111: 15 clock cycle delay
Clock is DC-DC clock divided by 8 (~250 kHz for nominal settings)</description>
              <bitRange>[25:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DRV_DLY_CONT</name>
              <description>Trim EN_DRV signal delay:
 Min is 0000 = 0 clock cycle delay
 Max is 1111 = 15 clock cycle delay
Clock is DC-DC clock divided by 8 (~250 kHz for nominal settings)</description>
              <bitRange>[21:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_EN_XTAL_CLK</name>
              <description>Switch DC-DC PWM clock from internal 2-MHz oscillator to 2-MHz crystal oscillator when = 1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_CTRL_FET</name>
              <description>Selects the drive strength of DC-DC NFET power transistor</description>
              <bitRange>[16:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_OSC2M_IBIAS</name>
              <description>Trim DC-DC 2-MHz internal oscillator:
 Min is 0000: 1.5 MHz
Max is 1111: 3.75 MHz
Step = ~0.15 MHz</description>
              <bitRange>[12:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_TRIM_VOUT</name>
              <description>Trim DC-DC regulation reference voltage:
 Min is 0000: -4%
Max is 1111: +3.5% 
Step: 0.5%</description>
              <bitRange>[8:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_VOUT_SEL</name>
              <description>Select DC-DC regulation reference voltage:</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b00</name>
                  <description>Vref = 0.800 V</description>
                  <value>0b00</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b01</name>
                  <description>Vref = 0.800 V</description>
                  <value>0b01</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b10</name>
                  <description>Vref = 0.825 V </description>
                  <value>0b10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b11</name>
                  <description>Vref = 0.850 V</description>
                  <value>0b11</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_LS_ON</name>
              <description>Force low-side Power FET to be on (NMOS Power FET), PWM signal will be kept low.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCDC_EN_CLAMP_LO</name>
              <description>Enable Vcomp clamp for voltages less than 400 mV: </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable clamp</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable clamp</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCDC_EN_CLAMP_HI</name>
              <description>Enable Vcomp clamp for voltages over 1.3 V:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable clamp</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable clamp</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_REG2</name>
          <description>DC/DC Control Register 2</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0B014441</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCDC_XTAL_DIV_EN</name>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DC-DC high-frequency XTAL frequency divider.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCDC_XTAL_DIV_CONT</name>
              <description>High-frequency XTAL frequency divider division value:
 Fout = Fxtal / (2 x DCDC_XTAL_DIV_CONT)</description>
              <bitRange>[30:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_MIN_TOFF</name>
              <description>Disable minimum Toff</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_GAIN_LSENSE</name>
              <description>Trim Current Sense Gain. 
 bit 4: sign bit (1: Positive, 0: Negative)
Min: 01111: -25%
 Max: 11111: +25%
 Step: 1.6%</description>
              <bitRange>[21:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_ONESHOT_CAP</name>
              <description>Trim one-shot capacitor</description>
              <bitRange>[16:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_LDO_CONT</name>
              <description>MIPI PHY LDO (LDO-6) output voltage control: 
Step: 20 mV</description>
              <bitRange>[14:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>1.6 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>1.9 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ONESHOT_L_CONT</name>
              <description>One-shot control</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PS_MODE</name>
              <description>Puts the DC-DC converter into PFM mode, with ultra low quiescent current. PFM_AUTO_SWITCH_EN bit must be 0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PFM_AUTO_SWITCH_EN</name>
              <description>When set to 1, DC-DC switches to PFM mode automatically. When cleared to 0, PFM mode is controlled by [PS_MODE] bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_RCOMP</name>
              <description>Trim for loop filter resistor. </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>shorts out loop resistor</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>enables loop resistor</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIM_ZCD</name>
              <description>Trim for PFM ZCD comparator offset voltage</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_SS</name>
              <description>Trim for soft start timing:
Step: 5 us</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>10 us </description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>45 us </description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>VBAT_ANA_REG1</name>
          <description>VBAT Analog Control Register 1</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x02441A80</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOR_THRESH</name>
              <description>Control for BOR threshold level:
Step: 22.857 mV</description>
              <bitRange>[31:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>1.585 V</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>1.745 V</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOR_HYST</name>
              <description>Control for BOR hysteresis:
Step: 22.857 mV</description>
              <bitRange>[28:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>0 mV</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>160 mV</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOR_EN</name>
              <description>Enables brown-out reset circuit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32K_CAP_CONT</name>
              <description>Shunt capacitor control for 32-kHz XTAL oscillator: 
 Step: 0.25 pF</description>
              <bitRange>[24:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000000</name>
                  <description>2 pF</description>
                  <value>0b000000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111111</name>
                  <description>16 pF</description>
                  <value>0b111111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XTAL32K_GM_CONT</name>
              <description>gM control for 32-kHz XTAL oscillator: 
00000: no gM (off) 
11111: max gM</description>
              <bitRange>[18:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPCOMP_CLK32K_EN</name>
              <description>Enables 32-kHz clock to LPCMP comparator.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32K_KICK</name>
              <description>Starts 32-kHz XTAL oscillator.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32K_EN</name>
              <description>Enables 32-kHz XTAL oscillator.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VDD_MAIN_SHUNT_EN</name>
              <description>Enables 38-Mohm shunt resistor on LDO-2.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VDDMAIN_EN</name>
              <description>Enables LDO-2 for SRAM6, SRAM7, SE SRAM, and M55-HE TCM retention.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VBAT_SHUNT_EN</name>
              <description>Enables 38-Mohm shunt resistor on LDO-0.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_VBAT_EN</name>
              <description>Enables LDO-0 for AON SRAM retention.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_LDO_CONT_3_0</name>
              <description>Controls both LDO-0 and LDO-2 output voltages:
Step: 22.2 mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>500 mV</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>833 mV</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSC_RC_32K_FREQ_CONT</name>
              <description>Controls NTAT current into 32-kHz RC oscillator</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VBAT_ANA_REG2</name>
          <description>VBAT Analog Control Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00CC0630</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_LP0_HYST</name>
              <description>Sets LPCMP hysteresis level. 6-mV steps</description>
              <bitRange>[31:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 mV</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>45 mV</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_LP0_IN_M_SEL</name>
              <description>Selects input to negative terminal of LPCMP:</description>
              <bitRange>[28:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Internal AON Vref (0.8 V)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VREF_IN0 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>VREF_IN1 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>VREF_IN2 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_LP0_IN_P_SEL</name>
              <description>Selects input to positive terminal of LPCMP:</description>
              <bitRange>[26:25]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> LPCMP_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPCMP_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>LPCMP_IN2 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>LPCMP_IN3 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_LP_EN</name>
              <description>Enables LPCMP</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_PERIPH_LDO_EN</name>
              <description>Enable Analog Peripherals LDO (LDO-5)</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_PERIPH_BG_ENA</name>
              <description>Enable precision bandgap for analog peripherals.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC_76M_DIV_CTRL_STBY</name>
              <description>76-MHz oscillator divider control in STANDBY mode.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> 76.8 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>38.4 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>19.2 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4.8 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description> 1.2 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description> 600 kHz</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description> 300 kHz</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>75 kHz</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSC_76MRC_CTRL_51</name>
              <description>Control for 76-MHz RC oscillator frequency. Bits [5-1]. Used with OSC_76MRC_CTRL_0 (bit 0).
Step: 1.3%
000000:  -10%
111111:  +10%</description>
              <bitRange>[18:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC_76M_DIV_CTRL_ACTIVE</name>
              <description>76-MHz oscillator divider control in GO, READY, and IDLE modes.</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> 76.8 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>38.4 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>19.2 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>9.6 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description> 4.8 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description> 2.4 MHz</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description> 1.2 MHz</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>600 kHz</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSC_76MRC_CTRL_0</name>
              <description>Control for 76-MHz RC oscillator frequency, LSB. Used with OSC_76MRC_CTRL_51</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIG_LDO_CONT</name>
              <description>LDO-4 output voltage control:
Step: 20 mV</description>
              <bitRange>[9:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description> 1.58 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description> 1.88 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIG_LDO_18_EN</name>
              <description>Enables 1.8-V digital LDO (LDO-4).
 Used for MRAM and EFUSE.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMUBG_VREF_CONT</name>
              <description>Calibration for PMU bandgap:
Step: 1%</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>-7%</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>+8%</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>VBAT_ANA_REG3</name>
          <description>VBAT Analog Control Register 3</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF8448004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPCOMP_CLK_SEL</name>
              <description>Selects clock source for LPCMP:</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description> 32-kHz XTAL oscillator (LFXO)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>32-kHz RC oscillator (LFRC)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AON_LDO_CONT</name>
              <description>AON LDO (LDO-1) output voltage trim:
Step: 10.67 mV</description>
              <bitRange>[30:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description> 660 mV</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description> 820 mV</description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AON_BG_CONT</name>
              <description>AON bandgap voltage trim:
Step: 10 mV</description>
              <bitRange>[26:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>830 mV</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>685 mV </description>
                  <value>0b1111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MRAM_VTRIM</name>
              <description>MRAM offset trim</description>
              <bitRange>[22:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_CTRIM</name>
              <description>MRAM curvature trim</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_VREF_EN</name>
              <description>Enables MRAM VREF block</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_THRESH</name>
              <description>Control for BOD threshold level:
Step: 22.857 mV</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>1.585 V</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>1.745 V</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOD_HYST</name>
              <description>Control for BOD hysteresis:
Step: 22.857 mV</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>0 mV</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>160 mV</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOD_EN</name>
              <description>Enables brown-out detector.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LDO_MAIN_CONT</name>
              <description>PMU 1.8-V LDO (LDO-3) output voltage control:
Step = 21.43 mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description> 1.71 V</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description> 1.86 V</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>STOP_MODE</name>
      <baseAddress>0x1A60F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>VBAT_STOP_MODE_REG</name>
          <description>VBAT Stop Mode Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000111</resetMask>
          <fields>
            <field>
              <name>DC_DC_STAT</name>
              <description>DC-DC Status
Reflects the real-time status of DC-DC power</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DC-DC is ON</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DC-DC is OFF</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_MODE_STAT</name>
              <description>Stop Mode Status
- HW sets this bit when DC-DC was turned off
- SW clears this bit by writing 0x1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>STOP_MODE_CTRL</name>
              <description>Stop Mode Control
- SW sets this bit to enter stop mode
- HW clears this bit when there is a wake-up event</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MHU_SECPU_M55HP_0_RX</name>
      <groupName>MHU</groupName>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>MHU_SECPU_M55HP_0_RX_IRQ</name>
        <description>Interrupt</description>
        <value>37</value>
      </interrupt>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>MHU_RX_CHANNEL_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>MHU_CH_ST</name>
            <description>Channel (n) Status Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_x</name>
                <description>Channel flag status
Each bit can be used as individual flag or bits can be grouped. The usage depends upon the transport protocol used. 
Bits in this register are set by writing 1 to the corresponding bit in the MHU_CHn_SET register.
Bits in this register are cleared by writing 1 to the corresponding bit the MHU_CHn_CLRregister.
 If software:
- Sets a bit that is already set, the bit remains set.
- Clears a bit that is already cleared, the bit remains cleared.
- Sets and clears a bit at the same time, the bit remains set.
It is strongly recommended that software follows the transport protocols defined in
Section MHU Functional Description.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_ST_MSK</name>
            <description>Channel (n) Status Masked Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_x</name>
                <description>Channel flag status after the mask is applied.
When this field is nonzero, the interrupt for the channel is asserted. 
 The value (VALUE) in this register is: 
Value = MHU_CHn_ST &amp; ( ~MHU_CHn_MSK_ST), at the point theread occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_CLR</name>
            <description>Channel Clear Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_CLR_x</name>
                <description>Channel flag clear
 Write 1 to a bit clears the corresponding bit in the MHU_CHn_ST and MHU_CHn_ST_MSK.
Writing 0 has no effect. 
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_MSK_ST</name>
            <description>Channel (n) Mask Status Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_x</name>
                <description>Channel flag mask
When a bit is unmasked, the corresponding bits in the MHU_CHn_ST and MHU_CHn_ST_MSKregisters have the same value.
When a bit is masked, the corresponding bit in the MHU_CHn_ST_MSK register alwaysreads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Flag bit is unmasked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Flag bit is masked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_MSK_SET</name>
            <description>Channel (n) Mask Set Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_SET_x</name>
                <description>Channel flag mask set
Writing 1 to a bit sets the corresponding bit in the MHU_CHn_MSK_ST register.
Writing 0 has no effect.
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_MSK_CLR</name>
            <description>Channel (n) Mask Clear Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_MSK_CLR_x</name>
                <description>Channel flag mask clear
Write 1 to a bit clears the corresponding bit in the MHU_CHn_MSK_ST register.
Writing 0 has no effect.
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>MHU_CFG</name>
          <description>Module Configuration Register</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFG_DEF</name>
              <description>Number of channels</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 channels</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_ST</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0xF90</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt status
There is no corresponding bit in the MHU_INT_CLR register. To clear this interrupt, softwaremust clear the underlying interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt has occurred on any channel.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>An interrupt has occurred on at least one channel.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt status</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ready to Not Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to Not Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not Ready to Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not Ready to Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_CLR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0xF94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>R2NR</name>
              <description>Clear Ready to Not Ready interrupt
Write 1 to clear the interrupt.
 Writing 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>NR2R</name>
              <description>Clear Not Ready to Ready interrupt
Write 1 to clear the interrupt. 
Writing 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0xF98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Combined interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Combined interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST0</name>
          <description>Channel Combined Interrupt Status Register for Channels 0-31</description>
          <addressOffset>0xFA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 0-31 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST1</name>
          <description>Channel Combined Interrupt Status Register for Channels 32-63</description>
          <addressOffset>0xFA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 32-63 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST2</name>
          <description>Channel Combined Interrupt Status Register for Channels 64-95</description>
          <addressOffset>0xFA8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 64-95 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST3</name>
          <description>Channel Combined Interrupt Status Register for Channels 96-123</description>
          <addressOffset>0xFAC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 96-123 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[27:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_IIDR</name>
          <description>Implementer Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0760043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID</name>
              <description>MHU part ID</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the MHU</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revisions of the MHU</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Contains the JEP106 code:
[11-8] JEP106 continuation code of implementer
[7] Always 0
[6-0] JEP106 identity code of implementer</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000011</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARCH_MAJOR_REV</name>
              <description>MHU architecture major revision
Others: Reserved</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MHUv2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARCH_MINOR_REV</name>
              <description>MHU architecture minor revision
Others: Reserved</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Minor revision 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Minor revision 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID4</name>
          <description>Peripheral ID 4 Register</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Number of 4KB occupied by the System ID block.
This field is deprecated.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_2</name>
              <description>JEP continuation</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID0</name>
          <description>Peripheral ID 0 Register</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000076</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PART_0</name>
              <description>Bits [7:0] of part ID.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID1</name>
          <description>Peripheral ID 1 Register</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DES_0</name>
              <description>Bits [3:0] of JEP 106 identity.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_1</name>
              <description>Bits [11:8] of part ID.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID2</name>
          <description>Peripheral ID 2 Register</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Major revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEDEC</name>
              <description>Indicates the use of JEDEC JEP106 identification scheme.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_1</name>
              <description>Bits [6:4] of JEP 106 identity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID3</name>
          <description>Peripheral ID 3 Register</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVAND</name>
              <description>Minor revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMOD</name>
              <description>Customer modification field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID0</name>
          <description>Component ID 0 Register</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_0</name>
              <description>Preamble 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID1</name>
          <description>Component ID 1 Register</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLASS</name>
              <description>Class of the component.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRMBL_1</name>
              <description>Preamble 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID2</name>
          <description>Component ID 2 Register</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_2</name>
              <description>Preamble 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID3</name>
          <description>Component ID 3 Register</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_3</name>
              <description>Preamble 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MHU_M55HP_SECPU_0_TX</name>
      <groupName>MHU</groupName>
      <baseAddress>0x40050000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>MHU_M55HP_SECPU_0_TX_IRQ</name>
        <description>Interrupt</description>
        <value>38</value>
      </interrupt>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>MHU_TX_CHANNEL_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>MHU_CH_ST</name>
            <description>Channel (n) Status Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_x</name>
                <description>Channel flag status
Each bit can be used as individual flag or bits can be grouped. The usage depends upon the transport protocol used. 
Bits in this register are set by writing 1 to the corresponding bit in the MHU_CHn_SET register.
Bits in this register are cleared by writing 1 to the corresponding bit the MHU_CHn_CLRregister.
 If software:
- Sets a bit that is already set, the bit remains set.
- Clears a bit that is already cleared, the bit remains cleared.
- Sets and clears a bit at the same time, the bit remains set.
It is strongly recommended that software follows the transport protocols defined in
Section MHU Functional Description.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_SET</name>
            <description>Channel (n) Set Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FLAG_SET_x</name>
                <description>Channel flag set
 Write 1 to a bit sets the corresponding bit in the MHU_CHn_ST. 
Writing 0 has no effect. 
Each bit always reads as 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_INT_ST</name>
            <description>Channel (n) Interrupt Status Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CH_CLR</name>
                <description>Channel Clear Interrupt status bit
CH_CLR bit is:
 Set to 1 when the Receiver writes to MHU_CHn_CLR registers. 
Note: If the Sender domain is not powered on, or is held in reset at the point the write occurs, then there is no requirement for the field to be set to 1. 
 Set to 0 when the Sender writes 1 to the MHU_CHn_INT_CLR[CH_CLR] bit.
 Setting MHU_CHn_INT_ST [CH_CLR] bit to 1 takes priority of setting the bit to 0.
The value of the MHU_CHn_INT_EN[CH_CLR] bit has no effect on the value of MHU_CHn_INT_ST register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No Channel Clear interrupt has occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>A Channel Clear interrupt has occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_INT_CLR</name>
            <description>Channel (n) Interrupt Clear Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CH_CLR</name>
                <description>Clears MHU_CHn_INT_ST[CH_CLR] bit.
Write 1 to clear the interrupt. 
Writing 0 has no effect.
This field always reads as 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MHU_CH_INT_EN</name>
            <description>Channel (n) Interrupt Enable Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CH_CLR</name>
                <description>Channel Clear interrupt enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Channel Clear interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Channel Clear interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>MHU_CFG</name>
          <description>Module Configuration Register</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFG_DEF</name>
              <description>Number of channels</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 channels</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_RESP_CFG</name>
          <description>Response Configuration Register</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NR_RESP</name>
              <description>Response generated when the Sender attempts to access any register of a channel, when
MHU_ACCESS_REQUEST[ACC_REQ] bit is 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Access is treated as RAZ/WI with no error generated.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Access is treated as RAZ/WI and an error is generated.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_ACCESS_REQUEST</name>
          <description>Access Request Register</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC_REQ</name>
              <description>Access Request</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver is not requested to be ready to receive transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver is requested to be ready to receive transfer.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_ACCESS_READY</name>
          <description>Access Ready Register</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACC_RDY</name>
              <description>Access Ready</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver is not ready to receive transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver is ready to receive transfer.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_ST</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0xF90</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt status
There is no corresponding bit in the MHU_INT_CLR register. To clear this interrupt, softwaremust clear the underlying interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt has occurred on any channel.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>An interrupt has occurred on at least one channel.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt status</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ready to Not Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to Not Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not Ready to Ready interrupt has not occurred.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not Ready to Ready interrupt has occurred.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_CLR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0xF94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>R2NR</name>
              <description>Clear Ready to Not Ready interrupt
Write 1 to clear the interrupt.
 Writing 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>NR2R</name>
              <description>Clear Not Ready to Ready interrupt
Write 1 to clear the interrupt. 
Writing 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_INT_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0xF98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHCOMB</name>
              <description>Channel Combined interrupt enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Combined interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Combined interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R2NR</name>
              <description>Ready to Not Ready interrupt enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Ready to Not Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NR2R</name>
              <description>Not Ready to Ready interrupt enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the generation of Not Ready to Ready interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST0</name>
          <description>Channel Combined Interrupt Status Register for Channels 0-31</description>
          <addressOffset>0xFA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 0-31 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST1</name>
          <description>Channel Combined Interrupt Status Register for Channels 32-63</description>
          <addressOffset>0xFA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 32-63 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST2</name>
          <description>Channel Combined Interrupt Status Register for Channels 64-95</description>
          <addressOffset>0xFA8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 64-95 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CHCOMB_INT_ST3</name>
          <description>Channel Combined Interrupt Status Register for Channels 96-123</description>
          <addressOffset>0xFAC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH_INT_ST_x</name>
              <description>Interrupt status for 96-123 channels
Each bit indicates whether a channel has a pending interrupt or not.
A bit relating to an unimplemented channel is Reserved and treated as RAZ/WI.</description>
              <bitRange>[27:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_IIDR</name>
          <description>Implementer Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0760043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID</name>
              <description>MHU part ID</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the MHU</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revisions of the MHU</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Contains the JEP106 code:
[11-8] JEP106 continuation code of implementer
[7] Always 0
[6-0] JEP106 identity code of implementer</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000011</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARCH_MAJOR_REV</name>
              <description>MHU architecture major revision
Others: Reserved</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MHUv2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARCH_MINOR_REV</name>
              <description>MHU architecture minor revision
Others: Reserved</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Minor revision 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Minor revision 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID4</name>
          <description>Peripheral ID 4 Register</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Number of 4KB occupied by the System ID block.
This field is deprecated.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_2</name>
              <description>JEP continuation</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID0</name>
          <description>Peripheral ID 0 Register</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000076</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PART_0</name>
              <description>Bits [7:0] of part ID.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID1</name>
          <description>Peripheral ID 1 Register</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DES_0</name>
              <description>Bits [3:0] of JEP 106 identity.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_1</name>
              <description>Bits [11:8] of part ID.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID2</name>
          <description>Peripheral ID 2 Register</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Major revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEDEC</name>
              <description>Indicates the use of JEDEC JEP106 identification scheme.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DES_1</name>
              <description>Bits [6:4] of JEP 106 identity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_PID3</name>
          <description>Peripheral ID 3 Register</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVAND</name>
              <description>Minor revision of the System ID block.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMOD</name>
              <description>Customer modification field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID0</name>
          <description>Component ID 0 Register</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_0</name>
              <description>Preamble 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID1</name>
          <description>Component ID 1 Register</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLASS</name>
              <description>Class of the component</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRMBL_1</name>
              <description>Preamble 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID2</name>
          <description>Component ID 2 Register</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_2</name>
              <description>Preamble 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MHU_CID3</name>
          <description>Component ID 3 Register</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRMBL_3</name>
              <description>Preamble 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MHU_SECPU_M55HP_0_RX">
      <name>MHU_SECPU_M55HP_1_RX</name>
      <baseAddress>0x40060000</baseAddress>
      <interrupt>
        <name>MHU_SECPU_M55HP_1_RX_IRQ</name>
        <description>Interrupt</description>
        <value>39</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_SECPU_0_TX">
      <name>MHU_M55HP_SECPU_1_TX</name>
      <baseAddress>0x40070000</baseAddress>
      <interrupt>
        <name>MHU_M55HP_SECPU_1_TX_IRQ</name>
        <description>Interrupt</description>
        <value>40</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="MHU_SECPU_M55HP_0_RX">
      <name>MHU_M55HE_M55HP_0_RX</name>
      <baseAddress>0x40080000</baseAddress>
      <interrupt>
        <name>MHU_M55HE_M55HP_0_RX_IRQ</name>
        <description>Interrupt</description>
        <value>41</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_SECPU_0_TX">
      <name>MHU_M55HP_M55HE_0_TX</name>
      <baseAddress>0x40090000</baseAddress>
      <interrupt>
        <name>MHU_M55HP_M55HE_0_TX_IRQ</name>
        <description>Interrupt</description>
        <value>42</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="MHU_SECPU_M55HP_0_RX">
      <name>MHU_M55HE_M55HP_1_RX</name>
      <baseAddress>0x400A0000</baseAddress>
      <interrupt>
        <name>MHU_M55HE_M55HP_1_RX_IRQ</name>
        <description>Interrupt</description>
        <value>43</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="MHU_M55HP_SECPU_0_TX">
      <name>MHU_M55HP_M55HE_1_TX</name>
      <baseAddress>0x400B0000</baseAddress>
      <interrupt>
        <name>MHU_M55HP_M55HE_1_TX_IRQ</name>
        <description>Interrupt</description>
        <value>44</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>DMA1_SEC</name>
      <groupName>DMA</groupName>
      <baseAddress>0x400C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>DMA1_IRQ0</name>
        <description>Interrupt request 0. One per DMA request interface (32 in total).</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ1</name>
        <description>Interrupt request 1. One per DMA request interface (32 in total).</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ10</name>
        <description>Interrupt request 10. One per DMA request interface (32 in total).</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ11</name>
        <description>Interrupt request 11. One per DMA request interface (32 in total).</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ12</name>
        <description>Interrupt request 12. One per DMA request interface (32 in total).</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ13</name>
        <description>Interrupt request 13. One per DMA request interface (32 in total).</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ14</name>
        <description>Interrupt request 14. One per DMA request interface (32 in total).</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ15</name>
        <description>Interrupt request 15. One per DMA request interface (32 in total).</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ16</name>
        <description>Interrupt request 16. One per DMA request interface (32 in total).</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ17</name>
        <description>Interrupt request 17. One per DMA request interface (32 in total).</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ18</name>
        <description>Interrupt request 18. One per DMA request interface (32 in total).</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ19</name>
        <description>Interrupt request 19. One per DMA request interface (32 in total).</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ2</name>
        <description>Interrupt request 2. One per DMA request interface (32 in total).</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ20</name>
        <description>Interrupt request 20. One per DMA request interface (32 in total).</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ21</name>
        <description>Interrupt request 21. One per DMA request interface (32 in total).</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ22</name>
        <description>Interrupt request 22. One per DMA request interface (32 in total).</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ23</name>
        <description>Interrupt request 23. One per DMA request interface (32 in total).</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ24</name>
        <description>Interrupt request 24. One per DMA request interface (32 in total).</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ25</name>
        <description>Interrupt request 25. One per DMA request interface (32 in total).</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ26</name>
        <description>Interrupt request 26. One per DMA request interface (32 in total).</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ27</name>
        <description>Interrupt request 27. One per DMA request interface (32 in total).</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ28</name>
        <description>Interrupt request 28. One per DMA request interface (32 in total).</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ29</name>
        <description>Interrupt request 29. One per DMA request interface (32 in total).</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ3</name>
        <description>Interrupt request 3. One per DMA request interface (32 in total).</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ30</name>
        <description>Interrupt request 30. One per DMA request interface (32 in total).</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ31</name>
        <description>Interrupt request 31. One per DMA request interface (32 in total).</description>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ4</name>
        <description>Interrupt request 4. One per DMA request interface (32 in total).</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ5</name>
        <description>Interrupt request 5. One per DMA request interface (32 in total).</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ6</name>
        <description>Interrupt request 6. One per DMA request interface (32 in total).</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ7</name>
        <description>Interrupt request 7. One per DMA request interface (32 in total).</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ8</name>
        <description>Interrupt request 8. One per DMA request interface (32 in total).</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ9</name>
        <description>Interrupt request 9. One per DMA request interface (32 in total).</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ_ABORT</name>
        <description>DMAC aborted execution of a program thread.</description>
        <value>32</value>
      </interrupt>
      <registers>
        <register>
          <name>DMA_DSR</name>
          <description>DMA Manager Status Register </description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DNS</name>
              <description>This bit provides the security status of the DMA manager thread.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA manager operates in the secure state.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA manager operates in the non-secure state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAKEUP_EVENT</name>
              <description>When the DMA manager thread executes a DMAWFE instruction, it waits for the following event to occur:</description>
              <bitRange>[8:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>event[0].</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>event[1].</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>event[2].</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>event[31].</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_STATUS</name>
              <description>This bit field presents the operating state of the DMA manager.
For more information, see Section Thread Operating States.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Executing.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Cache miss.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Updating PC.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Waiting for event.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Faulting.</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DPC</name>
          <description>DMA Program Counter Register </description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PC_MGR</name>
              <description>Program counter for the DMA manager thread.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTEN</name>
          <description>Interrupt Enable Register </description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVENT_IRQ_SELECT</name>
              <description>Program the appropriate bit to control how the DMAC responds when it executes DMASEV.
Bit [N] = 0x0: If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC signals event N to all of the threads. 
Bit [N] = 0x1: If the DMAC executes DMASEV for the event-interrupt resource N then the DMAC sets IRQ[N] high.
Note: For more information about selecting an event number, see Section DMASEV.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INT_EVENT_RIS</name>
          <description>Event-Interrupt Raw Status Register </description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASEV_ACTIVE</name>
              <description>This bit field returns the status of the event-interrupt resources.
- Bit [N] = 0x0: Event N is inactive or IRQ[N] is low.
- Bit [N] = 0x1: Event N is active or IRQ[N] is high.
Note: When the DMAC executes a DMASEV N instruction to send event N, the DMA_INTEN register controls whether the DMAC:
- Signals an interrupt using the appropriate IRQ.
- Sends the event to all of the threads (see DMA_INTEN register).
Note: The DMAC clears bit [N] when either:
- The DMA_INTEN register is programmed to process the event and the DMAC executes a DMAWFE instruction for that event.
- The DMA_INTEN register is programmed to signal an interrupt and the user write to the corresponding bit in the DMA_INTCLR register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTMIS</name>
          <description>Interrupt Status Register </description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_STATUS</name>
              <description>This bit field provides the status of the interrupts that are active in the DMAC.
- Bit [N] = 0x0: Interrupt N is inactive and therefore IRQ[N] is low.
- Bit [N] = 0x1: Interrupt N is active and therefore IRQ[N] is high.
Note: User must use the DMA_INTCLR register to set bit [N] to 0x0.
Note: Bit [N] is 0x0 if the DMA_INTEN register programs DMASEV to signal an event.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTCLR</name>
          <description>Interrupt Clear Register </description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_CLR</name>
              <description>Controls the clearing of the IRQ outputs:
- Bit [N] = 0x0: The status of IRQ[N] does not change.
- Bit [N] = 0x1: The DMAC sets IRQ[N] low if the DMA_INTEN register programs the DMAC to signal an interrupt.
Otherwise, the status of IRQ[N] does not change (see DMA_INTEN register).</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_FSRD</name>
          <description>Fault Status DMA Manager Register </description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FS_MGR</name>
              <description>This bit provides the fault status of the DMA manager.
Refer to the DMA_FTRD register for more information about the type of fault that occured.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA manager thread is not in the Faulting state.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMA manager thread is in the Faulting state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_FSRC</name>
          <description>Fault Status DMA Channel Register </description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAULT_STATUS</name>
              <description>Each bit provides the fault status of the corresponding channel.
- Bit [N] = 0x0: No fault is present on DMA channel N.
- Bit [N] = 0x1: DMA channel N is in the Faulting or Faulting completing state.
Refer to the DMA_FTRD register for more information about the type of fault that occured. </description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_FTRD</name>
          <description>Fault Type DMA Manager Register </description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBG_INSTR</name>
              <description>If the DMA manager aborts, this bit indicates whether the erroneous instruction was read from the system memory or from the debug interface.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction that generated an abort was read from system memory.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction that generated an abort was read from the debug interface.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INSTR_FETCH_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA manager performs an instruction fetch.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGR_EVNT_ERR</name>
              <description>This bit indicates whether the DMA manager was attempting to execute DMAWFE or DMASEV with inappropriate security permissions.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA manager has appropriate security to execute DMAWFE or DMASEV.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMA manager thread in the non-secure state attempted to execute either:
- DMAWFE to wait for a secure event.
- DMASEV to create a secure event or secure interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAGO_ERR</name>
              <description>This bit indicates whether the DMA manager was attempting to execute DMAGO with inappropriate security permissions.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA manager has appropriate security to execute DMAGO.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMA manager thread in the non-secure state attempted to execute DMAGO to create a DMA channel operating in the secure state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERAND_INVALID</name>
              <description>This bit indicates whether the DMA manager was attempting to execute an instruction operand that was not valid for the configuration of the DMAC.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Valid operand.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invalid operand.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UNDEF_INSTR</name>
              <description>This bit indicates whether the DMA manager was attempting to execute an undefined instruction.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Defined instruction.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Undefined instruction.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DMA_FTR[%s]</name>
          <description>Fault Type for DMA Channel (n) Register </description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCKUP_ERR</name>
              <description>This bit indicates whether the DMA channel has locked-up because of resource starvation.
This fault is an imprecise abort.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA channel has adequate resources.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel has locked-up because of insufficient resources.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_INSTR</name>
              <description>If the DMA channel aborts, this bit indicates whether the erroneous instruction was read from the system memory or from the debug interface.
This fault is an imprecise abort but the bit is only valid when a precise abort occurs.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction that generated an abort was read from system memory.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction that generated an abort was read from the debug interface.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_READ_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel thread performs a data read.
This fault is an imprecise abort.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_WRITE_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the BRESP bus, after the DMA channel thread performs a data write.
This fault is an imprecise abort.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INSTR_FETCH_ERR</name>
              <description>This bit indicates the AXI response that the DMAC receives on the RRESP bus, after the DMA channel thread performs an instruction fetch.
This fault is a precise abort.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OKAY response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EXOKAY, SLVERR, or DECERR response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ST_DATA_UNAVAILABLE</name>
              <description>This bit indicates whether the MFIFO did not contain the data to enable the DMAC to perform the DMAST.
This fault is a precise abort.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MFIFO contains all the data to enable the DMAST to complete.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Previous DMALDs have not put enough data in the MFIFO to enable the DMAST to complete.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFIFO_ERR</name>
              <description>This bit indicates whether the MFIFO prevented the DMA channel thread from executing DMALD or DMAST. Depending on the instruction:
- DMALD
 0x0: MFIFO contains sufficient space.
0x1: MFIFO is too small to hold the data that DMALD requires.
- DMAST
 0x0: MFIFO contains sufficient data.
0x1: MFIFO is too small to store the data to enable DMAST to complete.
This fault is an imprecise abort.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_RDWR_ERR</name>
              <description>This bit indicates whether a DMA channel thread, in the non-secure state, attempts to program the DMA_CCRn register to perform a secure read or secure write.
This fault is a precise abort.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>A DMA channel thread in the non-secure state is not violating the security permissions.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>A DMA channel thread in the non-secure state attempted to perform a secure read or secure write.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_PERIPH_ERR</name>
              <description>This bit indicates whether a DMA channel thread, in the non-secure state, attempts to execute DMAWFP, DMALDP, DMASTP, or DMAFLUSHP with inappropriate security permissions.
This fault is a precise abort.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>A DMA channel thread in the non-secure state is not violating the security permissions.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>A DMA channel thread in the non-secure state attempted to execute either:
- DMAWFP to wait for a secure peripheral.
- DMALDP or DMASTP to notify a secure peripheral.
- DMAFLUSHP to flush a secure peripheral.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_EVNT_ERR</name>
              <description>This bit indicates whether the DMA channel thread attempts to execute DMAWFE or DMASEV with inappropriate security permissions.
This fault is a precise abort.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>A DMA channel thread in the non-secure state is not violating the security permissions.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>A DMA channel thread in the non-secure state attempted to execute either:
- DMAWFE to wait for a secure event.
- DMASEV to create a secure event or secure interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERAND_INVALID</name>
              <description>This bit indicates whether the DMA channel thread was attempting to execute an instruction operand that was not valid for the configuration of the DMAC.
This fault is a precise abort.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Valid operand.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invalid operand.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UNDEF_INSTR</name>
              <description>This bit indicates whether the DMA channel thread was attempting to execute an undefined instruction.
This fault is a precise abort.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Defined instruction.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Undefined instruction.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>8</dimIncrement>
          <name>DMA_CHANNEL_RT_INFO[%s]</name>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>DMA_CSR</name>
            <description>Channel Status for DMA Channel (n) Register </description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNS</name>
                <description>The channel non-secure bit provides the security of the DMA channel.
Note: For more information, see Section DMAGO</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMA channel operates in the secure state.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMA channel operates in the non-secure state.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAWFP_PERIPH</name>
                <description>When the DMA channel thread executes DMAWFP, this bit indicates whether the periph operand was set.
For more information, see Section DMAWFP.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMAWFP executed with the periph operand not set.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMAWFP executed with the periph operand set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAWFP_B_NS</name>
                <description>When the DMA channel thread executes DMAWFP, this bit indicates whether the burst or single operand were set.
For more information, see Section DMAWFP.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMAWFP executed with the single operand set.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMAWFP executed with the burst operand set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKEUP_NUMBER</name>
                <description>If the DMA channel is in the Waiting for event state, or the Waiting for peripheral state, then these bits indicate the event or peripheral number that the channel is waiting for.</description>
                <bitRange>[8:4]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>DMA channel is waiting for event, or peripheral, 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>DMA channel is waiting for event, or peripheral, 1.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>DMA channel is waiting for event, or peripheral, 2.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1F</name>
                    <description>DMA channel is waiting for event, or peripheral, 31.</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHANNEL_STATUS</name>
                <description>The channel status encoding is:
For more information, see Section Thread Operating States.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Stopped.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Executing.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Cache miss.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Updating PC.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Waiting for event.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>At barrier.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Waiting for peripheral.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>Killing.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Completing.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>Faulting completing.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>Faulting.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CPC</name>
            <description>Channel PC for DMA Channel (n) Register </description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PC_CHNL</name>
                <description>Program counter for the DMA channel n thread, where n depends on the address of the register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>8</dim>
          <dimIncrement>32</dimIncrement>
          <name>DMA_RT_CHANNEL_CFG[%s]</name>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>DMA_SAR</name>
            <description>Source Address for DMA Channel (n) Register </description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SRC_ADDR</name>
                <description>Address of the source data for DMA channel n, where n depends on the address of the register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_DAR</name>
            <description>Destination Address for DMA Channel (n) Register </description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DST_ADDR</name>
                <description>Address for the destination data for DMA channel n, where n depends on the address of the register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_CCR</name>
            <description>Channel Control for DMA Channel (n) Register </description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00800200</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENDIAN_SWAP_SIZE</name>
                <description>This bit field defines whether data can be swapped between little-endian (LE) and byte-invariant big-endian (BE-8) formats, and if so, also defines the natural width of the data independently of the source and destination transaction sizes.
This enables unaligned data streams to use the full bus-width, and to be correctly transformed, irrespective of the source and destination address alignments. The format is identical to AxSIZE, except that 0x0 indicates that no swap must occur.
For more information, see Section Endian Swap Size Restrictions.</description>
                <bitRange>[30:28]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No swap, 8-bit data.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Swap bytes within 16-bit data.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Swap bytes within 32-bit data.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Swap bytes within 64-bit data.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Swap bytes within 128-bit data.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DST_CACHE_CTRL</name>
                <description>Programs the state of AWCACHE[3,1:0] a when the DMAC writes the destination data.
- Bit [27]
 0x0: AWCACHE[3] is low.
0x1: AWCACHE[3] is high.
- Bit [26]
 0x0: AWCACHE[1] is low.
0x1: AWCACHE[1] is high.
- Bit [25]
 0x0: AWCACHE[0] is low.
0x1: AWCACHE[0] is high.
Note: AWCACHE[2] is tied low by the DMAC. Setting AWCACHE[3,1] = 0x2 violates the AXI protocol. See the AMBA AXI and ACE Protocol Specification.</description>
                <bitRange>[27:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_PROT_CTRL</name>
                <description>Programs the state of AWPROT[2:0] when the DMAC writes the destination data.
- Bit [24]
 0x0: AWPROT[2] is low.
0x1: AWPROT[2] is high.
- Bit [23]
 0x0: AWPROT[1] is low.
0x1: AWPROT[1] is high.
- Bit [22]
 0x0: AWPROT[0] is low.
0x1: AWPROT[0] is high.
Note: Only DMA channels in the secure state can program AWPROT[1] low, that is, a secure access. If a DMA channel in the non-secure state attempts to set AWPROT[1] low, then the DMA channel aborts.</description>
                <bitRange>[24:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_BURST_LEN</name>
                <description>For each burst, these bits program the number of data transfers that the DMAC performs when it writes the destination data.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction is the product of dst_burst_len and dst_burst_size.
Note: These bits control the state of AWLEN[3:0].</description>
                <bitRange>[21:18]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>1 Data transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>2 Data transfers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>3 Data transfers.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>16 Data transfers.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DST_BURST_SIZE</name>
                <description>For each beat within a burst, it programs the number of bytes that the DMAC writes to the destination.
The total number of bytes that the DMAC writes out of the MFIFO when it executes a DMAST instruction is the product of dst_burst_len and dst_burst_size.
Note: These bits control the state of AWSIZE[2:0].</description>
                <bitRange>[17:15]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Writes 1 byte per beat.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Writes 2 bytes per beat.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Writes 4 bytes per beat.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Writes 8 bytes per beat.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Writes 16 bytes per beat.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DST_INC</name>
                <description>Programs the burst type that the DMAC performs when it writes the destination data.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Fixed-address burst. The DMAC signals AWBURST[0] low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Incrementing-address burst. The DMAC signals AWBURST[0] high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRC_CACHE_CTRL</name>
                <description>Set the bits to control the state of ARCACHE[2:0] when the DMAC reads the source data.
- Bit [13]
 0x0: ARCACHE[2] is low.
0x1: ARCACHE[2] is high.
- Bit [12]
 0x0: ARCACHE[1] is low.
0x1: ARCACHE[1] is high.
- Bit [11]
 0x0: ARCACHE[0] is low.
0x1: ARCACHE[0] is high.
Note: The DMAC ties ARCACHE[3] low. Setting ARCACHE[2:1] = 0b10 violates the AXI protocol. See the AMBA AXI and ACE Protocol Specification.</description>
                <bitRange>[13:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_PROT_CTRL</name>
                <description>Programs the state of ARPROT[2:0] when the DMAC reads the source data.
 - Bit [10]: 
0x0 = ARPROT[2] is low.
0x1 = ARPROT[2] is high.
 - Bit [9]: 
0x0 = ARPROT[1] is low. 
0x1 = ARPROT[1] is high.
 - Bit [8]: 
0x0 = ARPROT[0] is low. 
0x1 = ARPROT[0] is high.
Note: Only DMA channels in the secure state can program ARPROT[1] low, that is, a secure access. If a DMA channel in the non-secure state attempts to set ARPROT[1] low, the DMA channel aborts.</description>
                <bitRange>[10:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_BURST_LEN</name>
                <description>For each burst, these bits program the number of data transfers that the DMAC performs when it reads the source data.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction is the product of SRC_BURST_LEN and SRC_BURST_SIZE bit fields.
Note: These bits control the state of ARLEN[3:0].</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>1 Data transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>2 Data transfers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>3 Data transfers.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>16 Data transfers.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRC_BURST_SIZE</name>
                <description>For each beat within a burst, it programs the number of bytes that the DMAC reads from the source.
The total number of bytes that the DMAC reads into the MFIFO when it executes a DMALD instruction is the product of src_burst_len and src_burst_size.
Note: These bits control the state of ARSIZE[2:0].</description>
                <bitRange>[3:1]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Reads 1 byte per beat.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Reads 2 bytes per beat.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Reads 4 bytes per beat.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Reads 8 bytes per beat.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Reads 16 bytes per beat.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRC_INC</name>
                <description>Programs the burst type that the DMAC performs when it reads the source data.
Note: The DMAC does not generate:
- Locked or exclusive accesses.
- WRAP transfers. Therefore, ARBURST[1] and AWBURST[1] are always low.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Fixed-address burst. The DMAC signals ARBURST[0] low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Incrementing-address burst. The DMAC signals ARBURST[0] high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_LC0</name>
            <description>Loop Counter 0 for DMA Channel (n) Register </description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOOP_COUNTER_ITERATIONS</name>
                <description>The number of loop counter iterations.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_LC1</name>
            <description>Loop Counter 1 for DMA Channel (n) Register </description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOOP_COUNTER_ITERATIONS</name>
                <description>The number of loop counter iterations.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DMA_DBGSTATUS</name>
          <description>Debug Status Register </description>
          <addressOffset>0xD00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_DBGSTATUS</name>
              <description>The debug status encoding is:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Idle.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Busy.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DBGCMD</name>
          <description>Debug Command Register </description>
          <addressOffset>0xD04</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_DBGCMD</name>
              <description>The debug encoding is as follows:</description>
              <bitRange>[1:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Execute the instruction that the DMA_DBGINST0 and DMA_DBGINST1 registers contain.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DBGINST0</name>
          <description>Debug Instruction Register 0 </description>
          <addressOffset>0xD08</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INSTRUCTION_BYTE_1</name>
              <description>Instruction byte 1.</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_0</name>
              <description>Instruction byte 0.</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CHANNEL_NUMBER</name>
              <description>DMA channel number:
Note: When set to 0x1, this bit field selects the DMA channel to debug.</description>
              <bitRange>[10:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA channel 0.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>DMA channel 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>DMA channel 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_THREAD</name>
              <description>The debug thread encoding is as follows:</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA manager thread.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DBGINST1</name>
          <description>Debug Instruction Register 1 </description>
          <addressOffset>0xD0C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INSTRUCTION_BYTE_5</name>
              <description>Instruction byte 5.</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_4</name>
              <description>Instruction byte 4.</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_3</name>
              <description>Instruction byte 3.</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>INSTRUCTION_BYTE_2</name>
              <description>Instruction byte 2.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR0</name>
          <description>Configuration Register 0 </description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x003FF071</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_EVENTS</name>
              <description>Number of interrupt outputs that the DMAC provides.</description>
              <bitRange>[21:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 interrupt outputs, IRQ[31:0].</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_PERIPH_REQ</name>
              <description>Number of peripheral request interfaces that the DMAC provides.</description>
              <bitRange>[16:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 peripheral request interfaces.</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_CHNLS</name>
              <description>Number of DMA channels that the DMAC supports.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>8 DMA channels.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGR_NS_AT_RST</name>
              <description>Indicates DMA manager is in the secure state when the DMAC exited from reset.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA manager is in the secure state.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA manager is in the non-Secure state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_EN</name>
              <description>Indicates the srunning state when the DMAC exited from reset.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped state and waits for an instruction from the Secure APB interface.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERIPH_REQ</name>
              <description>Supports peripheral requests.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMAC provides the number of peripheral request interfaces that the NUM_PERIPH_REQ field specifies.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR1</name>
          <description>Configuration Register 1 </description>
          <addressOffset>0xE04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000035</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_ICACHE_LINES</name>
              <description>Number of an i-cache lines:</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 i-cache lines.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ICACHE_LEN</name>
              <description>The length of an i-cache line:</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>32 Bytes (8 words).</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR2</name>
          <description>Configuration Register 2 </description>
          <addressOffset>0xE08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_ADDR</name>
              <description>This bit field provides the value of boot_addr[31:0] when the DMAC exits from reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR3</name>
          <description>Configuration Register 3 </description>
          <addressOffset>0xE0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INS</name>
              <description>Provides the security state of an event-interrupt resource.
- Bit [N] = 0x0: Event&lt;N&gt; or irq[N] is in the secure state.
- Bit [N] = 0x1: Event&lt;N&gt; or irq[N] is in the non-secure state.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CR4</name>
          <description>Configuration Register 4 </description>
          <addressOffset>0xE10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PNS</name>
              <description>Provides the security state of the peripheral request interfaces.
- Bit [N] = 0x0: Peripheral request interface N is in the secure state.
- Bit [N] = 0x1: Peripheral request interface N is in the non-secure state.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CRD</name>
          <description>DMA Configuration Register </description>
          <addressOffset>0xE14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01F73733</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_BUFFER_DEP</name>
              <description>The number of the lines that the data buffer contains.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32 lines.</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_Q_DEP</name>
              <description>The depth of the read queue.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>8 lines.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_CAP</name>
              <description>Read issuing capability that programs the number of the outstanding read transactions.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 outstanding read transactions.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_Q_DEP</name>
              <description>The depth of the write queue.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>8 lines.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_CAP</name>
              <description>Write issuing capability that programs the number of the outstanding write transactions.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 outstanding write transactions.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_WIDTH</name>
              <description>The data bus width of the AXI master interface.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>64-bit.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_WD</name>
          <description>Watchdog Register </description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_IRQ_ONLY</name>
              <description>This bit controls how the DMAC responds when it detects a lock-up condition.
For more information, see Section Watchdog Abort.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMAC aborts all of the contributing DMA channels and sets IRQ_ABORT high.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The DMAC sets IRQ_ABORT high.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_0</name>
          <description>Peripheral ID Register 0</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PART_NUMBER_0</name>
              <description>Part number 0 value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_1</name>
          <description>Peripheral ID Register 1</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000013</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DESIGNER_0</name>
              <description>Designer ID part 0</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_NUMBER_1</name>
              <description>Part number value 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_2</name>
          <description>Peripheral ID Register 2</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000034</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision ID:</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>r0p0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>r1p0</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>r1p1</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>r1p2</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DESIGNER_1</name>
              <description>Designer ID part 1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH_ID_3</name>
          <description>Peripheral ID Register 3</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>INTEGRATION_CFG</name>
              <description>Indicates DMAC integration configuration</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_0</name>
          <description>Component Identification Register 0</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_0</name>
              <description>Component ID part 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_1</name>
          <description>Component Identification Register 1</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_1</name>
              <description>Component ID part 1</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_2</name>
          <description>Component Identification Register 2</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_2</name>
              <description>Component ID part 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PCELL_ID_3</name>
          <description>Component Identification Register 3</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PCELL_ID_3</name>
              <description>Component ID part 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DMA1_SEC">
      <name>DMA1_NS</name>
      <baseAddress>0x400E0000</baseAddress>
      <interrupt>
        <name>DMA1_IRQ0</name>
        <description>Interrupt request 0. One per DMA request interface (32 in total).</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ1</name>
        <description>Interrupt request 1. One per DMA request interface (32 in total).</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ10</name>
        <description>Interrupt request 10. One per DMA request interface (32 in total).</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ11</name>
        <description>Interrupt request 11. One per DMA request interface (32 in total).</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ12</name>
        <description>Interrupt request 12. One per DMA request interface (32 in total).</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ13</name>
        <description>Interrupt request 13. One per DMA request interface (32 in total).</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ14</name>
        <description>Interrupt request 14. One per DMA request interface (32 in total).</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ15</name>
        <description>Interrupt request 15. One per DMA request interface (32 in total).</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ16</name>
        <description>Interrupt request 16. One per DMA request interface (32 in total).</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ17</name>
        <description>Interrupt request 17. One per DMA request interface (32 in total).</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ18</name>
        <description>Interrupt request 18. One per DMA request interface (32 in total).</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ19</name>
        <description>Interrupt request 19. One per DMA request interface (32 in total).</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ2</name>
        <description>Interrupt request 2. One per DMA request interface (32 in total).</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ20</name>
        <description>Interrupt request 20. One per DMA request interface (32 in total).</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ21</name>
        <description>Interrupt request 21. One per DMA request interface (32 in total).</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ22</name>
        <description>Interrupt request 22. One per DMA request interface (32 in total).</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ23</name>
        <description>Interrupt request 23. One per DMA request interface (32 in total).</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ24</name>
        <description>Interrupt request 24. One per DMA request interface (32 in total).</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ25</name>
        <description>Interrupt request 25. One per DMA request interface (32 in total).</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ26</name>
        <description>Interrupt request 26. One per DMA request interface (32 in total).</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ27</name>
        <description>Interrupt request 27. One per DMA request interface (32 in total).</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ28</name>
        <description>Interrupt request 28. One per DMA request interface (32 in total).</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ29</name>
        <description>Interrupt request 29. One per DMA request interface (32 in total).</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ3</name>
        <description>Interrupt request 3. One per DMA request interface (32 in total).</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ30</name>
        <description>Interrupt request 30. One per DMA request interface (32 in total).</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ31</name>
        <description>Interrupt request 31. One per DMA request interface (32 in total).</description>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ4</name>
        <description>Interrupt request 4. One per DMA request interface (32 in total).</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ5</name>
        <description>Interrupt request 5. One per DMA request interface (32 in total).</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ6</name>
        <description>Interrupt request 6. One per DMA request interface (32 in total).</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ7</name>
        <description>Interrupt request 7. One per DMA request interface (32 in total).</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ8</name>
        <description>Interrupt request 8. One per DMA request interface (32 in total).</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ9</name>
        <description>Interrupt request 9. One per DMA request interface (32 in total).</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>DMA1_IRQ_ABORT</name>
        <description>DMAC aborted execution of a program thread.</description>
        <value>32</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>NPU_HP</name>
      <baseAddress>0x400E1000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>NPUHP_ID</name>
          <description>ID Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x10104201</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARCH_MAJOR_REV</name>
              <description>This is the major architecture version number, a in the architecture version a.b</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_MINOR_REV</name>
              <description>This is the minor architecture version number, b in the architecture version a.b</description>
              <bitRange>[27:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_PATCH_REV</name>
              <description>This is the patch number of the architecture version a.b</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRODUCT_MAJOR</name>
              <description>This is the X-part of the ML00X product number</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_MAJOR</name>
              <description>This is the n for the R-part of an RnPn release number</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_MINOR</name>
              <description>This is the n for the P-part of an RnPn release number</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION_STATUS</name>
              <description>This is the version of the product</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_HISTORY_MASK</name>
              <description>IRQ history mask.
This is used for debug purposes. Each IRQ or event operation provides a 16-bit mask which is
logically OR-ed into these bits.
The bits can be cleared via their counterparts in the NPUHP_CMD[CLEAR_IRQ_HISTORY] field.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FAULTING_CHANNEL</name>
              <description>Faulting channel on a bus abort.
Read operations: 
 Write operations: </description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cmd</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IFM</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Weights</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Bias and Scale</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Mem2Mem</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>OFM</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Mem2Mem</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FAULTING_INTERFACE</name>
              <description>Faulting interface on bus abort. </description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI-M0 </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI-M1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECC_FAULT</name>
              <description>ECC state for internal RAMs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No fault </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ECC fault signalled. Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WD_FAULT</name>
              <description>Weight decoder state.
Note: This bit is never set in this product.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No fault </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Weight decoder decompression fault signalled. Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PMU_IRQ_RAISED</name>
              <description>PMU IRQ status.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PMU IRQ not raised</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMU IRQ raised. Can be cleared via the NPUHP_CMD[CLEAR_IRQ] field.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_REACHED</name>
              <description>Command stream end status.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>End not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>End reached. Can be cleared by writing NPUHP_QBASE0 / NPUHP_QBASE1 or NPUHP_QSIZE when NPU is in stopped state.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_PARSE_ERROR</name>
              <description>Command stream parsing error status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command stream parsing error detected. Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET_STATUS</name>
              <description>Reset status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>NPU is not being reset and can be accessed as normal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset is ongoing and only this register can be read (other registers read as 0 and writes are ignored).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUS_STATUS</name>
              <description>Bus status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bus abort detected and processing halted (NPU has reached IDLE state and does not start to process any more commands / AXI transactions). Can only be cleared by reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ_RAISED</name>
              <description>Raw IRQ status. </description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IRQ not raised</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IRQ raised. Can be cleared via the NPUHP_CMD[CLEAR_IRQ] field.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STATE</name>
              <description>NPU state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CMD</name>
          <description>Command Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLEAR_IRQ_HISTORY</name>
              <description>Clears the IRQ history mask.
When bit [k] is set, then the corresponding bit [k] of the NPUHP_STATUS[IRQ_HISTORY_MASK] field is cleared.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_REQUEST</name>
              <description>Write 1 to this bit to request STOP after completing any already-started commands.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_Q_ENABLE</name>
              <description>Write 1 to this bit to enable power off using Power Q-interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_Q_ENABLE</name>
              <description>Write 1 to this bit to enable clock off using Clock Q-interface and enable the master clock gate.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR_IRQ</name>
              <description>Write 1 to clear the IRQ status in the STATUS register.
Writing 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSITION_TO_RUNNING_STATE</name>
              <description>Write 1 to transition the NPU to running state.
Writing 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_RESET</name>
          <description>Reset Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PENDING_CSL</name>
              <description>Current security level </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PENDING_CPL</name>
              <description>Current privilege level </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>User </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QBASE0</name>
          <description>Queue Base Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QBASE0</name>
              <description>Lower bytes of the base address value for the command stream (4-byte-aligned)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QBASE1</name>
          <description>Queue Base Register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QBASE1</name>
              <description>Upper bytes of the base address value for the command stream (4-byte-aligned)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QREAD</name>
          <description>Queue Read Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QREAD</name>
              <description>The read offset (in bytes) of the current command under execution. Multiple of 4 in the range 0 to 16 MB.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QCONFIG</name>
          <description>Queue Configuration Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QCONFIG</name>
              <description>AXI configuration for the command stream in the range 0-3. Same encoding as for NPUHP_REGIONCFG.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_QSIZE</name>
          <description>Queue Size Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QSIZE</name>
              <description>Size (in bytes) of the next command stream to be executed by the NPU. Multiple of 4 in the range 0 to 16 MB.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PROT</name>
          <description>Protection Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE_CSL</name>
              <description>Current security level </description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Secure </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-secure</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE_CPL</name>
              <description>Current privilege level </description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>User </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Privileged</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CONFIG</name>
          <description>Module Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00003008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT</name>
              <description>Product configuration</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUSTOM_DMA</name>
              <description>Custom DMA configuration</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Custom DMA not implemented</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SHRAM_SIZE</name>
              <description>Total size of internal SHRAM</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x30</name>
                  <description>48KB</description>
                  <value>0x30</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_STREAM_VERSION</name>
              <description>Command stream version accepted by this NPU</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MACS_PER_CC</name>
              <description>MACs/clock cycle</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>256</description>
                  <value>0x8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_LOCK</name>
          <description>Lock Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>32-bit value for the lock configuration.
To try to claim the lock, write a non-zero ID value and read back to see if the value was
accepted.
To release the lock (that contains your non-zero ID value), write 0 to the lock register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_REGIONCFG</name>
          <description>Region Configuration Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGION7</name>
              <description>Region 7 configuration</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION6</name>
              <description>Region 6 configuration</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION5</name>
              <description>Region 5 configuration</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION4</name>
              <description>Region 4 configuration</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION3</name>
              <description>Region 3 configuration</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION2</name>
              <description>Region 2 configuration</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION1</name>
              <description>Region 1 configuration</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGION0</name>
              <description>Region 0 configuration</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT0</name>
          <description>AXI Limit Register 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT1</name>
          <description>AXI Limit Register 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT2</name>
          <description>AXI Limit Register 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_AXI_LIMIT3</name>
          <description>AXI Limit Register 3</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_OUTSTANDING_WRITE_M1</name>
              <description>Maximum number of [outstanding AXI write transactions - 1] in range 0 to 15</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READ_M1</name>
              <description>Maximum number of [outstanding AXI read transactions - 1] in range 0 to 31</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMTYPE</name>
              <description>Memory type</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device Non-Bufferable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Device Bufferable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Normal, Non-Cacheable, Non-Bufferable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Normal, Non-Cacheable, Bufferable</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Write Through, No Allocate</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Write Through, Read Allocate</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Write Through, Write Allocate</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Write Through, Read and Write Allocate</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Write Back, No Allocate</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Write Back, Read Allocate</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Write Back, Write Allocate</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Write Back, Read and Write Allocate</description>
                  <value>0xB</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BEATS</name>
              <description>Burst split alignment</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>128 bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>256 bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP0</name>
          <description>Base Pointer Register 0</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP1</name>
          <description>Base Pointer Register 1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP2</name>
          <description>Base Pointer Register 2</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP3</name>
          <description>Base Pointer Register 3</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP4</name>
          <description>Base Pointer Register 4</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP5</name>
          <description>Base Pointer Register 5</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP6</name>
          <description>Base Pointer Register 6</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP7</name>
          <description>Base Pointer Register 7</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP8</name>
          <description>Base Pointer Register 8</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP9</name>
          <description>Base Pointer Register 9</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP10</name>
          <description>Base Pointer Register 10</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP11</name>
          <description>Base Pointer Register 11</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP12</name>
          <description>Base Pointer Register 12</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP13</name>
          <description>Base Pointer Register 13</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP14</name>
          <description>Base Pointer Register 14</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The low word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_BASEP15</name>
          <description>Base Pointer Register 15</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_WORD</name>
              <description>The high word of the 64-bit address</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCR</name>
          <description>Performance Monitor Control Register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_EVENT_CNT</name>
              <description>Number of PMU event counters (4 event counters are available)</description>
              <bitRange>[15:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_EN</name>
              <description>Allows to enable/disable PMU by command stream operation NPU_OP_PMU_MASK. Note that the [CNT_EN] field in this register must be enabled for the PMU to be active.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT_RST</name>
              <description>Reset PMU cycle counter.
Writing 1 to this field resets the cycle counter. If the cycle counter is active, it will continue
counting after reset.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>EVENT_CNT_RST</name>
              <description>Reset PMU event counter.
Writing 1 to this field resets all event counters. If any counter is active, it will continue counting
after reset.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CNT_EN</name>
              <description>Enable PMU.
This is the master switch. When the switch is disabled, the PMU is always off. Writing 1 to this field enables PMU operation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCNTENSET</name>
          <description>Performance Monitor Count Enable Set Register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT</name>
              <description>Enable PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter is enabled. When written, it enables the cycle counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3</name>
              <description>Enable PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2</name>
              <description>Enable PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1</name>
              <description>Enable PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0</name>
              <description>Enable PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it enables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCNTENCLR</name>
          <description>Performance Monitor Count Enable Clear Register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT</name>
              <description>Disable PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter is enabled. When written, it disables the cycle counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3</name>
              <description>Disable PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2</name>
              <description>Disable PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1</name>
              <description>Disable PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0</name>
              <description>Disable PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter is enabled. When written, it disables the event counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMOVSSET</name>
          <description>Performance Monitor Overflow Status Set Register</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_OVF</name>
              <description>Set overflow for PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_OVF</name>
              <description>Set overflow for PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_OVF</name>
              <description>Set overflow for PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_OVF</name>
              <description>Set overflow for PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_OVF</name>
              <description>Set overflow for PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it sets the overflow bit to 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMOVSCLR</name>
          <description>Performance Monitor Overflow Status Clear Register</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_OVF</name>
              <description>Clear overflow for PMU cycle counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_OVF</name>
              <description>Clear overflow for PMU event counter 3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_OVF</name>
              <description>Clear overflow for PMU event counter 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_OVF</name>
              <description>Clear overflow for PMU event counter 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_OVF</name>
              <description>Clear overflow for PMU event counter 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter has not overflowed. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter has overflowed. When written, it clears the overflow bit to 0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMINTSET</name>
          <description>Performance Monitor Interrupt Set Register</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_INT</name>
              <description>Enable overflow interrupt request for PMU cycle counter.
interrupt request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter overflow interrupt request is enabled. When written, it enables the cycle count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 3.
interrupt request.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 2.
interrupt request.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 1.
interrupt request.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_INT</name>
              <description>Enable overflow interrupt request for PMU event counter 0.
interrupt request.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt request is enabled. When written, it enables the event count overflow</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMINTCLR</name>
          <description>Performance Monitor Interrupt Clear Register</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_INT</name>
              <description>Disable overflow interrupt request for PMU cycle counter.
overflow interrupt request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the cycle counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the cycle counter overflow interrupt-request is enabled. When written, it disables the cycle count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_3_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 3.
overflow interrupt request.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_2_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 2.
overflow interrupt request.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_1_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 1.
overflow interrupt request.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVENT_CNT_0_INT</name>
              <description>Disable overflow interrupt request for PMU event counter 0.
overflow interrupt request.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When read, it means the event counter overflow interrupt-request is disabled. When written, it has no effect.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When read, it means the event counter overflow interrupt-request is enabled. When written, it disables the event count</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCCNTR_LO</name>
          <description>Performance Monitor Cycle Count Low Register</description>
          <addressOffset>0x1A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_LO</name>
              <description>Cycle count low</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCCNTR_HI</name>
          <description>Performance Monitor Cycle Count High Register</description>
          <addressOffset>0x1A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CYCLE_CNT_HI</name>
              <description>Cycle count high</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMCAXI_CHAN</name>
          <description>Performance Monitor AXI Channel Select Register</description>
          <addressOffset>0x1AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BW_CH_SEL_EN</name>
              <description>Enable bandwidth channel selector</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI BW events measured for all channels</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI BW events measured for channel specified by [CH_SEL]</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AXI_CNT_SEL</name>
              <description>Select AXI counter to monitor for latency measurements
A maximum of two separate outstanding transaction queues can be connected to each AXI
interface. The counters are used to express the maximum number of outstanding jobs per queue.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI counter 0 (AXI port 0, outstanding counter 0)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI counter 1 (AXI port 0, outstanding counter 1)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>AXI counter 2 (AXI port 1, outstanding counter 0)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>AXI counter 3 (AXI port 1, outstanding counter 1)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_SEL</name>
              <description>Select channel to monitor for bandwidth or latency measurements
Read operations:
 Write operations: </description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cmd </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IFM </description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Weights </description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Bias and Scale</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Mem2Mem</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>OFM </description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Mem2Mem</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR0</name>
          <description>Performance Monitor Event Count Register 0</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR1</name>
          <description>Performance Monitor Event Count Register 1</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR2</name>
          <description>Performance Monitor Event Count Register 2</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVCNTR3</name>
          <description>Performance Monitor Event Count Register 3</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_CNTR</name>
              <description>Event counter value</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER0</name>
          <description>Performance Monitor Event Type Register 0</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER1</name>
          <description>Performance Monitor Event Type Register 1</description>
          <addressOffset>0x384</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER2</name>
          <description>Performance Monitor Event Type Register 2</description>
          <addressOffset>0x388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PMEVTYPER3</name>
          <description>Performance Monitor Event Type Register 3</description>
          <addressOffset>0x38C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EV_TYPE</name>
              <description>Event type.
For field encoding (list of supported PMU events), refer to the Arm(R) Ethos(TM)-U55 NPU Technical Reference Manual.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID4</name>
          <description>Peripheral ID Register 4</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID4</name>
              <description>Byte 4 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID5</name>
          <description>Peripheral ID Register 5</description>
          <addressOffset>0xFD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID5</name>
              <description>Byte 5 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID6</name>
          <description>Peripheral ID Register 6</description>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID6</name>
              <description>Byte 6 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID7</name>
          <description>Peripheral ID Register 7</description>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID7</name>
              <description>Byte 7 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID0</name>
          <description>Peripheral ID Register 0</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID0</name>
              <description>Byte 0 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID1</name>
          <description>Peripheral ID Register 1</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID1</name>
              <description>Byte 1 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID2</name>
          <description>Peripheral ID Register 2</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID2</name>
              <description>Byte 2 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_PID3</name>
          <description>Peripheral ID Register 3</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PID3</name>
              <description>Byte 3 of Peripheral ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID0</name>
          <description>Component ID Register 0</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID0</name>
              <description>Byte 0 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID1</name>
          <description>Component ID Register 1</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID1</name>
              <description>Byte 1 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID2</name>
          <description>Component ID Register 2</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID2</name>
              <description>Byte 2 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPUHP_CID3</name>
          <description>Component ID Register 3</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CID3</name>
              <description>Byte 3 of Component ID (lower 8 bits valid)</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EVTRTR1</name>
      <groupName>EVTRTR</groupName>
      <baseAddress>0x400E2000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>160</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>DMA_CTRL[%s]</name>
          <description>DMA/Event Router Control and Status Register (n)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK_TYPE</name>
              <description>DMA handshake type status for DMA peripheral</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Peripheral completes the REQ-ACK handshake with DMA controller. Event Router passing through REQ-ACK between DMA controller and peripheral.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Event Router completes the REQ-ACK handshake with DMA controller. Peripheral raises DMA request without responding to ACK from DMA controller.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENA</name>
              <description>DMA channel enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable DMA channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DMA channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL</name>
              <description>Select one channel from the four input groups
Note: This field is only available for EVTRTR0. It is RESERVED and treated as RAZ/WI (read-as-zero, write-ignored) for EVTRTR1 and EVTRTR2.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select group 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select group 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select group 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select group 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_REQ_CTRL</name>
          <description>DMA REQ Control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CB</name>
              <description>Enable DMA request on DMACBREQ</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CS</name>
              <description>Enable DMA request on DMACSREQ</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLB</name>
              <description>Enable DMA request on DMACLBREQ</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLS</name>
              <description>Enable DMA request on DMACLSREQ</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_ACK_TYPE0</name>
          <description>DMA Handshake Type Register 0</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFF00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_ACK_TYPE1</name>
          <description>DMA Handshake Type Register 1</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF3FF300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_ACK_TYPE2</name>
          <description>DMA Handshake Type Register 2</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC3FF0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_ACK_TYPE3</name>
          <description>DMA Handshake Type Register 3</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK</name>
              <description>Select DMA handshake type for DMA group #3</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>M55HP_CFG</name>
      <baseAddress>0x400F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>HP_DMA_CTRL</name>
          <description>DMA1 Boot Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>SW_RST</name>
              <description>Software reset for DMA1</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset DMA1. This bit is self-cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_MANAGER</name>
              <description>When DMA1 exits from reset, this bit controls the security state of the DMA manager thread</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Assigns DMA manager to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assigns DMA manager to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_DMA_IRQ</name>
          <description>DMA1 Boot IRQ Non-Secure Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_IRQ</name>
              <description>Controls the security state of an event-interrupt resource, when DMA1 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA1 assigns event x or IRQ[x] to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA1 assigns event x or IRQ[x] to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_DMA_PERIPH</name>
          <description>DMA1 Boot Peripheral Non-Secure Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_PERIPH</name>
              <description>Controls the security state of a peripheral request interface, when DMA1 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA1 assigns peripheral request interface x to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA1 assigns peripheral request interface x to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_DMA_SEL</name>
          <description>DMA1 Select Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF000000</resetMask>
          <fields>
            <field>
              <name>FLT_ENA</name>
              <description>For each bit:</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable glitch-filter for GPIO input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable glitch-filter for GPIO input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HP_CLK_ENA</name>
          <description>Peripheral Clock Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>DMA_CKEN</name>
              <description>Enable clock for DMA1 and EVTRTR1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NPU_CKEN</name>
              <description>Enable clock for NPU-HP</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT_HP_CTRL</name>
      <groupName>WDT</groupName>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_WDOGLOAD</name>
          <description>Watchdog Load Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDOGLOAD</name>
              <description>When
this bit field is written, the count is immediately restarted from the new value.
 The minimum
valid value for this field is 0x1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGVALUE</name>
          <description>Watchdog Value Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDOGVALUE</name>
              <description>This bit field gives the current value of the decrementing counter.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGCONTROL</name>
          <description>Watchdog Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESEN</name>
              <description>Enables the watchdog reset output, WDOGRES. Acts as a mask for the reset output. </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTEN</name>
              <description>Enables the interrupt event, WDT_IRQ. 
 Reloads the counter from the value in WDT_WDOGLOAD register when the interrupt is enabled, afterpreviously being disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The counter and the interrupt are disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The counter and the interrupt are enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGINTCLR</name>
          <description>Watchdog Clear Interrupt Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>WDOGINTCLR</name>
              <description>A write of any value clears the watchdog interrupt, and reloads
the counter from the value in WDT_WDOGLOAD register.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGRIS</name>
          <description>Watchdog Raw Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RAW_WATCHDOG_INTERRUPT</name>
              <description>Enables the raw interrupt status from the counter. This value is
ANDed with the value of WDT_WDOGCONTROL[INTEN] bit to create the masked interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGMIS</name>
          <description>Watchdog Interrupt Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WATCHDOG_INTERRUPT</name>
              <description>Enables the masked interrupt status from the counter. This value is the logical AND of the raw interrupt status with the WDT_WDOGCONTROL[INTEN] bit, and isthe value of the WDT_IRQ.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGLOCK</name>
          <description>Watchdog Lock Register</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE_REGISTER_WRITES</name>
              <description>Enable write access to all other registers by writing 0x1ACC_E551. Disable write access by
writing any other value.</description>
              <bitRange>[31:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGISTER_WRITE_ENABLE_STATUS</name>
              <description>Write access status:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write access to all other registers is enabled. </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Write access to all other registers is disabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID4</name>
          <description>Peripheral ID Register 4</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCK_COUNT</name>
              <description>Block count</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEP106_C_CODE</name>
              <description>JEP106 continuation code value</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID0</name>
          <description>Peripheral ID Register 0</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000024</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PART_NUMBER_7_0</name>
              <description>Part number</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID1</name>
          <description>Peripheral ID Register 1</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>JEP106_ID_3_0</name>
              <description>JEP106 identity code [3:0]</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PART_NUMBER_11_8</name>
              <description>Part number</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID2</name>
          <description>Peripheral ID Register 2</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision of the TZC-400</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEDEC_USED</name>
              <description>Indicates that the TZC-400 uses a manufacturer identity code allocated by JEDEC according to JEP106.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>JEP106_ID_6_4</name>
              <description>JEP106 identity code [6:4]</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPERIPHID3</name>
          <description>Peripheral ID Register 3</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECO_REVISION_NUMBER</name>
              <description>ECO revision number</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUSTOMER_MODIFICATION_NUMBER</name>
              <description>Customer modification number</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID0</name>
          <description>Component ID Register 0</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_0</name>
              <description>Component ID 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID1</name>
          <description>Component ID Register 1</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_1</name>
              <description>Component ID 1</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID2</name>
          <description>Component ID Register 2</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_2</name>
              <description>Component ID 2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WDOGPCELLID3</name>
          <description>Component ID Register 3</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMPONENT_ID_3</name>
              <description>Component ID 3</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="WDT_HP_CTRL">
      <name>WDT_HP_REFRESH</name>
      <baseAddress>0x40101000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LPRTC</name>
      <baseAddress>0x42000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>40</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>LPRTC_IRQ</name>
        <description>LPRTC interrupt request</description>
        <value>350</value>
      </interrupt>
      <registers>
        <register>
          <name>LPRTC_CCVR</name>
          <description>Current Counter Value Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRENT_COUNTER_VALUE</name>
              <description>When read, this register contains the current value of the internal counter. This value is always read coherently.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CMR</name>
          <description>Counter Match Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_MATCH</name>
              <description>When the internal counter matches this value, an interrupt is generated, provided interrupt generation is enabled.
When appropriate, this value is written coherently. Only when all the bytes are written, the value of this register is used by the interrupt detection logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CLR</name>
          <description>Counter Load Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_LOAD</name>
              <description>Loaded into the counter as counter load value, which is written coherently.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CCR</name>
          <description>Counter Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_PSCLR_EN</name>
              <description>Controls the usage of the prescaler feature.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the prescaler.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the prescaler.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_WEN</name>
              <description>Controls the wrap enable. Forces the counter to wrap to 0 when a match occurs, instead of waiting until the maximum count is reached.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the wrap.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the wrap.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_EN</name>
              <description>Controls counting in the counter.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the counter.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the counter.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_MASK</name>
              <description>Controls the interrupt mask. Determines whether an internally generated interrupt shall assert the IRQ line.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks the interrupt.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks the interrupt.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPRTC_IEN</name>
              <description>Controls the interrupt enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the interrupt generation.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the interrupt generation.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_STAT</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_STAT</name>
              <description>Masked interrupt status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is inactive. The IRQ line is not asserted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is active. The IRQ line is asserted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_RSTAT</name>
          <description>Interrupt Raw Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_RSTAT</name>
              <description>Raw interrupt status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is inactive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_EOI</name>
          <description>End-of-Interrupt Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_EOI</name>
              <description>By reading this bit, the match interrupt is cleared. Performing a read-to-clear on interrupt, the interrupt is cleared at the end of the read.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_COMP_VERSION</name>
          <description>LPRTC Component Version Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3230372A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPRTC_COMP_VERSION</name>
              <description>Component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CPSR</name>
          <description>Counter Prescaler Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00008000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_PRESCALER_VALUE</name>
              <description>Counter prescaler value. This bit field is used to prescale the rate at which the LPRTC counter updates. The prescaler value is in the range 1-65536. By default, the counter increments at a 1 Hz rate when the prescaler is enabled and precise 32.768 kHz clock source is used.
When appropriate, this bit field is written coherently. Only when all the bytes are written, the register is used by the prescaler counter logic.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPRTC_CPCVR</name>
          <description>Current Prescaler Counter Value Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRENT_PRESCALER_COUNTER_VALUE</name>
              <description>When read, this bit field provides the current value of the internal prescaler counter. This value is always read coherently.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIMER</name>
      <baseAddress>0x42001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>176</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>LPTIMER0_IRQ</name>
        <description>LPTIMER0 interrupt request</description>
        <value>346</value>
      </interrupt>
      <interrupt>
        <name>LPTIMER1_IRQ</name>
        <description>LPTIMER1 interrupt request</description>
        <value>347</value>
      </interrupt>
      <interrupt>
        <name>LPTIMER2_IRQ</name>
        <description>LPTIMER2 interrupt request</description>
        <value>348</value>
      </interrupt>
      <interrupt>
        <name>LPTIMER3_IRQ</name>
        <description>LPTIMER3 interrupt request</description>
        <value>349</value>
      </interrupt>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>20</dimIncrement>
          <name>LPTIMER_CHANNEL_CFG[%s]</name>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>LPTIMER_LOADCOUNT</name>
            <description>Timer (n) Load Count Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_LOADCOUNT</name>
                <description>Value to be loaded into Timer (n). This is the value from which counting commences. Any value written to this register is loaded into the associated timer.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_CURRENTVAL</name>
            <description>Timer (n) Current Value Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_CURRENTVALUE</name>
                <description>Current Value of Timer (n)</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_CONTROLREG</name>
            <description>Timer (n) Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000010</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_0N100PWM_EN</name>
                <description>0% and 100% PWM duty cycle mode for Timer (n).
Hardcoded to enabled state to reduce software overhead.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_PWM</name>
                <description>Pulse Width Modulation of Timer (n) toggle output.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>PWM is disabled (normal toggle)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>PWM is enabled (PWM toggle)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_INTERRUPT_MASK</name>
                <description>Timer interrupt mask for Timer (n).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Timer (n) interrupt is unmasked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Timer (n) interrupt is masked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_MODE</name>
                <description>Timer mode for Timer (n).
Note: All bits of the LPTIMERn_LOADCOUNT register must be set to 1 before enabling Timer (n) in free-running mode.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Free-running count</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>User-defined count</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMER_ENABLE</name>
                <description>Timer enable bit for Timer (n).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Timer (n) is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Timer (n) is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_EOI</name>
            <description>Timer (n) End-of-Interrupt Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_EOI</name>
                <description>End-of-Interrupt for Timer (n).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIMER_INTSTAT</name>
            <description>Timer (n) Interrupt Status Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMERN_INTSTATUS</name>
                <description>Interrupt status for Timer (n) after mask:</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Timer (n) interrupt is inactive. IRQ line is not asserted.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Timer (n) interrupt is active. IRQ line is asserted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>LPTIMERS_INTSTATUS</name>
          <description>Timers Interrupt Status Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_INTSTATUS</name>
              <description>Interrupt status of all timers after mask, where:
Bit 3: LPTIMER3
Bit 2: LPTIMER2
Bit 1: LPTIMER1
Bit 0: LPTIMER0
For each bit:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timer (n) interrupt is inactive. IRQ line is not asserted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timer (n) interrupt is active. IRQ line is asserted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIMERS_EOI</name>
          <description>Timers End-of-Interrupt Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_EOI</name>
              <description>End-of-Interrupt for all timers, where:
Bit 3: LPTIMER3
Bit 2: LPTIMER2
Bit 1: LPTIMER1
Bit 0: LPTIMER0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIMERS_RAWINTSTATUS</name>
          <description>Timers Raw Interrupt Status Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_RAWINTSTAT</name>
              <description>Raw interrupt status of all timers, where:
Bit 3: LPTIMER3
Bit 2: LPTIMER2
Bit 1: LPTIMER1
Bit 0: LPTIMER0
For each bit:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Raw Timer (n) interrupt is inactive.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Raw Timer (n) interrupt is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIMERS_COMP_VERSION</name>
          <description>LPTIMER Component Version</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3231322A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMERS_COMP_VERSION</name>
              <description>LPTIMER version number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPGPIO</name>
      <groupName>GPIO</groupName>
      <baseAddress>0x42002000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>120</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>LPGPIO_COMB_IRQ</name>
        <description>LPGPIO combined interrupt request</description>
        <value>57</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ0</name>
        <description>LPGPIO interrupt request 0</description>
        <value>171</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ1</name>
        <description>LPGPIO interrupt request 1</description>
        <value>172</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ2</name>
        <description>LPGPIO interrupt request 2</description>
        <value>173</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ3</name>
        <description>LPGPIO interrupt request 3</description>
        <value>174</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ4</name>
        <description>LPGPIO interrupt request 4</description>
        <value>175</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ5</name>
        <description>LPGPIO interrupt request 5</description>
        <value>176</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ6</name>
        <description>LPGPIO interrupt request 6</description>
        <value>177</value>
      </interrupt>
      <interrupt>
        <name>LPGPIO_IRQ7</name>
        <description>LPGPIO interrupt request 7</description>
        <value>178</value>
      </interrupt>
      <registers>
        <register>
          <name>GPIO_SWPORTA_DR</name>
          <description>GPIO Port Data Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_DR</name>
              <description>The values written to this field are output on the GPIO signals if the corresponding GPIO_SWPORTA_DDR[GPIO_SWPORTA_DDR] field is set to 1.
The value read back is equal to the last value written to this field.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_SWPORTA_DDR</name>
          <description>GPIO Port Data Direction Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_DDR</name>
              <description>The values written to this field independently control the data direction of the corresponding GPIO signal.
The direction is input after system reset by default.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Input direction</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Output direction</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_SWPORTA_CTL</name>
          <description>GPIO Port Data Source Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_SWPORTA_CTL</name>
              <description>Individual bit values will indicate whether the data source is hardware (aux port) or software (normal operation).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Software mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Hardware Mode (allows LPTIMER I/O on the LPGPIO pin)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTEN</name>
          <description>GPIO Port Interrupt Enable Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTEN</name>
              <description>Writing a 1 to a bit of this field configures the corresponding GPIO to become an interrupt signal. 
Interrupts are disabled on the corresponding bits if the corresponding bit of GPIO_SWPORTA_DDR[GPIO_SWPORTA_DDR] field is set to 1 (output).
The generation of interrupts are disabled by default. </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTMASK</name>
          <description>GPIO Port Interrupt Mask Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTMASK</name>
              <description>Writing a 1 to a bit in this field masks the interrupt generation capability for this corresponding GPIO signal. Otherwise interrupts are allowed through. The unmasked status is read as well as the resultant status after masking.
 All interrupt bits are unmasked by default. </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt bits are unmasked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt bits are masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTTYPE_LEVEL</name>
          <description>GPIO Port Interrupt Level Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTTYPE_LEVEL</name>
              <description>Writing a 0 to a bit of this field configures the interrupt type to be level-sensitive. Otherwise, it is edge-sensitive.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is level sensitive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is edge sensitive</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INT_POLARITY</name>
          <description>GPIO Port Interrupt Polarity Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_POLARITY</name>
              <description>Writing a 0 to a bit of this field configures the interrupt type to Falling edge or Active-low sensitive. Otherwise, it is Rising edge or Active-high sensitive.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active-low polarity / Falling edge</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active-high polarity / Rising edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INTSTATUS</name>
          <description>GPIO Port Interrupt Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INTSTATUS</name>
              <description>Interrupt status after masks</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_RAW_INTSTATUS</name>
          <description>GPIO Port Raw Interrupt Status Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_RAW_INTSTATUS</name>
              <description>Raw interrupt status. This status is before masks.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_DEBOUNCE</name>
          <description>GPIO Port Debounce Enable Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_DEBOUNCE</name>
              <description>Writing a 1 to a bit in this field enables the debouncing circuitry. A signal must be valid for two periods of the 32-k clock before it is internally processed.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No debounce</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable debounce</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_PORTA_EOI</name>
          <description>GPIO Port End Of Interrupt Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_PORTA_EOI</name>
              <description>Writing a 1 to a bit of this field, clears the corresponding interrupt. </description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear Interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_EXT_PORTA</name>
          <description>GPIO External Port Read Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_EXT_PORTA</name>
              <description>This register provides either the data on the GPIO pins or the contents of the GPIO_SWPORTA_DR, depending on the value of GPIO_SWPORTA_DDR.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_LS_SYNC</name>
          <description>Synchronization Level Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_LS_SYNC</name>
              <description>Writing a 1 to this bit results in all level-sensitive interrupts being synchronized to PCLK_INTR.
 They are not synchronized to PCLK_INTR by default.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No synchronization to PCLK_INTR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Synchronize to PCLK_INTR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_INT_BOTHEDGE</name>
          <description>GPIO Port Interrupt Both Edge Type Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_INT_BOTHEDGE</name>
              <description>Writing a 1 to a bit of this field enables the generation of interrupts on both the Rising edge and the Falling edge of an external input signal.
The values programmed in the registers GPIO_INTTYPE_LEVEL and GPIO_INT_POLARITY for this particular bit are not considered when the corresponding bit of this field is set to 1.
Writing a 0 to a bit of this field makes the interrupt type to depend on the value of the corresponding bits in the GPIO_INTTYPE_LEVEL and GPIO_INT_POLARITY registers.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Single edge sensitive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Both edge sensitive</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_VER_ID_CODE</name>
          <description>GPIO Version ID Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3231332A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_VER_ID_CODE</name>
              <description>Module version ID code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_CONFIG_REG2</name>
          <description>Module Configuration Register 2</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00039CE7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENCODED_ID_PWIDTH_D</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[19:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENCODED_ID_PWIDTH_C</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[14:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENCODED_ID_PWIDTH_B</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[9:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENCODED_ID_PWIDTH_A</name>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Port is 8 bits wide</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO_CONFIG_REG1</name>
          <description>Module Configuration Register 1</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x003F70F2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_BOTH_EDGE_TYPE</name>
              <description>The value of this bit defines the interrupt generation type.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt generation on both rising and falling edge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENCODED_ID_WIDTH</name>
              <description>The value of this field defines the encoded ID width.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO_ID</name>
              <description>The value of this bit defines the GPIO ID.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GPIO_ID not included</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD_ENCODED_PARAMS</name>
              <description>The value of this bit defines the encoded parameters.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Encoded parameters added</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBOUNCE</name>
              <description>The value of this bit defines the debounce capability.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Included debounce capability</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PORTA_INTR</name>
              <description>The value of this bit defines the Port A interrupts configuration.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PORT A is required to be used as an interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HW_PORTD</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_PORTC</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_PORTB</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_PORTA</name>
              <description>The value of this bit defines the Port A hardware configuration.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Port A has no external auxiliary hardware signals - GPIOs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Port A has external auxiliary hardware signals - LPGPIO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PORTD_SINGLE_CTL</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PORTC_SINGLE_CTL</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PORTB_SINGLE_CTL</name>
              <description>Reserved for multi-port configuration</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PORTA_SINGLE_CTL</name>
              <description>The value of this bit defines the Port A single source configuration.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Port A is controlled from a two sources - LPGPIO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Port A is controlled from a single source - GPIOs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_PORTS</name>
              <description>The value of this field defines the number of ports.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Number of ports is 1</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>The value of this field defines the APB data width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>APB data width is 32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPGPIO_CTRL</name>
      <baseAddress>0x42007000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>LPGPIO_CTRL_[%s]</name>
          <description>LPGPIO I/O Buffer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000022</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DRIVER</name>
              <description>Driver configuration
- Bit[7] selects driver mode:
0x0: Push-pull
0x1: Open drain
- Bits[6-5] select driver strength:
0x0: 2 mA
0x1: 4 mA (default)
0x2: 8 mA
0x3: 12 mA
- Bits[4-3] select driver disabled state:
0x0: Hi-Z
0x1: Pull-up
0x2: Pull-down
0x3: Bus keeper
- Bit[2] selects slew rate: 
NOTE: Applicable only to 1.8-V I/Os (non-Flex)
0x0: Slow
0x1: Fast</description>
              <bitRange>[7:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RECEIVER</name>
              <description>Receiver configuration
- Bit[1] Schmitt trigger (hysteresis) enable:
0x0: Disabled
0x1: Enabled
- Bit[0] receiver enable:
0x0: Disabled
0x1: Enabled</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSPI</name>
      <groupName>SPI</groupName>
      <baseAddress>0x43000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>244</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SPI_CTRLR0</name>
          <description>Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80004007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_IS_MST</name>
              <description>This bit selects if the SPI is working in Master or Slave mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI is Slave</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI is Master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CFS</name>
              <description>Control Frame Size.
Selects the length of the control word for the Microwire frame format.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>01-bit Control Word</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>02-bit Control Word</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>03-bit Control Word</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit Control Word</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit Control Word</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit Control Word</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit Control Word</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit Control Word</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit Control Word</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit Control Word</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit Control Word</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit Control Word</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit Control Word</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit Control Word</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit Control Word</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit Control Word</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSTE</name>
              <description>Slave Select Toggle Enable.
While operating in SPI mode with clock phase (SCPH) set to 0x0, this bit controls the behavior of the slave select line between data frames.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The slave select line will stay low and SPI_SCLK will run continuously for the duration of the transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The slave select line will toggle between consecutive data frames, with the serial clock (SPI_SCLK) being held to its default value while the slave select line is high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRL</name>
              <description>Shift Register Loop.
Used for testing purposes only. When internally active, connects the transmit shift register output to the receive shift register input. Can be used in both serial slave and serial Master mode. When the SPI is configured as a slave in loopback mode, the slave select input and SPI_CLK signals must be provided by an external source. In this mode, the slave cannot generate these signals because there is nothing to which to loop back.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal Mode Operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Test Mode Operation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLV_OE</name>
              <description>Slave Output Enable.
Relevant only when the SPI is configured as a serial slave device. When configured as a serial master, this bit has no functionality. This bit enables or disables the setting of the output enable signal from the SPI serial slave. When the SLV_OE = 0x1, the output enable signal can never be active. When the output enable signal controls the tri-state buffer on the TXD output from the slave, a high impedance state is always present on the slave TXD output when the SLV_OE bit is set to 0x1.
This is useful when the master transmits in broadcast mode (master transmits data to all slave devices). Only one slave may respond with data on the master RXD line. This bit is enabled after reset and must be disabled by software (when broadcast mode is used), if the device has no need to respond with data.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave output is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave output is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMOD</name>
              <description>Transfer Mode.
Selects the mode of transfer for serial communication. This field does not affect the transfer duplicity. Only indicates whether the receive or transmit data are valid.
In Transmit Only mode, data received from the external device is not valid and is not stored in the receive FIFO memory; it is overwritten on the next transfer.
In Receive Only mode, transmitted data are not valid. After the first write to the transmit FIFO, the same word is retransmitted for the duration of the transfer.
In Transmit and Receive mode, both transmit and receive data are valid. The transfer continues until the transmit FIFO is empty. Data received from the external device are stored into the receive FIFO memory, where it can be accessed by the host processor.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit and Receive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Only mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Receive Only mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>EEPROM Read mode</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPOL</name>
              <description>Serial Clock Polarity.
Valid when the Frame Format (FRF) bit is set to Motorola SPI. Used to select the polarity of the inactive serial clock, which is held inactive when the SPI master is not actively transferring data on the serial bus.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive state of serial clock is low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Inactive state of serial clock is high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPH</name>
              <description>Serial Clock Phase.
Valid when the FRF bit is set to Motorola SPI. The serial clock phase selects the relationship of the serial clock with the slave select signal.
When SCPH = 0, data are captured on the first edge of the serial clock. When SCPH = 1, the serial clock starts toggling one cycle after the slave select line is activated, and data are captured on the second edge of the serial clock.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Serial clock toggles in middle of first bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Serial clock toggles at start of first bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>Frame Format.
Selects which serial protocol transfers the data.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Motorola SPI frame format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Texas Instruments SSP frame format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>National Semiconductors Microwire frame format</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFS</name>
              <description>Data Frame Size.
Selects the data frame length. When the data frame size is programmed to be less than 32 bits, the receive data is automatically right-justified by the receive logic, with the upper bits of the receive FIFO zero-padded.
User must right-justify transmit data before writing into the transmit FIFO. The transmit logic ignores the upper unused bits when transmitting the data.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit serial data transfer</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit serial data transfer</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit serial data transfer</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit serial data transfer</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit serial data transfer</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit serial data transfer</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit serial data transfer</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit serial data transfer</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit serial data transfer</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit serial data transfer</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit serial data transfer</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit serial data transfer</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit serial data transfer</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>17-bit serial data transfer</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>18-bit serial data transfer</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>19-bit serial data transfer</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>20-bit serial data transfer</description>
                  <value>0x13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>21-bit serial data transfer</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x15</name>
                  <description>22-bit serial data transfer</description>
                  <value>0x15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x16</name>
                  <description>23-bit serial data transfer</description>
                  <value>0x16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x17</name>
                  <description>24-bit serial data transfer</description>
                  <value>0x17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x18</name>
                  <description>25-bit serial data transfer</description>
                  <value>0x18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x19</name>
                  <description>26-bit serial data transfer</description>
                  <value>0x19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1A</name>
                  <description>27-bit serial data transfer</description>
                  <value>0x1A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1B</name>
                  <description>28-bit serial data transfer</description>
                  <value>0x1B</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1C</name>
                  <description>29-bit serial data transfer</description>
                  <value>0x1C</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1D</name>
                  <description>30-bit serial data transfer</description>
                  <value>0x1D</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1E</name>
                  <description>31-bit serial data transfer</description>
                  <value>0x1E</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32-bit serial data transfer</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRLR1</name>
          <description>Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NDF</name>
              <description>Number of Data Frames.
When the SPI_CTRLR0[TMOD] = 0x2 or SPI_CTRLR0[TMOD] = 0x3, this bit field sets the number of data frames to be continuously received by the SPI. The SPI continues to receive serial data until the number of data frames received is equal to this register value plus 1, which enables the user to receive up to 64KB of data in a continuous transfer. When the SPI is configured as a serial slave, the transfer continues for as long as the slave is selected. Therefore, this bit field serves no purpose and is not present when the SPI is configured as a serial slave.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ENR</name>
          <description>SPI Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_EN</name>
              <description>SPI Enable.
Enables and disables all SPI operations. When disabled, all serial transfers are halted immediately. Transmit and receive FIFO buffers are cleared when the device is disabled. It is impossible to program some of the SPI control registers when enabled. When disabled, the SPI sleep output is set (after delay) to inform the system that it is safe to remove the SPI_CLK, thus saving power consumption in the system.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables SPI</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables SPI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_MWCR</name>
          <description>Microwire Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MHS</name>
              <description>Microwire Handshaking.
Relevant only when the SPI is configured as a serial master device. When configured as a serial slave, this bit has no functionality. Used to enable and disable the busy/ready handshaking interface for the Microwire protocol. When enabled, the SPI checks for a ready status from the target slave, after the transfer of the last data/control bit, before clearing the BUSY status in the SPI_SR[BUSY] bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Handshaking interface is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Handshaking interface is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MDD</name>
              <description>Microwire Control.
Defines the direction of the data word when the Microwire serial protocol is used. When this bit is set to 0, the data word is received by the SPI module from the external serial device. When this bit is set to 1, the data word is transmitted from the SPI module to the external serial device.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI receives data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI transmits data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MWMOD</name>
              <description>Microwire Transfer Mode.
Defines whether the Microwire transfer is sequential or non-sequential. When sequential mode is used, only one control word is needed to transmit or receive a block of data words. When non-sequential mode is used, there must be a control word for each data word that is transmitted or received.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Non-Sequential Transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sequential Transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_SER</name>
          <description>Slave Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SER</name>
              <description>Slave Select Enable Flag.
Each bit in this bit field corresponds to a slave select line from the SPI master. When a bit in this bit field is set to 0x1, the corresponding slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this bit field have no effect on the corresponding slave select outputs until a transfer is started. Before beginning a transfer, user should enable the bit in this field that corresponds to the slave device with which the master wants to communicate. When not operating in broadcast mode, only one bit in this field should be set.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not Selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_BAUDR</name>
          <description>Baud Rate Select Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCKDV</name>
              <description>SPI Clock Divider.
This field contains the MSB 15 bits of the 16-bit SPI_CLK divider value. The LSB for SPI_CLK divider is always set to 0 and is unaffected by a write operation, which ensures the divider is always set to an even value. If this field is set to all 0s, the serial output clock (SPI_SCLK) is disabled. The frequency of the SPI_SCLK is derived from the following equation:
 FSPI_SCLK = FSPI_CLK/BAUDR
Where BAUDR is any even value between 2 and 65534, and BAUDR = SCKDV x 2.
 For example, for FSPI_CLK = 3.6864 MHz and SCKDV = 1b'1:
BAUDR = 2 and FSPI_SCLK= 3.6864/2 = 1.8432 MHz.
For more information, see Section SPI Clock Ratios.</description>
              <bitRange>[15:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXFTLR</name>
          <description>Transmit FIFO Threshold Level Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFTHR</name>
              <description>Transfer Start FIFO Level.
Used to control the level of entries in transmit FIFO above which transfer will start on serial line. This bit field is used to ensure that sufficient data is present in transmit FIFO before starting a write operation on serial line. These field is valid only for Master mode of operation.
Note: This field is functional only for SPI module. It is not functional for LPSPI module.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFT</name>
              <description>Transmit FIFO Threshold.
Controls the level of entries (or below) at which the transmit FIFO controller triggers an interrupt. The FIFO depth is 16. If the value in this bit field is set greater than or equal to the depth of the FIFO, this bit field is not written and retains its current value. When the number of transmit FIFO entries is less than or equal to this value, the transmit FIFO empty interrupt is triggered.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXFTLR</name>
          <description>Receive FIFO Threshold Level Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFT</name>
              <description>Receive FIFO Threshold.
Controls the level of entries (or above) at which the receive FIFO controller triggers an interrupt. The FIFO depth is 16. If the value in this bit field is set greater than the depth of the FIFO, this bit field is not written and retains its current value. When the number of receive FIFO entries is greater than or equal to this value + 1, the receive FIFO full interrupt is triggered.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXFLR</name>
          <description>Transmit FIFO Level Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTFL</name>
              <description>Transmit FIFO Level.
Contains the number of valid data entries in the transmit FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXFLR</name>
          <description>Receive FIFO Level Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXTFL</name>
              <description>Receive FIFO Level.
Contains the number of valid data entries in the receive FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_SR</name>
          <description>Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCOL</name>
              <description>Data Collision Error.
Relevant only when the SPI is configured as a master device. This bit is set if slave select input is asserted by other master, when the SPI master is in the middle of the transfer. This informs the processor that the last data transfer was halted before completion. This bit is cleared when read.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Data Collision Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXE</name>
              <description>Transmission Error.
Set if the transmit FIFO is empty when a transfer is started. This bit can be set only when the SPI is configured as a slave device.
Note: LPSPI supports Master mode only. The high-speed SPIs support Master and Slave modes. For more information, see Section SPI Overview.
Data from the previous transmission is present on the TXD line. This bit is cleared when read.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Full.
When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Receive FIFO Not Empty.
Set when the receive FIFO contains one or more entries and is cleared when the receive FIFO is empty. This bit can be polled by software to completely empty the receive FIFO.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is not empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Empty.
When the transmit FIFO is completely empty, this bit is set. When the transmit FIFO contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Transmit FIFO Not Full.
Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>SPI Busy Flag.
When set, indicates that a serial transfer is in progress; when cleared indicates that the SPI is idle or disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI is idle or disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI is actively transferring data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IMR</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIM</name>
              <description>Multi-Master Contention Interrupt Mask.
This bit is not present if the SPI is configured as a serial master device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIM</name>
              <description>Receive FIFO Full Interrupt Mask.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIM</name>
              <description>Receive FIFO Overflow Interrupt Mask.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIM</name>
              <description>Receive FIFO Underflow Interrupt Mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIM</name>
              <description>Transmit FIFO Overflow Interrupt Mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIM</name>
              <description>Transmit FIFO Empty Interrupt Mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ISR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIS</name>
              <description>Multi-Master Contention Interrupt Status.
This bit is not present if the SPI is configured as a serial slave device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIS</name>
              <description>Receive FIFO Full Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIS</name>
              <description>Receive FIFO Overflow Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIS</name>
              <description>Receive FIFO Underflow Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIS</name>
              <description>Transmit FIFO Overflow Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIS</name>
              <description>Transmit FIFO Empty Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RISR</name>
          <description>Raw Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTIR</name>
              <description>Multi-Master Contention Raw Interrupt Status.
 This bit field is not present if the SPI is configured as a serial slave device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Multi-Master Contention interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multi-Master Contention interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIR</name>
              <description>Receive FIFO Full Raw Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIR</name>
              <description>Receive FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIR</name>
              <description>Receive FIFO Underflow Raw Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIR</name>
              <description>Transmit FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIR</name>
              <description>Transmit FIFO Empty Raw Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TXOICR</name>
          <description>Transmit FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOICR</name>
              <description>Clear Transmit FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Transmit FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXOICR</name>
          <description>Receive FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOICR</name>
              <description>Clear Receive FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RXUICR</name>
          <description>Receive FIFO Underflow Interrupt Clear Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUICR</name>
              <description>Clear Receive FIFO Underflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Underflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_MSTICR</name>
          <description>Multi-Master Interrupt Clear Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSTICR</name>
              <description>Clear Multi-Master Contention Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Multi-Master Contention interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_ICR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ICR</name>
              <description>Clear Interrupts.
This bit is set if any of the interrupts below are active. A read clears the Transmit FIFO Overflow, Receive FIFO Underflow, Receive FIFO Overflow, and Multi-Master Contention interrupts. Writing to this bit has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMACR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDMAE</name>
              <description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDMAE</name>
              <description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive DMA disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive DMA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMATDLR</name>
          <description>DMA Transmit Data Level Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMATDL</name>
              <description>Transmit Data Level.
This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the transmit DMA request signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this bit field value, and the SPI_DMACR[TDMAE] = 0x1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_DMARDLR</name>
          <description>DMA Receive Data Level Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMARDL</name>
              <description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level is equal to DMARDL + 1; that is, receive DMA request is generated when the number of valid data entries in the receive FIFO is equal to or above this bit field value + 1, and SPI_DMACR[RDMAE] = 0x1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IDR</name>
          <description>Reserved</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xC7C5C3C1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDCODE</name>
              <description>Reserved.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_VERSION_ID</name>
          <description>Reserved</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3130322A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_COMP_VERSION</name>
              <description>Reserved.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>36</dim>
          <dimIncrement>4</dimIncrement>
          <name>SPI_DR[%s]</name>
          <description>SPI Data Register (n)</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DR</name>
              <description>Data Register (n).
When writing to this register, the user must right-justify the data. Read data are automatically right-justified.
Read = Receive FIFO buffer
Write = Transmit FIFO buffer</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RX_SAMPLE_DELAY</name>
          <description>RX Sample Delay Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SE</name>
              <description>Receive Data Sampling Edge.
 This bit is used to decide the sampling edge for RXD signal with SPI_CLK. Then this bit is set to 1 then negative edge of SPI_CLK will be used to sample the incoming data, otherwise positive edge will be used for sampling.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSD</name>
              <description>Receive Data Sample Delay.
 This bit field is used to delay the sample of the RXD input port. Each value represents a single SPI_CLK delay on the sample of RXD.
Note: If this bit field is programmed with a value that exceeds the depth of the internal shift registers (internal shift register depth = 4) zero delay will be applied to the RXD sample.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPI2S</name>
      <groupName>I2S</groupName>
      <baseAddress>0x43001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>516</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>I2S_IER</name>
          <description>I2S Enable Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IEN</name>
              <description>I2S Enable.
This bit enables or disables the I2S module. Disabling this bit (I2S_IER[IEN] = 0x0) overrides any other block or channel enables, and flushes all FIFOs.
 For more information about how this bit affects the other I2S blocks, refer to Section I2S Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2S disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2S enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_IRER</name>
          <description>I2S Receiver Block Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXEN</name>
              <description>Receiver Block Enable.
This bit enables or disables the Receiver block. Disabling this bit (I2S_IRER[RXEN] = 0x0) overrides the receive channel enables.
 For more information about the Receiver block, refer to Section I2S as a Receiver.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_ITER</name>
          <description>I2S Transmitter Block Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXEN</name>
              <description>Transmitter Block Enable.
This bit enables or disables the Transmitter block. A disable on this bit (I2S_ITER[TXEN] = 0x0) overrides the transmit channel enables. 
For more information about the Transmitter block, refer to Section I2S as a Transmitter.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmitter disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_CER</name>
          <description>Clock Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKEN</name>
              <description>Clock Generation Enable or Disable.
This bit enables or disables the clock generation signals when the I2S module is a master: SCLK_EN, WS_OUT, and SCLK_GATE.
For more information about clock generation, refer to Section I2S Clocks.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock generation disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock generation enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_CCR</name>
          <description>Clock Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WSS</name>
              <description>This bit field is used to program the number of SCLK cycles for which the word select line (WS_OUT) stays in the left or right sample mode. The I2S Clock Generation block must be disabled (I2S_CER[CLKEN] = 0x0) prior to any changes in this value.</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>16 SCLK cycles</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>24 SCLK cycles</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>32 SCLK cycles</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCLKG</name>
              <description>This bit field is used to program the gating of SCLK. The programmed gating value must be less than or equal to the largest configured (programmed) audio resolution to prevent the truncating of RX/TX data. The I2S Clock Generation block must be disabled (I2S_CER[CLKEN] = 0x0) before making any changes in this value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock gating is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Gating after 12 SCLK cycles</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Gating after 16 SCLK cycles</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Gating after 20 SCLK cycles</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Gating after 24 SCLK cycles</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RXFFR</name>
          <description>Receiver Block FIFO Reset Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFFR</name>
              <description>Receiver FIFO Reset.
Writing a 0x1 to this bit flushes all the RX FIFOs (this is a self clearing bit). The Receiver block must be disabled before writing to this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Does not flush the RX FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes the RX FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TXFFR</name>
          <description>Transmitter Block FIFO Reset Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFFR</name>
              <description>Transmitter FIFO Reset.
Writing a 0x1 to this bit flushes all the TX FIFOs (this is a self clearing bit). The Transmitter block must be disabled prior to writing this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Does not flush the TX FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes the TX FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_LRBR0</name>
          <description>Left Receive Buffer Register 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LRBRX</name>
              <description>The left stereo data received serially from the receive channel input (SDI). 
If the RX FIFO is full and the two-stage read operation (for instance, a read from the I2S_LRBR0[LRBRX] bit field followed by a read from the I2S_RRBR0[RRBRX] bit field) is not performed before the start of the next stereo pair, then the new data is lost and an overrun interrupt occurs (data already in the RX FIFO is preserved).
Note: Before reading this register again, the right stereo data must be read from the I2S_RRBR0[RRBRX] bit field or the status (interrupts) will not be valid.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_LTHR0</name>
          <description>Left Transmit Holding Register 0</description>
          <alternateRegister>I2S_LRBR0</alternateRegister>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LTHRX</name>
              <description>The left stereo data to be transmitted serially through the transmit channel output (SDO) is written through this bit field.
Writing is a two-stage process:
1. A write to this bit field passes the left stereo sample to the transmitter.
2. This must be followed by writing the right stereo sample to the I2S_RTHR0[RTHRX] bit field.
Note: Data must only be written to the FIFO when it is not full. Any attempt to write to a full FIFO results in that data being lost and an overrun interrupt being generated.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RRBR0</name>
          <description>Right Transmit Holding Register 0</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RRBRX</name>
              <description>The right stereo data received serially from the receive channel input (SDI) is read through this bit field. If the RX FIFO is full and the two-stage read operation (for instance, read from the I2S_LRBR0[LRBRX] bit field followed by a read from the I2S_RRBR0[RRBRX] bit field) is not performed before the start of the next stereo pair, then the new data is lost and an overrun interrupt occurs (data already in the RX FIFO is preserved).
Note: Prior to reading this bit field, the left stereo data must be read from the I2S_LRBR0[LRBRX] bit field, or the status (interrupts) will not be valid.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RTHR0</name>
          <description>Specifies the Right Transmit Holding Register</description>
          <alternateRegister>I2S_RRBR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTHRX</name>
              <description>The right stereo data to be transmitted serially through the transmit channel output (SDO) is written through this bit field.
Writing is a two-stage process:
1. A left stereo sample must be written to the I2S_LTHR0[LTHRX] bit field.
2. A write to this bit field passes the right stereo sample to the transmitter.
Note: Data should only be written to the FIFO when it is not full. Any attempt to write to a full FIFO results in that data being lost and an overrun interrupt being generated.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RER0</name>
          <description>Receive Enable Register 0</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCHENX</name>
              <description>Receive Channel Enable.
This bit enables or disables the receive channel. On enable, the channel begins receiving on the next left stereo cycle.
A global disable of the I2S module (I2S_IER[IEN] = 0x0) or the Receiver block (I2S_IRER[RXEN] = 0x0) overrides this value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive channel disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive channel enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TER0</name>
          <description>Transmit Enable Register 0</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCHENX</name>
              <description>Transmit Channel Enable.
This bit enables or disables the transmit channel. On enable, the channel begins transmitting on the next left stereo cycle.
A global disable of the I2S module (I2S_IER[IEN] = 0x0) or Transmitter block (I2S_ITER[TXEN] = 0x0) overrides this value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit channel disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit channel enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RCR0</name>
          <description>Receive Configuration Register 0</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLEN</name>
              <description>This bit field is used to program the desired data resolution of the receiver and enables the LSB of the incoming left (or right) word to be placed in the LSB of the I2S_LRBR0[LRBRX] (or I2S_RRBR0[RRBRX]) bit field.
Programmed data resolution must be less than or equal to the I2S_COMP_PARAM_2[I2S_RX_WORDSIZE_x] bit field value, where x = 0 to 3. If the selected resolution is greater than the I2S_COMP_PARAM_2[I2S_RX_WORDSIZE_x] bit field value, the receive channel defaults back to the to the maximum audio data resolution supported.
The channel must be disabled prior to any changes in this value (I2S_RER0[RXCHENX] = 0x0).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore the word length</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>12-bit data resolution of the receiver</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>16-bit data resolution of the receiver</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>20-bit data resolution of the receiver</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24-bit data resolution of the receiver</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>32-bit data resolution of the receiver</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TCR0</name>
          <description>Transmit Configuration Register 0</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLEN</name>
              <description>This bit field is used to program the desired data resolution of the transmitter and ensures the MSB of the data is transmitted first.
Programmed resolution must be less than or equal to the I2S_COMP_PARAM_1[I2S_TX_WORDSIZE_x] bit field value, where x = 0 to 3. If the selected resolution is greater than the I2S_COMP_PARAM_1[I2S_TX_WORDSIZE_x] bit field value, the transmit channel defaults back to the to the maximum audio data resolution supported.
The channel must be disabled prior to any changes in this value (I2S_TER0[TXCHENX] = 0x0).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore the word length</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>12-bit data resolution of the transmitter</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>16-bit data resolution of the transmitter</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>20-bit data resolution of the transmitter</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>24-bit data resolution of the transmitter</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>32-bit data resolution of the transmitter</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_ISR0</name>
          <description>Interrupt Status Register 0</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFO</name>
              <description>Status of Data Overrun Interrupt for the TX Channel.
This bit specifies whether the TX FIFO write is valid or an overrun (attempt to write to full TX FIFO).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX FIFO write valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX FIFO write overrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFE</name>
              <description>Status of Transmit Empty Trigger Interrupt.
This bit specifies whether the TX FIFO trigger level has reached or not (TX FIFO is empty).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX FIFO trigger level is reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX FIFO trigger level is not reached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFO</name>
              <description>Status of Data Overrun Interrupt for the RX Channel.
Incoming data lost due to a full RX FIFO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX FIFO write valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX FIFO write overrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDA</name>
              <description>Status of Receive Data Available Interrupt.
This bit denotes the status of the RX FIFO trigger level.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX FIFO trigger level is not reached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX FIFO trigger level is reached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_IMR0</name>
          <description>Interrupt Mask Register 0</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFOM</name>
              <description>Mask TX FIFO Overrun Interrupt.
This bit masks or unmasks a TX FIFO overrun interrupt.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks TX FIFO Overrun interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks TX FIFO Overrun interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFEM</name>
              <description>Mask TX FIFO Empty Interrupt.
This bit masks or unmasks a TX FIFO Empty interrupt.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks TX FIFO Empty interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks TX FIFO Empty Interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFOM</name>
              <description>Mask RX FIFO Overrun Interrupt.
This bit masks or unmasks an RX FIFO Overrun interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks RX FIFO Overrun interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks RX FIFO Overrun interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDAM</name>
              <description>Mask RX FIFO Data Available Interrupt.
This bit masks or unmasks an RX FIFO Data Available interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Masks RX FIFO data available interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unmasks RX FIFO data available interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_ROR0</name>
          <description>Receive Overrun Register 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCHO</name>
              <description>Read this bit to clear the RX FIFO Data Overrun interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX FIFO write valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX FIFO write overrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TOR0</name>
          <description>Transmit Overrun Register 0</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCHO</name>
              <description>Read this bit to clear the TX FIFO Data Overrun interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX FIFO write valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX FIFO write overrun</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RFCR0</name>
          <description>Receive FIFO Configuration Register 0</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCHDT</name>
              <description>This bit field programs the trigger level in the RX FIFO at which the Received Data Available interrupt and DMA request is generated (Trigger Level = Programmed Value + 1).
Valid values of the I2S_RFCR0[RXCHDT] bit field: 0 to RX FIFO depth - 1.
If an illegal value is programmed, this bit field saturates to RX FIFO depth - 1.
For more information about FIFO depth, refer to Section I2S Overview.
The channel must be disabled prior to any changes in this value (that is, I2S_RER0[RXCHENX] = 0x0).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 6</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 7</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 9</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 10</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 11</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 12</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 13</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 14</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 15</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 16</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TFCR0</name>
          <description>Transmit FIFO Configuration Register 0</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCHET</name>
              <description>This bit field programs the trigger level in the TX FIFO at which the Empty Threshold Reached interrupt and DMA request is generated (Trigger Level = TXCHET).
Valid values of the I2S_TFCR0[TXCHET] bit field: 0 to TX FIFO depth - 1.
If an illegal value is programmed, this bit field saturates to TX FIFO depth - 1. The channel must be disabled prior to any changes in this value (that is, I2S_TER0[TXCHENX] = 0x0).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 4</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 5</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 6</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 7</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 8</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 9</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 10</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 11</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 12</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 13</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 14</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 15</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Interrupt trigger and DMA request asserted when FIFO level is 16</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RFF0</name>
          <description>Receive FIFO Flush Register 0</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCHFR</name>
              <description>Receive Channel FIFO Reset.
Writing a 0x1 to this bit flushes the channel RX FIFO (this is a self clearing bit). The RX channel or block must be disabled prior to writing to this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Does not flush the channel RX FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes the channel RX FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TFF0</name>
          <description>Transmit FIFO Flush Register 0</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXCHFR</name>
              <description>Transmit Channel FIFO Reset.
Writing a 0x1 to this bit flushes the channel TX FIFO (this is a self clearing bit). The TX channel or block must be disabled prior to writing to this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not flushes the channel TX FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flushes the channel TX FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_RXDMA</name>
          <description>Receiver Block DMA Register</description>
          <addressOffset>0x1C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDMA</name>
              <description>Receiver Block DMA.
These bits are used to cycle repeatedly through the enabled receive channels (from lowest numbered to highest), reading stereo data pairs.
For more information about the supported receive channels, refer to Section I2S Overview.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_TXDMA</name>
          <description>Transmitter Block DMA Register</description>
          <addressOffset>0x1C8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXDMA</name>
              <description>Transmitter Block DMA.
These bits can be used to cycle repeatedly through the enabled transmit channels (from lowest numbered to highest) to allow writing of stereo data pairs.
For more information about the supported transmit channels, refer to Section I2S Overview.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_PARAM_2</name>
          <description>Module Configuration Register 2</description>
          <addressOffset>0x1F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000048C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_RX_WORDSIZE_3</name>
              <description>These bits specify the RX resolution for WORDSIZE_3.</description>
              <bitRange>[12:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_WORDSIZE_2</name>
              <description>These bits specify the RX resolution for WORDSIZE_2.</description>
              <bitRange>[9:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_WORDSIZE_1</name>
              <description>These bits specify the RX resolution for WORDSIZE_1.</description>
              <bitRange>[5:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_WORDSIZE_0</name>
              <description>These bits specify the RX resolution for WORDSIZE_0.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32-bit Resolution</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_PARAM_1</name>
          <description>Module Configuration Register 1</description>
          <addressOffset>0x1F4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x024C007E</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_TX_WORDSIZE_3</name>
              <description>These bits specify the TX resolution for WORDSIZE_3.</description>
              <bitRange>[27:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_WORDSIZE_2</name>
              <description>These bits specify the TX resolution for WORDSIZE_2.</description>
              <bitRange>[24:22]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_WORDSIZE_1</name>
              <description>These bits specify the TX resolution for WORDSIZE_1.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit Resolution</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_WORDSIZE_0</name>
              <description>These bits specify the TX resolution for WORDSIZE_0.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32-bit Resolution</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TX_CHANNELS</name>
              <description>These bits specify the number of TX channels.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 x Transmit channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RX_CHANNELS</name>
              <description>These bits specify the number of RX channels.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 x Receive channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_RECEIVER_BLOCK</name>
              <description>This bit specifies whether the receiver block is enabled or not.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver block is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_TRANSMITTER_BLOCK</name>
              <description>This bit specifies whether the transmitter block is enabled or not.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter block is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE_EN</name>
              <description>This bit specifies whether the Master mode is enabled or not.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_FIFO_DEPTH_GLOBAL</name>
              <description>These bits specify the FIFO depth for TX and RX channels.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO depth is equals to 16 for TX and RX channels</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>These bits specify the APB data width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>APB data width of 32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_VERSION</name>
          <description>Component Parameter Register</description>
          <addressOffset>0x1F8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3131312A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_COMP_VERSION</name>
              <description>Module component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_COMP_TYPE</name>
          <description>Component Type Register</description>
          <addressOffset>0x1FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x445701A0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_COMP_TYPE</name>
              <description>Component type</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2S_DMACR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAEN_TXBLOCK</name>
              <description>DMA Enable for the Transmit Block.
This bit enables or disables the DMA handshake logic for the transmitter block.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA disabled for the transmit block</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA enabled for the transmit block</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMAEN_RXBLOCK</name>
              <description>DMA Enable for the Receive Block.
 This bit enables or disables the DMA handshake logic for the receiver block.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA disabled for the receiver block</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA enabled for the receiver block</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPPDM</name>
      <groupName>PDM</groupName>
      <baseAddress>0x43002000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>2008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PDM_CTL0</name>
          <description>PDM Audio Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_CLR</name>
              <description>FIFO clear</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_MODE</name>
              <description>PDM clock frequency selection for all channels.
For more details about these modes,PDM Modes.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PDM mode 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PDM mode 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>PDM mode 9</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH7_EN</name>
              <description>Channel 7 enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH6_EN</name>
              <description>Channel 6 enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH5_EN</name>
              <description>Channel 5 enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH4_EN</name>
              <description>Channel 4 enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH3_EN</name>
              <description>Channel 3 enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH2_EN</name>
              <description>Channel 2 enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH1_EN</name>
              <description>Channel 1 enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH0_EN</name>
              <description>Channel 0 enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable and soft-clear</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CTL1</name>
          <description>PDM Audio Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USE_DMA_HANDSHAKE</name>
              <description>Use DMA handshaking signals for flow control.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_ADVANCE</name>
              <description>Sampling of PDM data by SAMPLE_PHASE number of PDM_CLK periods around PDM_Ci edges.
Adjust to compensate for routing delay skew between PDM_Ci and PDM_Di and to meet sampling time requirement of the microphone.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Retard sampling</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Advance sampling</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAMPLE_PHASE</name>
              <description>Sampling phase of PDM data in units of PDM_CLK period.
Adjust to compensate for routing delay skew between PDM_Ci and PDM_Di and to meet sampling time requirement of the microphone.</description>
              <bitRange>[16:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PKDET_NODE</name>
              <description>Peak detection node.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Before gain stage</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>After gain stage</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYP_FIR</name>
              <description>Bypass FIR filter.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYP_IIR</name>
              <description>Bypass DC blocking IIR filter.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_FIFO_WATERMARK_H</name>
          <description>FIFO Watermark Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WATERMARK_H</name>
              <description>Threshold to trigger FIFO almost full warning interrupt</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_FIFO_STAT</name>
          <description>FIFO Status Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Count of sets of audio data entry in FIFO for each channel available to be read. A set consists of one PDM sample per channel.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_ERROR_IRQ</name>
          <description>FIFO Error Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_OVERFLOW_IRQ</name>
              <description>Asserts if audio stream causes FIFO overflow</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_WARN_IRQ</name>
          <description>FIFO Warning Interrupt Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_ALMOST_FULL_IRQ</name>
              <description>Alerts the Host that FIFO fill level has reached or exceeded the PDM_FIFO_WATERMARK_H threshold and audio data should be read to avoid FIFO overflow error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_AUDIO_DETECT_IRQ</name>
          <description>Audio Detection Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH7_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 7 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH6_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 6 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH5_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 5 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH4_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 5 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH3_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 3 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH2_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 2 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH1_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 1 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>CH0_AUDIO_DETECT_IRQ</name>
              <description>Asserts if the peak absolute value of audio signal in channel 0 exceeds the peak detector high threshold for the channel</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_IRQ_ENABLE</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH7_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 7 audio peak detection interrupt enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 6 audio peak detection interrupt enable</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH5_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 5 audio peak detection interrupt enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 4 audio peak detection interrupt enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 3 audio peak detection interrupt enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 2 audio peak detection interrupt enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 1 audio peak detection interrupt enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_AUDIO_DETECT_IRQ_EN</name>
              <description>Channel 0 audio peak detection interrupt enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW_IRQ_EN</name>
              <description>FIFO overflow error interrupt enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_ALMOST_FULL_IRQ_EN</name>
              <description>FIFO almost full warning interrupt enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH0_CH1_AUDIO_OUT</name>
          <description>Channels 0 and 1 Audio Output Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_AUDIO</name>
              <description>Channel 1 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_AUDIO</name>
              <description>Channel 0 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH2_CH3_AUDIO_OUT</name>
          <description>Channels 2 and 3 Audio Output Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3_AUDIO</name>
              <description>Channel 3 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_AUDIO</name>
              <description>Channel 2 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH4_CH5_AUDIO_OUT</name>
          <description>Channels 4 and 5 Audio Output Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH5_AUDIO</name>
              <description>Channel 5 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_AUDIO</name>
              <description>Channel 4 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDM_CH6_CH7_AUDIO_OUT</name>
          <description>Channels 6 and 7 Audio Output Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH7_AUDIO</name>
              <description>Channel 7 audio output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_AUDIO</name>
              <description>Channel 6 audio output</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>256</dimIncrement>
          <name>PDM_CHANNEL_CFG[%s]</name>
          <addressOffset>0x40</addressOffset>
          <register>
            <name>PDM_CH_FIR_COEF_0</name>
            <description>Channel (n) FIR Filter Coefficient 0 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_0</name>
                <description>FIR coefficient 0.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_1</name>
            <description>Channel (n) FIR Filter Coefficient 1 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_1</name>
                <description>FIR coefficient 1.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_2</name>
            <description>Channel (n) FIR Filter Coefficient 2 Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_2</name>
                <description>FIR coefficient 2.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_3</name>
            <description>Channel (n) FIR Filter Coefficient 3 Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_3</name>
                <description>FIR coefficient 3.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_4</name>
            <description>Channel (n) FIR Filter Coefficient 4 Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_4</name>
                <description>FIR coefficient 4.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_5</name>
            <description>Channel (n) FIR Filter Coefficient 5 Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_5</name>
                <description>FIR coefficient 5.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_6</name>
            <description>Channel (n) FIR Filter Coefficient 6 Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_6</name>
                <description>FIR coefficient 6.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_7</name>
            <description>Channel (n) FIR Filter Coefficient 7 Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_7</name>
                <description>FIR coefficient 7.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_8</name>
            <description>Channel (n) FIR Filter Coefficient 8 Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_8</name>
                <description>FIR coefficient 8.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_9</name>
            <description>Channel (n) FIR Filter Coefficient 9 Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_9</name>
                <description>FIR coefficient 9.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_10</name>
            <description>Channel (n) FIR Filter Coefficient 10 Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_10</name>
                <description>FIR coefficient 10.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_11</name>
            <description>Channel (n) FIR Filter Coefficient 11 Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_11</name>
                <description>FIR coefficient 11.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_12</name>
            <description>Channel (n) FIR Filter Coefficient 12 Register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_12</name>
                <description>FIR coefficient 12.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_13</name>
            <description>Channel (n) FIR Filter Coefficient 13 Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_13</name>
                <description>FIR coefficient 13.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_14</name>
            <description>Channel (n) FIR Filter Coefficient 14 Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_14</name>
                <description>FIR coefficient 14.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_15</name>
            <description>Channel (n) FIR Filter Coefficient 15 Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_15</name>
                <description>FIR coefficient 15.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_16</name>
            <description>Channel (n) FIR Filter Coefficient 16 Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_16</name>
                <description>FIR coefficient 16.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_FIR_COEF_17</name>
            <description>Channel (n) FIR Filter Coefficient 17 Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIR_COEF_17</name>
                <description>FIR coefficient 17.
11 bits signed 2's complement with 10 bits of fraction. Quantize to Matlab 11.10 format. Decimal range is (-1, 1-2^-10).</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_IIR_COEF_SEL</name>
            <description>Channel (n) IIR Filter Coefficient Selection Register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000009</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COEFSEL</name>
                <description>IIR filter coefficient selector for DC blocker filter characterized with the following transfer function: H(z) = (1 - z^-1) / (1 - a x z^-1), where a = 1 - (2^-COEFSEL).</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PHASE</name>
            <description>Channel (n) Phase Control Register</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PHASE</name>
                <description>Channel phase delay in units of PDM_Ci cycle counts</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_GAIN</name>
            <description>Channel (n) Gain Control Register</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000010</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GAIN</name>
                <description>Gain in unsigned 8.4 format (Matlab 12.4 format)</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PKDET_TH</name>
            <description>Channel (n) Peak Detector Threshold Register</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TH_HI</name>
                <description>High threshold for peak detection</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TH_LO</name>
                <description>Low threshold for peak detection</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PKDET_ITV</name>
            <description>Channel (n) Peak Detector Interval Register</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000780</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DLY_SP</name>
                <description>Number of samples to skip before peak detection starts</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_SP</name>
                <description>Number of samples to use for peak detection</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDM_CH_PKDET_STAT</name>
            <description>Channel (n) Peak Detector Status Register</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT_HI</name>
                <description>High peak count. Number of occurrences of the absolute value of audio signal exceeding PDM_CHn_PKDET_TH[TH_HI] threshold in the most recent peak detection interval specified by PDM_CHn_PKDET_ITV register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNT_LO</name>
                <description>Low peak count. Number of occurrences of the absolute value of audio signal going below PDM_CHn_PKDET_TH[TH_LO] threshold in the most recent peak detection interval specified by PDM_CHn_PKDET_ITV register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCPI</name>
      <groupName>CPI</groupName>
      <baseAddress>0x43003000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>52</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CAM_CTRL</name>
          <description>Camera Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001115</resetMask>
          <fields>
            <field>
              <name>FIFO_CLK_SEL</name>
              <description>Select clock source for the camera data input FIFO.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Select internal clock for soft reset</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Select external camera clock for normal function mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RESET</name>
              <description>Software reset.
Software shall set then clear this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not reset</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Reset</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SNAPSHOT</name>
              <description>Snapshot mode selection.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Capture one frame then stop (snapshot mode)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>Status of video capture.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not capturing video</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Capturing video</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START</name>
              <description>Start video capture.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Start video capture</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_INTR</name>
          <description>Camera Interrupt Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110071</resetMask>
          <fields>
            <field>
              <name>HSYNC</name>
              <description>Rising edge of HSYNC signal.</description>
              <bitRange>[20:20]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>VSYNC</name>
              <description>Rising edge of VSYNC signal.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BRESP_ERR</name>
              <description>AXI bus BRESP error.</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>OUTFIFO_OVERRUN</name>
              <description>Output FIFO overrun.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>INFIFO_OVERRUN</name>
              <description>Input FIFO overrun.</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>STOP</name>
              <description>Video capture stopped.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_INTR_ENA</name>
          <description>Camera Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00110071</resetMask>
          <fields>
            <field>
              <name>HSYNC</name>
              <description>Rising edge of HSYNC signal.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VSYNC</name>
              <description>Rising edge of VSYNC signal.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BRESP_ERR</name>
              <description>AXI bus BRESP error.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTFIFO_OVERRUN</name>
              <description>Output FIFO overrun.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INFIFO_OVERRUN</name>
              <description>Input FIFO overrun.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Video capture stopped.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_CFG</name>
          <description>Camera Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x31177133</resetMask>
          <fields>
            <field>
              <name>DATA_MASK</name>
              <description>Select camera data mask.
Valid only when [DATA_MODE] field is set to 16-bit.
NOTE: This register field is not functional for LPCPI.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>16-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>10-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_2</name>
                  <description>12-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_3</name>
                  <description>14-bit</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CODE10ON8</name>
              <description>Special coding: transfer 10-bit coding over 8-bit data bus.
Valid only when [DATA_MODE] field is set to 8-bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable special 10-bit coding</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable special 10-bit coding</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSB</name>
              <description>Select MSB/LSB
Valid only when [DATA_MODE] field is set to 1-/2-/4-/8-bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>LSB</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>MSB</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_MODE</name>
              <description>Select video data mode.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>1-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>2-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_2</name>
                  <description>4-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_3</name>
                  <description>8-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_4</name>
                  <description>16-bit (NOTE: This value is not valid for LPCPI)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSYNC_POL</name>
              <description>Set camera VSYNC polarity.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not invert VSYNC input</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Invert VSYNC input</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSYNC_POL</name>
              <description>Set camera HSYNC polarity.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not invert HSYNC input</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Invert HSYNC input</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLK_POL</name>
              <description>Set camera PIXEL_CLK polarity.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not invert external camera PIXEL_CLK</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Invert external camera PIXEL_CLK</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROW_ROUNDUP</name>
              <description>Round up pixel data to 64-bit at the end of each row.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Not round up</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Round up pixel data to 64-bit at the end of each row</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSYNC_EN</name>
              <description>Capture data when VSYNC is high.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Capture data regardless of VSYNC status</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Capture data when VSYNC is high</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_VSYNC</name>
              <description>Capture video frame on the rising edge of VSYNC.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Start video capture without waiting for VSYNC</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Start video capture on rising edge of VSYNC</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSI_HALT_EN</name>
              <description>Enable MIPI CSI controller halt function when FIFO is almost full.
NOTE: This register field is not functional for LPCPI.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Disable CSI IPI halt function</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Enable CSI IPI halt function </description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIPI_CSI</name>
              <description>Select video data source.
NOTE: This register field is not functional for LPCPI.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Select video data from parallel camera interface</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>Select video data from MIPI CSI interface</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_FIFO_CTRL</name>
          <description>Camera FIFO Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001808</resetValue>
          <resetMask>0x00001F1F</resetMask>
          <fields>
            <field>
              <name>WR_WMARK</name>
              <description>FIFO write watermark.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_WMARK</name>
              <description>FIFO read watermark.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_AXI_ERR_STAT</name>
          <description>Camera AXI Error Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF03</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>AXI bus BRESP error counter.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BRESP</name>
              <description>AXI bus BRESP error code.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_VIDEO_FCFG</name>
          <description>Camera Video Frame Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF3FFF</resetMask>
          <fields>
            <field>
              <name>ROW</name>
              <description>Valid data rows in a frame.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA</name>
              <description>Valid data in a row.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_CSI_CMCFG</name>
          <description>Camera MIPI CSI Color Mode Configuration Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>Color encoding for MIPI CSI IPI interface.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IPI-16 RAW 6</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IPI-16 RAW 7</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>IPI-16 RAW 8</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>IPI-16 RAW 10</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>IPI-16 RAW 12</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>IPI-16 RAW 14</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>IPI-16 RAW 16</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>IPI-48 RGB444</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>IPI-48 RGB555</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>IPI-48 RGB565</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>IPI-48 RGB666</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>IPI-48 XRGB888</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>IPI-48 RGBX888</description>
                  <value>0xC</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_FRAME_ADDR</name>
          <description>Camera Video Frame Start Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF8</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Video frame start address.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>M55HE_CFG</name>
      <baseAddress>0x43007000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>36</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>HE_DMA_CTRL</name>
          <description>DMA2 Boot Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>SW_RST</name>
              <description>Software reset for DMA2</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset DMA2. This bit is self-cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_MANAGER</name>
              <description>When DMA2 exits from reset, this bit controls the security state of the DMA manager thread</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Assigns DMA manager to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assigns DMA manager to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_DMA_IRQ</name>
          <description>DMA2 Boot IRQ Non-Secure Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_IRQ</name>
              <description>Controls the security state of an event-interrupt resource, when DMA2 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA2 assigns event x or IRQ[x] to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA2 assigns event x or IRQ[x] to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_DMA_PERIPH</name>
          <description>DMA2 Boot Peripheral Non-Secure Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_PERIPH</name>
              <description>Controls the security state of a peripheral request interface, when DMA2 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA2 assigns peripheral request interface x to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA2 assigns peripheral request interface x to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_DMA_SEL</name>
          <description>DMA2 Select Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF011131</resetMask>
          <fields>
            <field>
              <name>FLT_ENA</name>
              <description>For each bit:</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable glitch-filter for LPGPIO input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable glitch-filter for LPGPIO input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM</name>
              <description>Select DMA for LPPDM</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S</name>
              <description>Select DMA for LPI2S</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI</name>
              <description>Select DMA for LPSPI</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0 group 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Select DMA0 group 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Select DMA0 group 2</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UART</name>
              <description>Select DMA for LPUART</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA2</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_CLK_ENA</name>
          <description>Peripheral Clock Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00011311</resetMask>
          <fields>
            <field>
              <name>SPI_CKEN</name>
              <description>Enable clock for LPSPI</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPI_CKEN</name>
              <description>Enable clock for LPCPI</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_CKSEL</name>
              <description>Select clock source for LPPDM</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_CKEN</name>
              <description>Enable clock for LPPDM</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_CKEN</name>
              <description>Enable clock for DMA2 and EVTRTR2</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NPU_CKEN</name>
              <description>Enable clock for NPU-HE</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_I2S_CTRL</name>
          <description>LPI2S Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x001313FF</resetMask>
          <fields>
            <field>
              <name>SCLK_AON</name>
              <description>LPI2S clock output to external device always on</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPI2S clock output (LPI2S_SCLK) in gated mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPI2S clock output (LPI2S_SCLK) in always on mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIV_BYPASS</name>
              <description>LPI2S clock divider bypass</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not bypass clock divider</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bypass clock divider</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>LPI2S functional clock source select</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>LPI2S clock enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock for LPI2S module</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock for LPI2S module</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_DIVISOR</name>
              <description>LPI2S functional clock divisor
n: Clock divided by n</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HE_CAMERA_PIXCLK</name>
          <description>LPCPI Pixel Clock Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0001</resetMask>
          <fields>
            <field>
              <name>DIVISOR</name>
              <description>LPCPI pixel clock integer divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENA</name>
              <description>LPCPI pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPUART</name>
      <groupName>UART</groupName>
      <baseAddress>0x43008000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>UART_RBR</name>
          <description>Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register Field
This field contains the data byte received on the serial input port in UART mode. The data is valid only if the UART_LCR[DR] is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0), the data in the UART_RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an over-run error.
If FIFOs are enabled (UART_FCR[FIFOE] set to 1), this register accesses the head of the Rx FIFO. If the Rx FIFO is full and this field is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost and an over-run error occurs.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLL</name>
          <description>Divisor Latch Low Register</description>
          <alternateRegister>UART_RBR</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLL</name>
              <description>Divisor Latch Low Field
 The output baud rate is equal to the serial clock (SCLK) frequency divided by 16 times the value of the baud rate divisor, as follows:
 baud rate = (SCLK) / (16 x divisor).
Note: With the Divisor Latch registers (UART_DLL and UART_DLH) set to 0, the baud clock is disabled and no serial communication will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_THR</name>
          <description>Transmit Holding Register</description>
          <alternateRegister>UART_RBR</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>This field contains data to be transmitted on the serial output port in UART mode. Data should only be written to the THR when the UART_LSR[THRE] is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0) and UART_LSR[THRE] is set, writing a single character to the THR field clears the UART_LSR[THRE]. Any additional writes to the THR before the UART_LSR[THRE] is set again causes the THR data to be overwritten. 
If FIFOs are enabled (UART_FCR[FIFOE] set to 1) and UART_LSR[THRE] is set, 32 number of characters of data may be written to the THR before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost.</description>
              <bitRange>[8:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLH</name>
          <description>Divisor Latch High Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLH</name>
              <description>Divisor Latch High
 The output baud rate is equal to the SCLK frequency divided by 16 times the value of the baud rate divisor, as follows: 
baud rate = (SCLK) / (16 x divisor).
Note that with the Divisor Latch registers (UART_DLL and UART_DLH) set to 0, the baud clock is disabled and no serial communication will occur. Also, once the DLH is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_IER</name>
          <description>Interrupt Enable Register</description>
          <alternateRegister>UART_DLH</alternateRegister>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PTIME</name>
              <description>Programmable THRE Interrupt Mode Enable
 This bit is used to enable/disable the generation of THRE interrupt.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable programmable THRE interrupt mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable programmable THRE interrupt mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ELCOLR</name>
              <description>This bit controls the method for clearing the status in the UART_LSR register. This is applicable only for overrun error, parity error, framing error, and break interrupt status bits of UART_LSR register. </description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART_LSR status bits are cleared either on reading Rx FIFO (UART_RBR) or on reading UART_LSR register.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_LSR status bits are cleared only on reading UART_LSR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EDSSI</name>
              <description>Enable Modem Status Interrupt
This bit is used to enable/disable the generation of Modem Status interrupt. This is the fourth highest priority interrupt.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable Modem Status interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable Modem Status interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ELSI</name>
              <description>Enable Receiver Line Status Interrupt
This bit is used to enable/disable the generation of Receiver Line Status interrupt. This is the highest priority interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable Receiver Line Status interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable Receiver Line Status interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETBEI</name>
              <description>Enable Transmit Holding Register Empty Interrupt
This bit is used to enable/disable the generation of THRE Interrupt. This is the third highest priority interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable THRE interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable THRE interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERBFI</name>
              <description>Enable Received Data Available Interrupt
 This bit is used to enable/disable the generation of Received Data Available interrupt and the Character Timeout interrupt (if FIFOs are enabled). These are the second highest priority interrupts.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable Received Data Available interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable Received Data Available interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FCR</name>
          <description>FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RT</name>
              <description>Rx Trigger
 This field is used to select the trigger level in the Rx FIFO at which the Received Data Available interrupt will be generated. In Auto Flow Control mode, it is used to determine when the RTS signal will be deasserted only when RTC flow-control trigger is disabled. It also determines when the DMA_RX_REQ signal will be asserted when in certain modes of operation. 
For details on DMA support, refer to Section UART Functional Description.</description>
              <bitRange>[7:6]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 character in FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 2 characters till full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TET</name>
              <description>Tx Empty Trigger
 This field is used to select the empty threshold level at which the THRE interrupts will be generated when the mode is active. It also determines when the DMA_TX_REQ signal will be asserted when in certain modes of operation. 
For details on DMA support, refer to Section UART Functional Description.</description>
              <bitRange>[5:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO Empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 characters in FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFIFOR</name>
              <description>Tx FIFO Reset
 This bit resets the control portion of the Tx FIFO and treats the FIFO as empty. This will also deassert the DMA Tx request and single signals. Note that this bit is self-clearing.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFIFOR</name>
              <description>Rx FIFO Reset
This bit resets the control portion of the Rx FIFO and treats the FIFO as empty. This will also deassert the DMA Rx request and single signals. Note that this bit is self-clearing.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOE</name>
              <description>FIFO Enable
This bit enables/disables the Tx FIFOs and Rx FIFOs. Whenever the value of this bit is changed both the Tx FIFO and Rx FIFO controller portion of FIFOs is reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_IIR</name>
          <description>Interrupt Identification Register</description>
          <alternateRegister>UART_FCR</alternateRegister>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSE</name>
              <description>FIFOs Enabled
This field is used to indicate whether the FIFOs are enabled or disabled.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFOs are disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFOs are enabled</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IID</name>
              <description>Interrupt ID
This field indicates the highest priority pending interrupt which can be one of the following types.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Modem Status interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No interrupt pending</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>THRE interrupt</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Received Data Available interrupt</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Receiver Line Status interrupt</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Character Timeout interrupt</description>
                  <value>0xC</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LCR</name>
          <description>Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLAB</name>
              <description>Divisor Latch Access Bit
This bit is used to enable reading and writing of the Divisor Latch registers (UART_DLL and UART_DLH). This bit must be cleared after initial baud rate setup in order to access other registers.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divisor Latch register is writable only when UART is not busy</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Divisor Latch register is always readable and writable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BC</name>
              <description>Break Control Bit
 This bit is used to cause a break condition to be transmitted to the receiving device. If set to 1 the UART_TX is forced to the spacing (logic 0) state. 
When not in Loopback mode, as determined by UART_MCR[LOOPBACK], the UART_TX is forced low until the bit is cleared. 
When in Loopback mode, the break condition is internally looped back to the receiver.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART_TX is released for data transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_TX is forced to spacing state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SP</name>
              <description>Stick Parity
 This bit is used to force parity value. When PEN, EPS and SP bits are set to 1, the parity bit is transmitted and checked as logic 0. 
If PEN and SP are set to 1 and EPS is a logic 0, then parity bit is transmitted and checked as a logic 1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stick parity disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Stick parity enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EPS</name>
              <description>Even Parity Select
 This bit is used to select between even and odd parity, when PEN set to 1. </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>An odd parity is transmitted or checked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>An even parity is transmitted or checked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEN</name>
              <description>Parity Enable
 This bit is used to enable/disable parity generation and detection in transmitted and received serial character respectively.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable parity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable parity</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP</name>
              <description>This bit is used to select the number of stop bits per character that the peripheral will transmit and receive.
 If set to 0, one stop bit is transmitted in the serial data.
 If set to 1 and the data bits are set to 5 (UART_LCR[DLS] set to 0) one and a half stop bits are transmitted. Otherwise, 2 stop bits are transmitted. 
Note that regardless of the number of stop bits selected the receiver will only check the first stop bit.
 The STOP bit duration implemented by UART may appear longer due to IDLE time inserted between characters for some configurations and baud clock divisor values in the transmit direction; for details on IDLE time between transmitted transfers, refer to Section UART Back-to-Back Character Stream Transmission</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 stop bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.5 stop bits when UART_LCR[DLS] is 0, 2 stop bits otherwise</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DLS</name>
              <description>Data Length Select
 When UART_LCR_EXT[DLS_E] set to 0, this field is used to select the number of data bits per character that the peripheral will transmit and receive.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>5 data bits per character</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>6 data bits per character</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>7 data bits per character</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>8 data bits per character</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_MCR</name>
          <description>Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AFCE</name>
              <description>Auto Flow Control Enable
 When this bit is set and FIFOs are enabled, Auto Flow Control features are enabled.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto Flow Control mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto Flow Control mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Loopback Bit
 This bit is used to put the UART into a diagnostic mode for test purposes. If operating in UART mode, data on the UART_TX is held high, while UART_TX is looped back to the UART_RX, internally. In this mode all the interrupts are fully functional.
 In Loopback mode, the modem control inputs are disconnected and the modem control outputs are looped back to the inputs internally.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Loopback mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Loopback mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT2</name>
              <description>This bit is used to directly control the OUT2 output. The value written to this location is inverted and driven out on OUT2. Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the OUT2 output is held inactive high while the value of this location is internally looped back to an input.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OUT2 output deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>OUT2 output asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT1</name>
              <description>This bit is used to directly control the OUT1 output. The value written to this location is inverted and driven out on OUT1. Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the OUT1 output is held inactive high while the value of this location is internally looped back to an input.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OUT1 output deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>OUT1 output asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTS</name>
              <description>Request to Send
This bit is used to directly control the UART_RTS signal. The RTS bit is used to inform the modem that the UART is ready to exchange data.
 When Auto Flow Control mode is not enabled (UART_MCR[AFCE] set to 0), the UART_RTS is set low by programming UART_MCR[RTS] to high. 
In Auto Flow Control and FIFOs enable (UART_FCR[FIFOE] set to 1), the UART_RTS is controlled in the same way, but is also gated with the Rx FIFO threshold trigger (UART_RTS is inactive high when above the threshold). The UART_RTS signal will be deasserted when UART_MCR[RTS] set to 0. 
Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the UART_RTS output is held inactive high while the value of this bit is internally looped back to an input.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART_RTS deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_RTS asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTR</name>
              <description>Data Terminal Ready
This bit is used to directly control the DTR output. The value written to this bit is inverted and driven out on DTR.
 The DTR output is used to inform the modem that the UART is ready to establish communications. 
Note that in Loopback mode (UART_MCR[LOOPBACK] set to 1), the DTR output is held inactive high while the value of this bit is internally looped back to an input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DTR output deasserted (logic1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DTR asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LSR</name>
          <description>Line Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000060</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR_RCVD</name>
              <description>Address Received
If 9-bit data mode (UART_LCR_EXT[DLS_E] set to 1) is enabled, this bit is used to indicate the 9^th bit of the receive data is set to 1. This bit can also be used to indicate whether the incoming character is address or data.
Reading the UART_LSR clears the 9^th bit.
Note: Read UART_LSR register before the next address byte arrives. If there is a delay in clearing the interrupt, then software will not be able to distinguish between multiple address related interrupts.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Indicates the character is data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Indicates the character is address</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFE</name>
              <description>Rx FIFO Error
This bit is only relevant when FIFOs are enabled (UART_FCR[FIFOE] set to 0).
 This bit is used to indicate if there is at least one parity error, framing error, or break interrupt in the FIFO.
This bit is cleared when the UART_LSR is read and the character with the error is at the top of the Rx FIFO and there are no subsequent errors in the FIFO.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error in Rx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error in Rx FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEMT</name>
              <description>Transmitter Empty
This bit is only relevant when FIFOs are enabled (UART_FCR[FIFOE] set to 0).
This bit is set whenever the Transmitter Shift Register and the FIFOs are both empty. If the FIFOs are disabled, this bit is set whenever the UART_THR and the Transmitter Shift Register are both empty.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmitter not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>THRE</name>
              <description>Transmit Holding Register Empty
If THRE mode is disabled (UART_IER[PTIME] set to 0) and regardless of FIFOs being enabled or not, this bit indicates that the UART_THR or Tx FIFO is empty.
 This bit is set whenever data is transferred from the UART_THR or Tx FIFO to the Transmitter Shift Register and no new data has been written to the UART_THR or Tx FIFO. 
This also causes a THRE interrupt to occur, if the THRE interrupt is enabled. If both modes are active (UART_IER[PTIME] set to 1 and UART_FCR[FIFOE] set to 1, respectively), the functionality is switched to indicate the Tx FIFO is full, and no longer controls THRE interrupts, which are then controlled by the UART_FCR[TET] threshold setting.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>THRE interrupt control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>THRE interrupt control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BI</name>
              <description>Break Interrupt
This bit is used to indicate the detection of a break sequence on the serial input data.
If in UART mode, it is set whenever the UART_RX is held in a logic 0 state for longer than the sum of start time + data bits + parity + stop bits.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
 Reading the UART_LSR or UART_RBR clears the BI bit.
In the Non-FIFO mode, this bit is set immediately and persists until the UART_LSR is read.
Note: If a FIFO is full when a break condition is received, a FIFO overrun occurs. The break condition and all the information associated with it-parity and framing errors-is discarded; any information that a break character was received is lost.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No break sequence detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Break sequence detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FE</name>
              <description>Framing Error
This bit is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid UART_LCR[STOP] bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO. When a framing error occurs the UART will try resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit (data, and/or parity and stop).
It should be noted that the UART_LSR[FE] bit will be set if a break interrupt has occurred, as indicated by the BI bit. This happens because the break character implicitly generates a framing error by holding the UART_RX to logic 0 for longer than the duration of a character.
Reading the UART_LSR or UART_RBR clears this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No framing error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framing error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PE</name>
              <description>Parity Error
This bit is used to indicate the occurrence of a parity error in the receiver if the UART_LCR[PEN] bit is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that this bit will be set if a break interrupt has occurred, as indicated by the BI bit. In this situation, the PE bit is set if parity generation and detection is enabled (UART_LCR[PEN] is set to 1) and the parity is set to odd (UART_LCR[EPS] is set to 0).
 Reading the UART_LSR or UART_RBR clears this bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No parity error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Parity error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OE</name>
              <description>Overrun Error 
This bit is used to indicate the occurrence of an overrun error. This occurs if a new data character was received before the previous data was read.
 In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the Receiver Shift Register is lost.
 Reading the UART_LSR or UART_RBR clears this bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No overrun error </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Overrun error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DR</name>
              <description>Data Ready 
This bit is used to indicate that the receiver contains at least one character in the UART_RBR or the receiver FIFO. This bit is cleared when the UART_RBR is read in the Non-FIFO mode, or when the receiver FIFO is empty, in the FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No data ready </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_MSR</name>
          <description>Modem Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCD</name>
              <description>Data Carrier Detect
This bit is used to indicate the current state of the modem control line DCD. When the Data Carrier Detect input (DCD) is asserted it is an indication that the carrier has been detected by the modem or data set.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), DCD is the same as UART_MCR[OUT2] bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DCD input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DCD input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RI</name>
              <description>Ring Indicator
This bit is used to indicate the current state of the modem control line RI. When this bit is asserted it is an indication that a telephone ringing signal has been received by the modem data set.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), RI is the same as UART_MCR[OUT1].</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RI input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RI input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSR</name>
              <description>Data Set Ready
This bit is used to indicate the current state of the modem control line DSR. When this bit is asserted it is an indication that the modem or data set is ready to establish communications with the UART.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), DSR is the same as UART_MCR[DTR].</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DSR input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DSR input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTS</name>
              <description>Clear to Send
This bit is used to indicate the current state of the modem control line CTS. When this bit is asserted it is an indication that the modem or data set is ready to exchange data with the UART.
In Loopback mode (UART_MCR[LOOPBACK] set to 1), CTS is the same as UART_MCR[RTS].</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CTS input is deasserted (logic 1)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CTS input is asserted (logic 0)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDCD</name>
              <description>Delta Data Carrier Detect
This bit is used to indicate that the modem control line DCD has changed since the last time the UART_MSR was read.
Reading the UART_MSR clears the DDCD bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), DDCD reflects changes on UART_MCR[OUT2].
if the DDCD bit is not set and the DCD signal is asserted (low) and a reset occurs, then the DDCD bit will get set when the reset is removed if the DCD signal remains asserted.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on DCD since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on DCD since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TERI</name>
              <description>Trailing Edge of Ring Indicator
This bit is used to indicate that a change on the input RI (from an active low, to an inactive high state) has occurred since the last time the UART_MSR was read.
Reading the UART_MSR clears the TERI bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), this bit reflects when UART_MCR[OUT1] has changed state from a high to a low.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on RI since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on RI since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDSR</name>
              <description>Delta Data Set Ready
This bit is used to indicate that the modem control line DSR has changed since the last time the UART_MSR was read.
Reading the UART_MSR clears the DDSR bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), DDSR reflects changes on UART_MCR[DTR].
Note: If the DDSR bit is not set and the DSR signal is asserted (low) and a reset occurs, then the DDSR bit will get set when the reset is removed if the DSR signal remains asserted.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on DSR since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on DSR since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCTS</name>
              <description>Delta Clear to Send
This bit is used to indicate that the modem control line CTS has changed since the last time the UART_MSR was read.
Reading the UART_MSR clears the DCTS bit. In Loopback mode (UART_MCR[LOOPBACK] set to 1), DCTS reflects changes on UART_MCR[RTS].
If the DCTS bit is not set and the CTS signal is asserted (low) and a reset occurs, then the DCTS bit will get set when the reset is removed if the CTS signal remains asserted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No change on CTS since last read of UART_MSR</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Change on CTS since last read of UART_MSR</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SCR</name>
          <description>Scratchpad Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCR</name>
              <description>This field is to use as a temporary storage space. It has no defined purpose in the UART.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>UART_SRBR[%s]</name>
          <description>Shadow Receive Buffer Register (n)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRBRN</name>
              <description>This is a shadow field for the UART_RBR[RBR] field and has been allocated 16 32-bit locations so as to accommodate burst accesses from the master. This field contains the data byte received on the UART_RX in UART mode. The data in this field is valid only if the UART_LSR[DR] bit is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0), the data in the UART_RBR[RBR] must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error.
If FIFOs are enabled (UART_FCR[FIFOE] set to 1), this register accesses the head of the Rx FIFO. If the Rx FIFO is full and this field is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>UART_STHR[%s]</name>
          <description>Shadow Transmit Holding Register (n)</description>
          <alternateRegister>UART_SRBR[%s]</alternateRegister>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STHRN</name>
              <description>This is a shadow field for the UART_THR[THR] and has been allocated 16 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the UART_TX in UART mode. Data should only be written to the UART_THR when the UART_LSR[THRE] bit is set.
If FIFOs are disabled (UART_FCR[FIFOE] set to 0) and UART_LSR[THRE] is set, writing a single character to the UART_THR[THR] clears the UART_LSR[THRE]. Any additional writes to the UART_THR[THR] before the UART_LSR[THRE] is set again causes the UART_THR[THR] data to be overwritten.
If FIFOs are enabled (UART_FCR[FIFOE] set to 1) and UART_LSR[THRE] is set, 32 data characters may be written to the UART_THR[THR] before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost.</description>
              <bitRange>[8:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FAR</name>
          <description>FIFO Access Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAR</name>
              <description>This bit is used to enable a FIFO access mode for testing, so that the Rx FIFO can be written and the Tx FIFO can be read when FIFOs are enabled. When FIFOs are not enabled it allows the UART_RBR[RBR] to be written by the master and the UART_THR[THR] to be read by the master.
Note: When the FIFO access mode is enabled/disabled, the control portion of the Rx FIFO and Tx FIFO is reset and the FIFOs are treated as empty.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO access mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO access mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TFR</name>
          <description>Tx FIFO Read Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFR</name>
              <description>This field is only valid when FIFO access mode is enabled (UART_FAR[FAR] set to 1).
When FIFOs are enabled, reading this field gives the data at the top of the Tx FIFO. Each consecutive read pops the Tx FIFO and gives the next data value that is currently at the top of the FIFO.
When FIFOs are not enabled, reading it gives the data in the UART_THR[THR] field.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RFW</name>
          <description>Rx FIFO Write Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFFE</name>
              <description>Rx FIFO Framing Error
 When FIFOs are enabled, this bit is used to write framing error detection information to the Rx FIFO. 
When FIFOs are not enabled, this bit is used to write framing error detection information to the UART_RBR[RBR].</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Frame error disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Frame error enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFPE</name>
              <description>Rx FIFO Parity Error
 When FIFOs are enabled, this bit is used to write parity error detection information to the Rx FIFO.
When FIFOs are not enabled, this bit is used to write parity error detection information to the UART_RBR[RBR].</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Parity error disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Parity error enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFWD</name>
              <description>Rx FIFO Write Data
 When FIFOs are enabled, the data that is written to this bit is pushed into the Rx FIFO. Each consecutive write pushes the new data to the next write location in the Rx FIFO. 
When FIFOs are not enabled, the data that is written to this bit is pushed into the UART_RBR[RBR].</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_USR</name>
          <description>UART Status Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFF</name>
              <description>Rx FIFO Full
This bit is used to indicate that the Rx FIFO is completely full. This bit is cleared when the Rx FIFO is no longer full.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO is not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Rx FIFO Not Empty
This bit is used to indicate that the Rx FIFO contains one or more entries. This bit is cleared when the Rx FIFO is empty.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO is not empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Tx FIFO Empty
 This bit is used to indicate that the Tx FIFO is completely empty. This bit is cleared when the Tx FIFO is no longer empty.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO is not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Tx FIFO Not Full
This bit is used to indicate that the Tx FIFO is not full. This bit is cleared when the Tx FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO is not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TFL</name>
          <description>Tx FIFO Level Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFL</name>
              <description>This field indicates the number of data entries in the Tx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RFL</name>
          <description>Rx FIFO Level Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFL</name>
              <description>This field indicates the number of data entries in the Rx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRR</name>
          <description>Software Reset Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XFR</name>
              <description>Tx FIFO Reset
 This is a shadow bit for the UART_FCR[XFIFOR] bit. It is used to remove the burden on software having to store previously written UART_FCR values just to reset the Tx FIFO. This resets the control portion of the Tx FIFO and treats the FIFO as empty. This will also deassert the DMA Tx request and single signals when additional DMA handshaking signals are selected. Note that this bit is self-clearing.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RFR</name>
              <description>Rx FIFO Reset
 This is a shadow bit for the UART_FCR[RFIFOR] bit. It is used to remove the burden on software having to store previously written UART_FCR values just to reset the Rx FIFO. This resets the control portion of the Rx FIFO and treats the FIFO as empty. This will also deassert the DMA Rx request and single signals when additional DMA handshaking signals are selected. Note that this bit is self-clearing.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>UR</name>
              <description>UART Reset
This bit asynchronously resets the UART and synchronously removes the reset assertion. Both PCLK and SCLK will be reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No UART reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRTS</name>
          <description>Shadow Request to Send Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRTS</name>
              <description>This is a shadow bit for the UART_MCR[RTS] bit, used to remove the burden of having to perform a read / modify write on the UART_MCR. This is used to directly control the UART_RTS. The UART_RTS is used to inform the modem or data set that the UART is ready to exchange data.
When UART_MCR[AFCE] bit is set to 0, the UART_RTS is set low by programming UART_MCR[RTS] to a high.
When UART_MCR[AFCE] bit is set to 1 and UART_FCR[FIFOE] set to 1, the UART_RTS signal is controlled in the same way, but is also gated with the Rx FIFO threshold trigger (UART_RTS signal is in active high when above the threshold) only when RTC flow-control trigger is disabled; otherwise it is gated by the Rx FIFO almost-full trigger, where almost full refers to two available slots in the FIFO (UART_RTS signal is in active high when above the threshold).
Note: In Loopback mode (UART_MCR[LOOPBACK] bit set to 1), the UART_RTS signal is held in active high while the value of this bit is internally looped back to an input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shadow UART_RTS logic 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shadow UART_RTS logic 0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SBCR</name>
          <description>Shadow Break Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SBCB</name>
              <description>This is a shadow bit for the UART_LCR[BC] bit, used to remove the burden of having to perform a read / modify write on the UART_LCR. It is used to cause a break condition to be transmitted to the receiving device. If SBCB is set to one the UART_TX signal is forced to the spacing (logic 0) state. 
When not in Loopback mode (UART_MCR[LOOPBACK] set to 0), the UART_TX signal is forced low until the UART_LCR[BC] bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No spacing on UART_TX signal </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_TX forced to the spacing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SDMAM</name>
          <description>Shadow DMA Mode Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDMAM</name>
              <description>This is a shadow bit for the UART_FCR[DMAM] bit. It is used to remove the burden of having to store the previously written value to the UART_FCR in memory and having to mask this value so that only the UART_FCR[DMAM] bit gets updated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mode 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Mode 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SFE</name>
          <description>Shadow FIFO Enable Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFE</name>
              <description>This is a shadow bit for the UART_FCR[FIFOE] bit. It is used to remove the burden of having to store the previously written value to the UART_FCR in memory and having to mask this value so that only the FIFO enable bit gets updated. 
This enables/disables the Tx FIFOs. If this bit is set to 0 after being enabled then both the Tx and Rx controller portion of FIFOs will be reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFOs are disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFOs are enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_SRT</name>
          <description>Shadow RCVR Trigger Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRT</name>
              <description>This is a shadow field for the UART_FCR[RT] field. It is used to remove the burden of having to store the previously written value to the UART_FCR[RT] in memory and having to mask this value so that only the UART_FCR[RT] bit gets updated.
SRT is used to select the trigger level in the Rx FIFO at which the Received Data Available interrupt will be generated. It also determines when the DMA_RX_REQ signal will be asserted when UART_FCR[DMAM] bit set to 1.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 character in FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 2 less than full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_STET</name>
          <description>Shadow Tx Empty Trigger Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STET</name>
              <description>This is a shadow field for the UART_FCR[TET] field. It is used to remove the burden of having to store the previously written value to the UART_FCR[TET] in memory and having to mask this value so that only the UART_FCR[TET] bit gets updated. STET is used to select the empty threshold level at which the THRE interrupts will be generated when the mode is active.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 characters in FIFO</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO 1/4 full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>FIFO 1/2 full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_HTX</name>
          <description>Halt Tx Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTX</name>
              <description>This bit is used to halt transmissions for testing, so that the Tx FIFO is filled by the master when FIFOs are enabled.
Note: If FIFOs are not enabled the setting of this bit will have no effect on operation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Halt transmission disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Halt transmission enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DMASA</name>
          <description>DMA Software Acknowledge Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASA</name>
              <description>This bit is used to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. 
For example, if the DMA disables the channel, then the UART should clear its request. This will cause the Tx request, Tx single, Rx request and Rx single signals to deassert. 
Note: This bit is self-clearing.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA software acknowledge</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TCR</name>
          <description>Transceiver Control Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XFER_MODE</name>
              <description>Transfer Mode
Hardware will consider the Turnaround timings which are programmed in the UART_TAT register while switching from RE to DE or DE to RE. For transmission hardware will wait if it is in middle of receiving any transfer, before it starts transmitting.
If the SW programs the Tx FIFO with the data then UART (after ensuring no receive is in progress), disables RE and enables DE signal.
Once the Tx FIFO becomes empty, RE signal gets enabled and DE signal will be disabled. Hardware will consider the Turnaround timings which are programmed in the UART_TAT register while switching from RE to DE or DE to RE. The DE and RE signals are strictly complementary to each other.</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>In this mode, transmit and receive can happen simultaneously. UART_DE_EN[DE_ENABLE], UART_RE_EN[RE_ENABLE] can be enabled at any point of time. Turnaround timing as programmed in the UART_TAT register is not applicable in this mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>In this mode, DE and RE are mutually exclusive. Either DE or RE is expected to be enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> In this mode, DE and RE are mutually exclusive. Once UART_DE_EN/UART_RE_EN register is set-by default RE will be enabled and UART controller will be ready to receive. </description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DE_POL</name>
              <description>Driver Enable Polarity</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DE signal is active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DE signal is active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE_POL</name>
              <description>Receiver Enable Polarity</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RE signal is active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RE signal is active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RS485_EN</name>
              <description>RS485 Transfer Enable
All other fields in this register are reserved and registers UART_DE_EN, UART_RE_EN, and UART_TAT are also reserved.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The transfers will happen in RS485 mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DE_EN</name>
          <description>Driver Output Enable Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DE_ENABLE</name>
              <description>This bit is used to control assertion and deassertion of DE signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Deassert DE signal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assert DE signal</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RE_EN</name>
          <description>Receiver Output Enable Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RE_ENABLE</name>
              <description>This bit is used to control assertion and deassertion of RE signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Deassert RE signal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assert RE signal</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DET</name>
          <description>Driver Output Enable Timing Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DE_DE_ASSERTION_TIME</name>
              <description>Driver Enable Deassertion Time
This field controls the amount of time (in terms of number of SCLK periods) between the end of the stop bit on the UART_TX signal to the falling edge of DE signal.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DE_ASSERTION_TIME</name>
              <description>Driver Enable Assertion Time
This field controls the amount of time (in terms of number of SCLK periods) between the assertion of rising edge of DE signal to serial transmit enable. Any data in transmit buffer, will start on UART_TX signal after the transmit enable.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TAT</name>
          <description>Turnaround Timing Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RE_TO_DE</name>
              <description>Receiver Enable to Driver Enable Turnaround time
Turnaround time (in terms of SCLK) for RE deassertion to DE assertion:
 - If the UART_DET[DE_ASSERTION_TIME] field is 0, then the actual value is the programmed value + 3. 
- If the UART_DET[DE_ASSERTION_TIME] field is 1, then the actual value is the programmed value + 2. 
- If the UART_DET[DE_ASSERTION_TIME] field is greater than 1, then the actual value is the programmed value + 1.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DE_TO_RE</name>
              <description>Driver Enable to Receiver Enable TurnAround time.
Turnaround time (in terms of SCLK) for DE Deassertion to RE assertion:
The actual time is the programmed value + 1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_DLF</name>
          <description>Divisor Latch Fraction Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLF</name>
              <description>This field defines the fractional value that is added to the integer value set by UART_DLH, UART_DLL.
 Fractional value = DLF / 2^DLF_SIZE, where DLF_SIZE = 4.
For more information, see Section UART Fractional Baud Rate Support.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RAR</name>
          <description>Receive Address Register</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RAR</name>
              <description>This field is an address matching field during Receive mode. If the 9^th bit is set in the incoming character, then the remaining 8-bits will be checked against this field value. If the match happens, then sub-sequent characters with 9^th bit set to 0 will be treated as data byte until the next address byte is received.
 This field is applicable only when UART_LCR_EXT[ADDR_MATCH] and UART_LCR_EXT[DLS_E] bits are set to 1.
RAR can be programmed at any point of the time. However, it must not be changed during any receive is in progress.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TAR</name>
          <description>Transmit Address Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAR</name>
              <description>This field is an address matching filed during Transmit mode. If UART_LCR_EXT[DLS_E] bit is enabled, then UART will send the 9-bit character with 9^th bit set to 1 and remaining 8-bit address will be sent from this field provided UART_LCR_EXT[SEND_ADDR] bit set to 1.
This field is used only to send the address. The normal data should be sent by programming UART_THR[THR] field.
Once the address starts to be send on the UART serial lane, then UART_LCR_EXT[SEND_ADDR] bit will be auto-cleared.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_LCR_EXT</name>
          <description>Line Extended Control Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRANSMIT_MODE</name>
              <description>This bit is used to control the type of Transmit mode during 9-bit data transfers.
Address: 9^th bit set to 1; Data: 9^th bit set to 0.
Note: The UART_TAR[TAR] field is not applicable in this mode of operation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>In this mode of operation, UART_THR[THR] field and from UART_STHR0[STHRN] to UART_STHR15[STHR15] fields are 8-bit wide. Program the address into UART_TAR[TAR] field and data into the UART_THR/UART_STHR registers. The UART_LCR_EXT[SEND_ADDR] bit is used as a control knob to indicate the UART on when to send the address.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>In this mode of operation, UART_THR[THR] field and from UART_STHR0[STHRN] to UART_STHR15[STHR15] fields are 9-bit wide.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEND_ADDR</name>
              <description>This bit is used as a control knob to determine when to send the address during Transmit mode.
This bit is auto-cleared, after sending out the address character.
This field is applicable only when UART_LCR_EXT[DLS_E] bit is set to 1 and UART_LCR_EXT[TRANSMIT_MODE] is set to 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>9-bit character will be transmitted with 9^th bit set to 0 and the remaining 8-bits will be taken from the Tx FIFO which is programmed through 8-bit wide UART_THR/UART_STHR registers.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>9-bit character will be transmitted with 9^th bit set to 1 and the remaining 8-bits will match to what is being programmed in UART_TAR register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>This bit is used to enable the address match feature during Receive mode.
This bit is applicable only when UART_LCR_EXT[DLS_E] is set to 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal mode. The UART will start to receive the data and 9-bit character will be formed and written into the receive Rx FIFO. Then read the data and differentiate address and data.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Address match mode. The UART will wait until the incoming character with 9^th bit set to 1 and further checks to see if the address matches with what is programmed in UART_RAR register. If match is found, then sub-sequent characters will be treated as valid data and UART starts receiving data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DLS_E</name>
              <description>Extension for DLS
This bit is used to enable 9-bit data for transmit and receive transfers.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_REG_TIMEOUT_RST</name>
          <description>Timeout Counter Reset Value Register</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_TIMEOUT_RST</name>
              <description>This field holds reset value of register timeout counter.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CPR</name>
          <description>Module Configuration Register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00023F32</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_MODE</name>
              <description>The value of this field defines the FIFO mode.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FIFO mode is 32</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_EXTRA</name>
              <description>The value of this bit defines the DMA.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA_EXTRA enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UART_ADD_ENCODED_PARAMS</name>
              <description>The value of this bit defines the capability of reading encoded information about module configuration settings. Reading 1 in this bit means that the capability of reading this encoded information via software has been enabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART_ADD_ENCODED_PARAMS enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SHADOW</name>
              <description>The value of this bit defines the shadow registers.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SHADOW enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_STAT</name>
              <description>The value of this bit defines the FIFO status.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO_STAT enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_ACCESS</name>
              <description>The value of this bit defines the FIFO access.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO ACCESS enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDITIONAL_FEAT</name>
              <description>The value of this bit defines the additional features.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Additional features enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIR_LP_MODE</name>
              <description>The value of this bit defines the SIR low power mode.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SIR_LP mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIR_MODE</name>
              <description>The value of this bit defines the SIR mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SIR mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>THRE_MODE</name>
              <description>The value of this bit defines the THRE mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>THRE mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AFCE_MODE</name>
              <description>The value of this bit defines the AFCE mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AFCE mode enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>The value of this field defines the APB data width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>APB data width is 32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_UCV</name>
          <description>Reserved</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3430322A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART_COMPONENT_VERSION</name>
              <description>Reserved.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTR</name>
          <description>Reserved</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x44570110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIPHERAL_ID</name>
              <description>Reserved.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPI2C</name>
      <baseAddress>0x43009000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>36</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>LPI2C_READWRITE_DATA</name>
          <description>Read/Write Data Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>If the corresponding FIFO is not empty/full, a byte of data can be read/written to this address. From the FIFO's perspective, it would be like a pop/push.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI2C_INFIFO_STATUS</name>
          <description>Inbound FIFO Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WEMPTY</name>
              <description>This field shows if the inbound FIFO is empty</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WFULL</name>
              <description>This field shows if the inbound FIFO is full</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WSIZE</name>
              <description>This field shows the number of available bytes of data in the inbound FIFO</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI2C_OUTFIFO_STATUS</name>
          <description>Outbound FIFO Status Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REMPTY</name>
              <description>This field shows if the outbound FIFO is empty</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFULL</name>
              <description>This field shows if the outbound FIFO is full</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RSIZE</name>
              <description>This field shows the number of available bytes of data in the outbound FIFO</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UTIMER</name>
      <baseAddress>0x48000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65848</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>UTIMER_IRQ0</name>
        <description>Channel 0, interrupt request 0</description>
        <value>377</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ1</name>
        <description>Channel 0, interrupt request 1</description>
        <value>378</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ2</name>
        <description>Channel 0, interrupt request 2</description>
        <value>379</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ3</name>
        <description>Channel 0, interrupt request 3</description>
        <value>380</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ4</name>
        <description>Channel 0, interrupt request 4</description>
        <value>381</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ5</name>
        <description>Channel 0, interrupt request 5</description>
        <value>382</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ6</name>
        <description>Channel 0, interrupt request 6</description>
        <value>383</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ7</name>
        <description>Channel 0, interrupt request 7</description>
        <value>384</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ10</name>
        <description>Channel 1, interrupt request 10</description>
        <value>387</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ11</name>
        <description>Channel 1, interrupt request 11</description>
        <value>388</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ12</name>
        <description>Channel 1, interrupt request 12</description>
        <value>389</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ13</name>
        <description>Channel 1, interrupt request 13</description>
        <value>390</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ14</name>
        <description>Channel 1, interrupt request 14</description>
        <value>391</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ15</name>
        <description>Channel 1, interrupt request 15</description>
        <value>392</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ8</name>
        <description>Channel 1, interrupt request 8</description>
        <value>385</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ9</name>
        <description>Channel 1, interrupt request 9</description>
        <value>386</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ16</name>
        <description>Channel 2, interrupt request 16</description>
        <value>393</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ17</name>
        <description>Channel 2, interrupt request 17</description>
        <value>394</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ18</name>
        <description>Channel 2, interrupt request 18</description>
        <value>395</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ19</name>
        <description>Channel 2, interrupt request 19</description>
        <value>396</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ20</name>
        <description>Channel 2, interrupt request 20</description>
        <value>397</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ21</name>
        <description>Channel 2, interrupt request 21</description>
        <value>398</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ22</name>
        <description>Channel 2, interrupt request 22</description>
        <value>399</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ23</name>
        <description>Channel 2, interrupt request 23</description>
        <value>400</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ24</name>
        <description>Channel 3, interrupt request 24</description>
        <value>401</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ25</name>
        <description>Channel 3, interrupt request 25</description>
        <value>402</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ26</name>
        <description>Channel 3, interrupt request 26</description>
        <value>403</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ27</name>
        <description>Channel 3, interrupt request 27</description>
        <value>404</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ28</name>
        <description>Channel 3, interrupt request 28</description>
        <value>405</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ29</name>
        <description>Channel 3, interrupt request 29</description>
        <value>406</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ30</name>
        <description>Channel 3, interrupt request 30</description>
        <value>407</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ31</name>
        <description>Channel 3, interrupt request 31</description>
        <value>408</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ32</name>
        <description>Channel 4, interrupt request 32</description>
        <value>409</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ33</name>
        <description>Channel 4, interrupt request 33</description>
        <value>410</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ34</name>
        <description>Channel 4, interrupt request 34</description>
        <value>411</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ35</name>
        <description>Channel 4, interrupt request 35</description>
        <value>412</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ36</name>
        <description>Channel 4, interrupt request 36</description>
        <value>413</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ37</name>
        <description>Channel 4, interrupt request 37</description>
        <value>414</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ38</name>
        <description>Channel 4, interrupt request 38</description>
        <value>415</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ39</name>
        <description>Channel 4, interrupt request 39</description>
        <value>416</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ40</name>
        <description>Channel 5, interrupt request 40</description>
        <value>417</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ41</name>
        <description>Channel 5, interrupt request 41</description>
        <value>418</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ42</name>
        <description>Channel 5, interrupt request 42</description>
        <value>419</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ43</name>
        <description>Channel 5, interrupt request 43</description>
        <value>420</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ44</name>
        <description>Channel 5, interrupt request 44</description>
        <value>421</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ45</name>
        <description>Channel 5, interrupt request 45</description>
        <value>422</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ46</name>
        <description>Channel 5, interrupt request 46</description>
        <value>423</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ47</name>
        <description>Channel 5, interrupt request 47</description>
        <value>424</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ48</name>
        <description>Channel 6, interrupt request 48</description>
        <value>425</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ49</name>
        <description>Channel 6, interrupt request 49</description>
        <value>426</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ50</name>
        <description>Channel 6, interrupt request 50</description>
        <value>427</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ51</name>
        <description>Channel 6, interrupt request 51</description>
        <value>428</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ52</name>
        <description>Channel 6, interrupt request 52</description>
        <value>429</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ53</name>
        <description>Channel 6, interrupt request 53</description>
        <value>430</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ54</name>
        <description>Channel 6, interrupt request 54</description>
        <value>431</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ55</name>
        <description>Channel 6, interrupt request 55</description>
        <value>432</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ56</name>
        <description>Channel 7, interrupt request 56</description>
        <value>433</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ57</name>
        <description>Channel 7, interrupt request 57</description>
        <value>434</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ58</name>
        <description>Channel 7, interrupt request 58</description>
        <value>435</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ59</name>
        <description>Channel 7, interrupt request 59</description>
        <value>436</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ60</name>
        <description>Channel 7, interrupt request 60</description>
        <value>437</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ61</name>
        <description>Channel 7, interrupt request 61</description>
        <value>438</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ62</name>
        <description>Channel 7, interrupt request 62</description>
        <value>439</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ63</name>
        <description>Channel 7, interrupt request 63</description>
        <value>440</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ64</name>
        <description>Channel 8, interrupt request 64</description>
        <value>441</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ65</name>
        <description>Channel 8, interrupt request 65</description>
        <value>442</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ66</name>
        <description>Channel 8, interrupt request 66</description>
        <value>443</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ67</name>
        <description>Channel 8, interrupt request 67</description>
        <value>444</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ68</name>
        <description>Channel 8, interrupt request 68</description>
        <value>445</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ69</name>
        <description>Channel 8, interrupt request 69</description>
        <value>446</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ70</name>
        <description>Channel 8, interrupt request 70</description>
        <value>447</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ71</name>
        <description>Channel 8, interrupt request 71</description>
        <value>448</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ72</name>
        <description>Channel 9, interrupt request 72</description>
        <value>449</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ73</name>
        <description>Channel 9, interrupt request 73</description>
        <value>450</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ74</name>
        <description>Channel 9, interrupt request 74</description>
        <value>451</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ75</name>
        <description>Channel 9, interrupt request 75</description>
        <value>452</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ76</name>
        <description>Channel 9, interrupt request 76</description>
        <value>453</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ77</name>
        <description>Channel 9, interrupt request 77</description>
        <value>454</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ78</name>
        <description>Channel 9, interrupt request 78</description>
        <value>455</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ79</name>
        <description>Channel 9, interrupt request 79</description>
        <value>456</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ80</name>
        <description>Channel 10, interrupt request 80</description>
        <value>457</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ81</name>
        <description>Channel 10, interrupt request 81</description>
        <value>458</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ82</name>
        <description>Channel 10, interrupt request 82</description>
        <value>459</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ83</name>
        <description>Channel 10, interrupt request 83</description>
        <value>460</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ84</name>
        <description>Channel 10, interrupt request 84</description>
        <value>461</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ85</name>
        <description>Channel 10, interrupt request 85</description>
        <value>462</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ86</name>
        <description>Channel 10, interrupt request 86</description>
        <value>463</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ87</name>
        <description>Channel 10, interrupt request 87</description>
        <value>464</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ88</name>
        <description>Channel 11, interrupt request 88</description>
        <value>465</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ89</name>
        <description>Channel 11, interrupt request 89</description>
        <value>466</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ90</name>
        <description>Channel 11, interrupt request 90</description>
        <value>467</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ91</name>
        <description>Channel 11, interrupt request 91</description>
        <value>468</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ92</name>
        <description>Channel 11, interrupt request 92</description>
        <value>469</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ93</name>
        <description>Channel 11, interrupt request 93</description>
        <value>470</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ94</name>
        <description>Channel 11, interrupt request 94</description>
        <value>471</value>
      </interrupt>
      <interrupt>
        <name>UTIMER_IRQ95</name>
        <description>Channel 11, interrupt request 95</description>
        <value>472</value>
      </interrupt>
      <interrupt>
        <name>QEC0_CMPA_IRQ</name>
        <description>Channel 12 interrupt request at driver A</description>
        <value>369</value>
      </interrupt>
      <interrupt>
        <name>QEC0_CMPB_IRQ</name>
        <description>Channel 12 interrupt request at driver B</description>
        <value>370</value>
      </interrupt>
      <interrupt>
        <name>QEC1_CMPA_IRQ</name>
        <description>Channel 13 interrupt request at driver A</description>
        <value>371</value>
      </interrupt>
      <interrupt>
        <name>QEC1_CMPB_IRQ</name>
        <description>Channel 13 interrupt request at driver B</description>
        <value>372</value>
      </interrupt>
      <interrupt>
        <name>QEC2_CMPA_IRQ</name>
        <description>Channel 14 interrupt request at driver A</description>
        <value>373</value>
      </interrupt>
      <interrupt>
        <name>QEC2_CMPB_IRQ</name>
        <description>Channel 14 interrupt request at driver B</description>
        <value>374</value>
      </interrupt>
      <interrupt>
        <name>QEC3_CMPA_IRQ</name>
        <description>Channel 15 interrupt request at driver A</description>
        <value>375</value>
      </interrupt>
      <interrupt>
        <name>QEC3_CMPB_IRQ</name>
        <description>Channel 15 interrupt request at driver B</description>
        <value>376</value>
      </interrupt>
      <registers>
        <register>
          <name>UTIMER_GLB_CNTR_START</name>
          <description>Channels Global Counter Start Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Write 1 to start the associated channel counter.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CNTR_STOP</name>
          <description>Channels Global Counter Stop Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Write 1 to stop the associated channel counter.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CNTR_CLEAR</name>
          <description>Channels Global Counter Clear Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Write 1 to clear the associated channel counter.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CNTR_RUNNING</name>
          <description>Channels Global Counter Running Status Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Real-time running status of each channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_DRIVER_OEN</name>
          <description>Channels Driver Output Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRIVER_OEN_11</name>
              <description>Channel 11 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_10</name>
              <description>Channel 10 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_9</name>
              <description>Channel 9 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_8</name>
              <description>Channel 8 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_7</name>
              <description>Channel 7 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_6</name>
              <description>Channel 6 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_5</name>
              <description>Channel 5 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_4</name>
              <description>Channel 4 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_3</name>
              <description>Channel 3 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_2</name>
              <description>Channel 2 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_1</name>
              <description>Channel 1 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DRIVER_OEN_0</name>
              <description>Channel 0 active low output enable controls for driver A and B. B is the upper bit, A is the lower bit.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UTIMER_GLB_CLOCK_ENABLE</name>
          <description>Channels Clock Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHANNEL_NUM</name>
              <description>Clock control for each channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>4096</dimIncrement>
          <name>UTIMER_CHANNEL_CFG[%s]</name>
          <addressOffset>0x1000</addressOffset>
          <register>
            <name>UTIMER_START_0_SRC</name>
            <description>Channel (n) Counter Start Source 0 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to start.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to start.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to start.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to start.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to start.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to start.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to start.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to start.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to start.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to start.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to start.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to start.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to start.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to start.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to start.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to start.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to start.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to start.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to start.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to start.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to start.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to start.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to start.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to start.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to start.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to start.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to start.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_START_1_SRC</name>
            <description>Channel (n) Counter Start Source 1 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PGM_EN</name>
                <description>Programatic Start Enabled:</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Global programmatic start is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Global programmatic start is enabled (only for start, stop, and clear).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to start.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to start.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to start.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to start.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to start.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to start.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to start.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to start.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_STOP_0_SRC</name>
            <description>Channel (n) Counter Stop Source 0 Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to stop.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to stop.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to stop.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to stop.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to stop.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to stop.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to stop.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to stop.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to stop.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to stop.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to stop.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to stop.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to stop.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to stop.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to stop.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to stop.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to stop.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to stop.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to stop.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to stop.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to stop.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to stop.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to stop.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to stop.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to stop.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to stop.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to stop.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_STOP_1_SRC</name>
            <description>Channel (n) Counter Stop Source 1 Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PGM_EN</name>
                <description>Programatic Stop Enabled:</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Global programmatic stop is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Global programmatic stop is enabled (only for start, stop, and clear).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to stop.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to stop.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to stop.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to stop.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to stop.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to stop.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to stop.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to stop.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CLEAR_0_SRC</name>
            <description>Channel (n) Counter Clear Source 0 Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to clear.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to clear.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to clear.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to clear.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to clear.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to clear.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to clear.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to clear.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to clear.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to clear.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to clear.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to clear.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to clear.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to clear.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to clear.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to clear.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to clear.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to clear.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to clear.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to clear.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to clear.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to clear.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to clear.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to clear.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to clear.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to clear.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to clear.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CLEAR_1_SRC</name>
            <description>Channel (n) Counter Clear Source 1 Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PGM_EN</name>
                <description>Programmatic Clear Enabled:</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Global programmatic clear is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Global programmatic clear is enabled (only for start, stop, and clear).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to clear.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to clear.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to clear.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to clear.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to clear.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to clear.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to clear.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to clear.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_UP_0_SRC</name>
            <description>Channel (n) Counter Up Count Source 0 Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to increment.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to increment.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to increment.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to increment.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to increment.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to increment.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to increment.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to increment.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to increment.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to increment.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to increment.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to increment.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to increment.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to increment.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to increment.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to increment.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to increment.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to increment.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to increment.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to increment.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to increment.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to increment.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to increment.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to increment.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to increment.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to increment.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to increment.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_UP_1_SRC</name>
            <description>Channel (n) Counter Up Count Source 1 Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to increment.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to increment.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to increment.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to increment.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to increment.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to increment.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to increment.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to increment.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DOWN_0_SRC</name>
            <description>Channel (n) Counter Down Count Source 0 Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG15_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 15 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG15_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 15 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 14 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG14_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 14 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 13 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG13_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 13 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 12 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG12_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 12 causes counter to decrement.
For QEC channels: Reserved, not used.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 11 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER11 causes counter to decrement.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG11_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 11 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER11 causes counter to decrement.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 10 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER10 causes counter to decrement.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG10_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 10 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER10 causes counter to decrement.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 9 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER9 causes counter to decrement.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG9_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 9 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER9 causes counter to decrement.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 8 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER8 causes counter to decrement.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG8_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 8 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER8 causes counter to decrement.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 7 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER7 causes counter to decrement.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG7_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 7 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER7 causes counter to decrement.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 6 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER6 causes counter to decrement.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG6_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 6 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER6 causes counter to decrement.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 5 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER5 causes counter to decrement.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG5_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 5 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER5 causes counter to decrement.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 4 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER4 causes counter to decrement.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG4_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 4 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER4 causes counter to decrement.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 3 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER3 causes counter to decrement.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG3_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 3 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER3 causes counter to decrement.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 2 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER2 causes counter to decrement.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG2_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 2 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER2 causes counter to decrement.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 1 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER1 causes counter to decrement.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG1_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 1 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER1 causes counter to decrement.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_FALLING</name>
                <description>For UTIMER channels: Falling edge of global trigger 0 causes counter to decrement.
For QEC channels: Falling edge of QEC_TRIGGER0 causes counter to decrement.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIG0_RISING</name>
                <description>For UTIMER channels: Rising edge of global trigger 0 causes counter to decrement.
For QEC channels: Rising edge of QEC_TRIGGER0 causes counter to decrement.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DOWN_1_SRC</name>
            <description>Channel (n) Counter Down Count Source 1 Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_B_FALLING_A_1</name>
                <description>For this channel, channel input B is falling and channel input A = 1 causes counter to decrement.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_FALLING_A_0</name>
                <description>For this channel, channel input B is falling and channel input A = 0 causes counter to decrement.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_1</name>
                <description>For this channel, channel input B is rising and channel input A = 1 causes counter to decrement.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_B_RISING_A_0</name>
                <description>For this channel, channel input B is rising and channel input A = 0 causes counter to decrement.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_1</name>
                <description>For this channel, channel input A is falling and channel input B = 1 causes counter to decrement.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_FALLING_B_0</name>
                <description>For this channel, channel input A is falling and channel input B = 0 causes counter to decrement.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_1</name>
                <description>For this channel, channel input A is rising and channel input B = 1 causes counter to decrement.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_A_RISING_B_0</name>
                <description>For this channel, channel input A is rising and channel input B = 0 causes counter to decrement.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_A_0</name>
            <description>Channel (n) Trigger Capture Source A 0 Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_A</name>
                <description>Capture the counter value, when channel input A is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_A_1</name>
            <description>Channel (n) Trigger Capture Source A 1 Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_A</name>
                <description>Capture the counter value, when channel input A is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_B_0</name>
            <description>Channel (n) Trigger Capture Source B 0 Register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_B</name>
                <description>Capture the counter value, when channel input B is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_TRIG_CAPTURE_SRC_B_1</name>
            <description>Channel (n) Trigger Capture Source B 1 Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIG_CAPTURE_SRC_B</name>
                <description>Capture the counter value, when channel input A is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_A_0</name>
            <description>Channel (n) DMA Clear Source A 0 Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_A</name>
                <description>Clear DMA when driver A is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_A_1</name>
            <description>Channel (n) DMA Clear Source A 1 Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_A</name>
                <description>Clear DMA when driver A is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_B_0</name>
            <description>Channel (n) DMA Clear Source B 0 Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_B</name>
                <description>Clear DMA when driver B is the source (decoding is the same as in the UTIMERn_START_0_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DMA_CLEAR_SRC_B_1</name>
            <description>Channel (n) DMA Clear Source B 1 Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_SRC_B</name>
                <description>Clear DMA when driver B is the source (decoding is the same as in the UTIMERn_START_1_SRC register).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PAUSE_SRC</name>
            <description>Channel (n) Counter Pause Source Register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAUSE_SRC_1_LO_EN</name>
                <description>While PAUSE_TRIGGER[1] = 0x0, pause the channel counter.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAUSE_SRC_1_HI_EN</name>
                <description>While PAUSE_TRIGGER[1] = 0x1, pause the channel counter.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAUSE_SRC_0_LO_EN</name>
                <description>While PAUSE_TRIGGER[0] = 0x0, pause the channel counter.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAUSE_SRC_0_HI_EN</name>
                <description>While PAUSE_TRIGGER[0] = 0x1, pause the channel counter.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_CTRL</name>
            <description>Channel (n) Counter Control Register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_DIR</name>
                <description>Counter Direction:
Note: For triangle counter, this will be the direction at a start event
Note: If the direction is changed while the counter is running, it will take effect at the next over/underrun. Changes during triangle wave have no effect.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Up</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Down</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_TYPE</name>
                <description>Counter Type:</description>
                <bitRange>[4:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Sawtooth</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Sawtooth one shot</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Triangle</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Triangle one shot</description>
                    <value>0x6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_RUNNING</name>
                <description>Counter Running:
Note: Writing this bit have no effect.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Count operation is stopped</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Count operation is running </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_EN</name>
                <description>Counter Enable:</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_FILTER_CTRL_A</name>
            <description>Channel (n) Filter Control A Register</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESCALER</name>
                <description>Prescaler function. Allows the input A to be sampled periodically according to the programmed value.
For example, if programmed to 0x10, the input A is sampled every 16 clocks before entering the filter taps.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Input A is sampled every clock before entering the filter taps.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Input A is sampled every clock before entering the filter taps.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xA</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xB</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xC</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xD</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x10</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x11</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x12</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x13</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x14</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x15</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x16</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x17</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x18</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x19</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1A</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1B</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1C</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1D</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1E</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1F</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x1F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x20</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x21</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x22</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x23</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x24</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x25</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x26</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x27</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x28</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x29</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2A</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2B</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2C</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2D</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2E</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2F</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x2F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x30</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x31</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x31</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x32</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x32</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x33</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x33</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x34</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x34</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x35</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x35</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x36</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x36</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x37</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x37</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x38</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x38</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x39</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x39</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3A</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3B</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3C</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3D</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3E</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3F</name>
                    <description>Input A is sampled periodically according to this value. </description>
                    <value>0x3F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FILTER_TAPS</name>
                <description>Number of filter taps.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>Enable the filtering function.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_FILTER_CTRL_B</name>
            <description>Channel (n) Filter Control B Register</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESCALER</name>
                <description>Prescaler function. Allows the input B to be sampled periodically according to the programmed value.
For example, if programmed to 0x10, the input B is sampled every 16 clocks before entering the filter taps.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Input B is sampled every clock before entering the filter taps.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Input B is sampled every clock before entering the filter taps.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xA</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xB</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xC</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xD</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x10</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x11</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x12</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x13</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x14</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x15</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x16</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x17</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x18</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x19</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1A</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1B</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1C</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1D</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1E</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1F</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x1F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x20</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x21</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x22</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x23</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x24</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x25</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x26</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x27</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x28</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x29</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2A</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2B</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2C</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2D</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2E</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2F</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x2F</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x30</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x31</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x31</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x32</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x32</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x33</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x33</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x34</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x34</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x35</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x35</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x36</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x36</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x37</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x37</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x38</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x38</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x39</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x39</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3A</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3A</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3B</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3B</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3C</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3C</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3D</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3E</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3F</name>
                    <description>Input B is sampled periodically according to this value. </description>
                    <value>0x3F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FILTER_TAPS</name>
                <description>Number of filter taps.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>Enable the filtering function.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_CTRL_A</name>
            <description>Channel (n) Compare Control A Register</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_EN</name>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Disable DMA_CLEAR function.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Enable DMA_CLEAR function.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_TRIG_EN</name>
                <description>Enable compare match for trigger input:
Note: Only enable if desire compare function during trigger driven counting.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match when trigger count disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match when trigger count enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_EN</name>
                <description>Enable compare match:</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DISABLE_VAL</name>
                <description>Driver value when output is disabled via bit [8] of this register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVER_EN</name>
                <description>Driver output enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output is disabled, will take value at bit [9] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output is controlled by compare logic.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_START_STOP_LEVEL</name>
                <description>Driver output level at start or stop:</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output at start or stop reflects value at bit [4] and bit [6] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output at start or stop is retained.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_STOP_VAL</name>
                <description>Driver value when counting stops.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_START_VAL</name>
                <description>Driver value when counting starts.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_CYCLE_END</name>
                <description>Driver value at cycle end:</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at cycle end</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at cycle end</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at cycle end </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at cycle end</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_MATCH</name>
                <description>Driver A value at compare match:</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at compare match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at compare match</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at compare match</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at compare match</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_CTRL_B</name>
            <description>Channel (n) Compare Control B Register</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMA_CLEAR_EN</name>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Disable DMA_CLEAR function.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Enable DMA_CLEAR function.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_TRIG_EN</name>
                <description>Enable compare match for trigger input:
Note: Only enable if desire compare function during trigger driven counting.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match when trigger count disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match when trigger count enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_EN</name>
                <description>Enable compare match:</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DISABLE_VAL</name>
                <description>Driver value when output is disabled via bit [8] of this register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVER_EN</name>
                <description>Driver output enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output is disabled, will take value at bit [9] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output is controlled by compare logic.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_START_STOP_LEVEL</name>
                <description>Driver output level at start or stop:</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver output at start or stop reflects value at bit [4] and bit [6] of this register.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver output at start or stop is retained.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_STOP_VAL</name>
                <description>Driver value when counting stops.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_START_VAL</name>
                <description>Driver value when counting starts.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_CYCLE_END</name>
                <description>Driver value at cycle end:</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at cycle end</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at cycle end</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at cycle end </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at cycle end</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRV_MATCH</name>
                <description>Driver B value at compare match:</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Driver value retained at compare match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Driver value is 0x0 at compare match</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Driver value is 0x1 at compare match</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Driver value toggles at compare match</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_BUF_OP_CTRL</name>
            <description>Channel (n) Buffer Operation Control Register</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B_BUF_OP</name>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Single buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Double buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_B_BUF_EVENT</name>
                <description>For triangle wave:
0x0: No transfer (except triangle one shot)
0x1: Transfer at crest
0x2: Transfer at trough
0x3: Transfer at both crest and trough
For sawtooth wave:
0x0: No transfer (except sawtooth one shot)
Any other value: transfer at overflow or underflow (depends on direction)</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_BUF_OP</name>
                <description>Buffer operation at compare on driver A:</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Single buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Double buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_A_BUF_EVENT</name>
                <description>For triangle wave:
0x0: No transfer (except triangle one shot)
0x1: Transfer at crest
0x2: Transfer at trough
0x3: Transfer at both crest and trough
For sawtooth wave:
0x0: No transfer (except sawtooth one shot)
Any other value: transfer at overflow or underflow (depends on direction)</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_COMPARE_BUF_OP</name>
                <description>Writing 1 forces buffer operation of UTIMERn_COMPARE_A and UTIMERn_COMPARE_B registers for one shot modes. For more information, see the explanation on fixed buffering in UTIMER Buffers, including UTIMER Fixed Buffering Block Diagram.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNTR_BUF_OP</name>
                <description>Buffer operation is at overflow/underflow (for triangle wave, only underflow):</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Single buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Double buffer operation</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAPTURE_B_BUF_OP</name>
                <description>Buffer operation at capture on driver B:</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Single buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Double buffer operation</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAPTURE_A_BUF_OP</name>
                <description>Buffer operation at capture on driver A:</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>No buffer operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Single buffer operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Double buffer operation</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPARE_BUF_ENABLE</name>
                <description>Enable buffer operation at compare:</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Buffer operation at compare is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Buffer operation at compare is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_BUF_ENABLE</name>
                <description>Enable counter buffer:</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter buffer operation is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter buffer operation is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAPTURE_BUF_ENABLE</name>
                <description>Enable buffer operation at capture:</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Buffer operation at capture is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Buffer operation at capture is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR</name>
            <description>Channel (n) Counter Register</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR</name>
                <description>Write or read value of the counter.
Note: Value must be written only when the counter is stopped.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PTR</name>
            <description>Channel (n) Counter Pointer Register</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_PTR</name>
                <description>Counter maximum value.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PTR_BUF1</name>
            <description>Channel (n) Counter Pointer Buffer 1 Register</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_PTR_BUF1</name>
                <description>Counter pointer for buffer 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CNTR_PTR_BUF2</name>
            <description>Channel (n) Counter Pointer Buffer 2 Register</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTR_PTR_BUF2</name>
                <description>Counter pointer for buffer 2.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_A</name>
            <description>Channel (n) Capture A Register</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_A</name>
                <description>Top register for capture operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_A_BUF1</name>
            <description>Channel (n) Capture A Buffer 1 Register</description>
            <addressOffset>0xB4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_A_BUF1</name>
                <description>Value of buffer 1 for capture operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_A_BUF2</name>
            <description>Channel (n) Capture A Buffer 2 Register</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_A_BUF2</name>
                <description>Value of buffer 2 for capture operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_B</name>
            <description>Channel (n) Capture B Register</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_B</name>
                <description>Top register for capture operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_B_BUF1</name>
            <description>Channel (n) Capture B Buffer 1 Register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_B_BUF1</name>
                <description>Value of buffer 1 for capture operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CAPTURE_B_BUF2</name>
            <description>Channel (n) Capture B Buffer 2 Register</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_B_BUF2</name>
                <description>Value of buffer 2 for capture operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_A</name>
            <description>Channel (n) Compare A Register</description>
            <addressOffset>0xD0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_A</name>
                <description>Top register for compare operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_A_BUF1</name>
            <description>Channel (n) Compare A Buffer 1 Register</description>
            <addressOffset>0xD4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_A_BUF1</name>
                <description>Value of buffer 1 for compare operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_A_BUF2</name>
            <description>Channel (n) Compare A Buffer 2 Register</description>
            <addressOffset>0xD8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_A_BUF2</name>
                <description>Value of buffer 2 for compare operation on driver A.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_B</name>
            <description>Channel (n) Compare B Register</description>
            <addressOffset>0xE0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B</name>
                <description>Top register for compare operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_B_BUF1</name>
            <description>Channel (n) Compare B Buffer 1 Register</description>
            <addressOffset>0xE4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B_BUF1</name>
                <description>Value of buffer 1 for compare operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_COMPARE_B_BUF2</name>
            <description>Channel (n) Compare B Buffer 2 Register</description>
            <addressOffset>0xE8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMPARE_B_BUF2</name>
                <description>Value of buffer 2 for compare operation on driver B.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_UP</name>
            <description>Channel (n) Dead-time Up Register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_UP</name>
                <description>Dead-time in counter direction up.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_UP_BUF1</name>
            <description>Channel (n) Dead-time Up Buffer 1 Register</description>
            <addressOffset>0xF4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_UP_BUF1</name>
                <description>Dead-time in counter direction up for buffer 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_DOWN</name>
            <description>Channel (n) Dead-time Down Register</description>
            <addressOffset>0xF8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_DOWN</name>
                <description>Dead-time in counter direction down.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DT_DOWN_BUF1</name>
            <description>Channel (n) Dead-time Down Buffer 1 Register</description>
            <addressOffset>0xFC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_DOWN_BUF1</name>
                <description>Dead-time in counter direction down for buffer 1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CHAN_STATUS</name>
            <description>Channel (n) Status Register</description>
            <addressOffset>0x114</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRV_A_B_0</name>
                <description>Drivers A and B are both 0.
Note: This bit contains the current status.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_A_B_1</name>
                <description>Drivers A and B are both 1.
Note: This bit contains the current status.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_DOWN</name>
                <description>Compare on driver B during down counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_UP</name>
                <description>Compare on driver B during up counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_DOWN</name>
                <description>Compare on driver A during down counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_UP</name>
                <description>Compare on driver A during up counting.
 Note: This status bit is only valid when the counter is free-running.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNTR_DIR</name>
                <description>Counter Direction:
Note: This bit contains the current status, only valid if counter is running.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter is downward</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter is upward</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CNTR_RUNNING</name>
                <description>Counter running status:
Note: This bit contains the current status.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Counter is not running.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Counter is running.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVER_FLOW</name>
                <description>An overflow (or crest) had occurred.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UNDER_FLOW</name>
                <description>An underflow (or trough) had occurred.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_B</name>
                <description>Capture event on driver B occurred due to a trigger.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_A</name>
                <description>Capture event on driver A occurred due to a trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CHAN_INTERRUPT</name>
            <description>Channel (n) Interrupt Control Register</description>
            <addressOffset>0x118</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OVER_FLOW</name>
                <description>An overflow event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>UNDER_FLOW</name>
                <description>An underflow event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[6:6]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_B_BUF2</name>
                <description>Compare of COMPARE_B_BUF2.
Write 1 to clear bit.</description>
                <bitRange>[5:5]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_B_BUF1</name>
                <description>Compare of COMPARE_B_BUF1.
Write 1 to clear bit.</description>
                <bitRange>[4:4]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_A_BUF2</name>
                <description>Compare of COMPARE_A_BUF2.
Write 1 to clear bit.</description>
                <bitRange>[3:3]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>COMPARE_A_BUF1</name>
                <description>Compare of COMPARE_A_BUF1.
Write 1 to clear bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>CAPTURE_B</name>
                <description>Capture B or compare B event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>CAPTURE_A</name>
                <description>Capture A or compare A event had occurred.
Write 1 to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_CHAN_INTERRUPT_MASK</name>
            <description>Channel (n) Interrupt Mask Register</description>
            <addressOffset>0x11C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x000000FF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OVER_FLOW</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UNDER_FLOW</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_BUF2</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_B_BUF1</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_BUF2</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPARE_A_BUF1</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_B</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPTURE_A</name>
                <description>Mask for channel interrupts.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DUTY_CYCLE_CTRL</name>
            <description>Channel (n) Duty Cycle Control Register</description>
            <addressOffset>0x120</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DC_UNDERFLOW_B</name>
                <description>Apply duty cycle at underflow of driver B.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_OVERFLOW_B</name>
                <description>Apply duty cycle at overflow of driver B.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_SETTING_B</name>
                <description>Duty cycle setting for driver B:</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>0% duty cycle</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>100% duty cycle</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DC_FORCE_B</name>
                <description>Force duty cycle for output B at cycle start, reflecting the UTIMERn_DUTY_CYCLE_CTRL[DC_SETTING_B] bit field.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_ENABLE_B</name>
                <description>Enable the duty cycle function for driver B.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_UNDERFLOW_A</name>
                <description>Apply duty cycle at underflow of driver A.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_OVERFLOW_A</name>
                <description>Apply duty cycle at overflow of driver A.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_SETTING_A</name>
                <description>Duty cycle setting for driver A:</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Compare match determines duty cycle (no masking)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>0% duty cycle</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>100% duty cycle</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DC_FORCE_A</name>
                <description>Force duty cycle for output A at cycle start, reflecting the UTIMERn_DUTY_CYCLE_CTRL[DC_SETTING_A] bit field.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_ENABLE_A</name>
                <description>Enable the duty cycle function for driver A.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_DEAD_TIME_CTRL</name>
            <description>Channel (n) Dead-time Control Register</description>
            <addressOffset>0x124</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DT_BUF_EN</name>
                <description>Enable dead-time buffer operation.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DT_EN</name>
                <description>Dead-time enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_INT_CNTR_CTRL</name>
            <description>Channel (n) Interrupt Counter Control Register</description>
            <addressOffset>0x130</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INT_CNTR_EN</name>
                <description>Enables the counting of overflow or underflow events.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_CNTR</name>
                <description>Interrupt counter. This number of overflow or underflow events must occur before the corresponding interrupt is triggered.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UTIMER_FAULT_CTRL</name>
            <description>Channel (n) Fault Control Register</description>
            <addressOffset>0x134</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FAULT_TYPE_B</name>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver B low and keep low until overflow or underflow.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver B low and keep low until a counter stop event is seen.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_POLARITY_B</name>
                <description>Bit enable to determine FAULT_TRIGGER[3-0] active polarity for output driver B.</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver B low when associated FAULT_TRIGGER[3-0] is low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver B low when associated FAULT_TRIGGER[3-0] is high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_ENABLE_B</name>
                <description>Bit enable to use FAULT_TRIGGER[3-0] to control channel output driver B.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Associated FAULT_TRIGGER has no effect on output drivers.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Associated FAULT_TRIGGER active to control output drivers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_TYPE_A</name>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver A low and keep low until overflow or underflow.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver A low and keep low until a counter stop event is seen.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_POLARITY_A</name>
                <description>Bit enable to determine FAULT_TRIGGER[3-0] active polarity for output driver A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Will force output driver A low when associated FAULT_TRIGGER[3-0] is low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Will force output driver A low when associated FAULT_TRIGGER[3-0] is high.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FAULT_ENABLE_A</name>
                <description>Bit enable to use FAULT_TRIGGER[3-0] to control channel output driver A.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Associated FAULT_TRIGGER has no effect on output drivers.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Associated FAULT_TRIGGER active to control output drivers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>ETH</name>
      <baseAddress>0x48100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4460</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ETH_PMT_IRQ</name>
        <description>Non-maskable interrupt generated when the MAC receives remote wake-up frame or magic packet</description>
        <value>149</value>
      </interrupt>
      <interrupt>
        <name>ETH_SBD_IRQ</name>
        <description>ETH main interrupt asserted by many events. Its value can also be read via the ETH_STAT0[SBD_INTR_O] bit.</description>
        <value>148</value>
      </interrupt>
      <registers>
        <register>
          <name>ETH_MAC_CONFIGURATION</name>
          <description>MAC Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00008000</resetValue>
          <resetMask>0x8FFBFFFF</resetMask>
          <fields>
            <field>
              <name>ARPEN</name>
              <description>ARP Offload Enable
When this bit is set, the MAC can recognize an incoming ARP request packet and schedules the ARP packet for transmission. It forwards the ARP packet to the application and also indicate the events in the RxStatus.
When this bit is reset, the MAC receiver does not recognize any ARP packet and indicates them as Type frame in the RxStatus.
This bit is available only when the Enable IPv4 ARP Offload is selected.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ARP offload is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ARP offload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPC</name>
              <description>Checksum Offload
When set, this bit enables the IPv4 header checksum checking and IPv4 or IPv6 TCP, UDP, or ICMP payload checksum checking. When this bit is reset, the COE function in the receiver is disabled.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IP header/payload checksum checking is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IP header/payload checksum checking is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPG</name>
              <description>Inter-Packet Gap
These bits control the minimum IPG between packets during transmission. This range of minimum IPG is valid in full-duplex mode.
In the half-duplex mode, the minimum IPG can be configured only for 64-bit times (IPG = 100). Lower values are not considered.
When a JAM pattern is being transmitted because of backpressure activation, the MAC does not consider the minimum IPG.
The above function (IPG less than 96-bit times) is valid only when the ETH_MAC_EXT_CONFIGURATION[EIPGEN] bit is reset. When EIPGEN is set, then the minimum IPG (greater than 96-bit times) is controlled as per the description given in the ETH_MAC_EXT_CONFIGURATION[EIPG] field.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>96-bit times IPG</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>88-bit times IPG</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>80-bit times IPG</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>72-bit times IPG</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>64-bit times IPG</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>56-bit times IPG</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>48-bit times IPG</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>40-bit times IPG</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPSLCE</name>
              <description>Giant Packet Size Limit Control Enable
When this bit is set, the MAC considers the value in the ETH_MAC_EXT_CONFIGURATION[GPSL] field to declare a received packet as Giant packet. This field must be programmed to more than 1,518 bytes. Otherwise, the MAC considers 1,518 bytes as giant packet limit.
When this bit is reset, the MAC considers a received packet as Giant packet when its size is greater than 1,518 bytes (1522 bytes for tagged packet).
The watchdog timeout limit, Jumbo Packet Enable and 2KB Packet Enable have higher precedence over this bit, that is the MAC considers a received packet as Giant packet when its size is greater than 9,018 bytes (9,022 bytes for tagged packet) with Jumbo Packet Enabled and greater than 2,000 bytes with 2KB Packet Enabled. The watchdog timeout, if enabled, terminates the received packet when watchdog limit is reached. Therefore, the programmed giant packet limit should be less than the watchdog limit to get the giant packet status.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Giant packet size limit control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Giant packet size limit control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>S2KP</name>
              <description>IEEE 802.3as Support for 2KB Packets
When this bit is set, the MAC considers all packets with up to 2,000 bytes length as normal packets. When the JE bit is not set, the MAC considers all received packets of size more than 2KB as Giant packets.
When this bit is reset and the JE bit is not set, the MAC considers all received packets of size more than 1,518 bytes (1,522 bytes for tagged) as giant packets.
Note: When the JE bit is set, setting this bit has no effect on the giant packet status.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Support upto 2KB packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Support upto 2KB packet is Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CST</name>
              <description>CRC stripping for Type packets
When this bit is set, the last four bytes (FCS) of all packets of Ether type (type field greater than 1,536) are stripped and dropped before forwarding the packet to the application.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CRC stripping for type packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC stripping for type packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACS</name>
              <description>Automatic Pad or CRC Stripping
When this bit is set, the MAC strips the Pad or FCS field on the incoming packets only if the value of the length field is less than 1,536 bytes. All received packets with length field greater than or equal to 1,536 bytes are passed to the application without stripping the Pad or FCS field.
When this bit is reset, the MAC passes all incoming packets to the application, without any modification.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Automatic Pad or CRC stripping is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Automatic Pad or CRC stripping is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WD</name>
              <description>Watchdog Disable
When this bit is set, the MAC disables the watchdog timer on the receiver. The MAC can receive packets of up to 16,383 bytes.
When this bit is reset, the MAC does not allow more than 2,048 bytes (10,240 if JE is set high) of the packet being received. The MAC cuts off any bytes received after 2,048 bytes.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Watchdog is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Watchdog is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JD</name>
              <description>Jabber Disable
When this bit is set, the MAC disables the jabber timer on the transmitter. The MAC can transfer packets of up to 16,383 bytes.
When this bit is reset, if the application sends more than 2,048 bytes of data (10,240 if JE is set high) during transmission, the MAC does not send rest of the bytes in that packet.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Jabber is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Jabber is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>JE</name>
              <description>Jumbo Packet Enable
When this bit is set, the MAC allows jumbo packets of 9,018 bytes (9,022 bytes for VLAN tagged packets) without reporting a giant packet error in the Rx packet status.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Jumbo packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Jumbo packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PS</name>
              <description>Port Select
This bit selects the Ethernet line speed. This bit, along with the FES bit, selects the exact line speed. Their value is also reflected in the ETH_STAT0[MAC_SPEED_O] field.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>For 10 or 100 Mbps operations</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FES</name>
              <description>Speed
This bit selects the speed mode. Its value along with the PS bit value is also reflected in the ETH_STAT0[MAC_SPEED_O] field.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>10 Mbps</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>100 Mbps</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DM</name>
              <description>Duplex Mode
When this bit is set, the MAC operates in the full-duplex mode in which it can transmit and receive simultaneously.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Half-duplex mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full-duplex mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LM</name>
              <description>Loopback Mode
When this bit is set, the MAC operates in the loopback mode at RMII.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Loopback is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Loopback is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECRSFD</name>
              <description>Enable Carrier Sense Before Transmission in Full-Duplex Mode
When this bit is set, the MAC transmitter checks the ETH_CRS_DV signal before packet transmission in the full-duplex mode. The MAC starts the transmission only when the ETH_CRS_DV signal is low.
When this bit is reset, the MAC transmitter ignores the status of the ETH_CRS_DV signal.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ECRSFD is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ECRSFD is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DO</name>
              <description>Disable Receive Own
When this bit is set, the MAC disables the reception of packets when the ETH_TXEN signal is asserted in the half-duplex mode. When this bit is reset, the MAC receives all packets given by the PHY.
This bit is not applicable in the full-duplex mode.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable receive own</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable receive own</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCRS</name>
              <description>Disable Carrier Sense During Transmission
When this bit is set, the MAC transmitter ignores the RMII ETH_CRS_DV signal during packet transmission in the half-duplex mode. As a result, no errors are generated because of Loss of Carrier or No Carrier during transmission.
When this bit is reset, the MAC transmitter generates errors because of Carrier Sense. The MAC can even abort the transmission.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable carrier sense during transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable carrier sense during transmission</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DR</name>
              <description>Disable Retry
When this bit is set, the MAC attempts only one transmission. When a collision occurs on the RMII interface, the MAC ignores the current packet transmission and reports a Packet Abort with excessive collision error in the Tx packet status.
When this bit is reset, the MAC retries based on the settings of the BL field. This bit is applicable only in the half-duplex mode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable retry</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable retry</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BL</name>
              <description>Back-Off Limit
The back-off limit determines the random integer number (r) of slot time delays (512-bit times) for which the MAC waits before rescheduling a transmission attempt during retries after a collision.n = retransmission attempt.
The random integer r takes the value in the range 0 &lt;= r &lt; 2^k
This bit is applicable only in the half-duplex mode.</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>k = min(n, 10)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>k = min(n, 8)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>k = min(n, 4)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>k = min(n, 1)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC</name>
              <description>Deferral Check
When this bit is set, the deferral check function is enabled in the MAC. The MAC issues a Packet Abort status, along with the excessive deferral error bit set in the Tx packet status, when the Tx state machine is deferred for more than 24,288-bit times in 10 or 100 Mbps mode.
The defer time is not cumulative. For example, if the transmitter defers for 10,000-bit times because the ETH_CRS_DV signal is active and the ETH_CRS_DV signal becomes inactive, the transmitter transmits and collision happens. Because of collision, the transmitter needs to back off and then defer again after back off completion. In such a scenario, the deferral timer is reset to 0, and it is restarted.
When this bit is reset, the deferral check function is disabled and the MAC defers until the ETH_CRS_DV signal goes inactive.
This bit is applicable only in the half-duplex mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Deferral check function is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Deferral check function is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRELEN</name>
              <description>Preamble Length for Transmit packets
These bits control the number of preamble bytes that are added to the beginning of every Tx packet. The preamble reduction occurs only when the MAC is operating in the full-duplex mode.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>7 bytes of preamble</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>5 bytes of preamble</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bytes of preamble</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter Enable
When this bit is set, the Tx state machine of the MAC is enabled for transmission on the RMII interface. When this bit is reset, the MAC Tx state machine is disabled after it completes the transmission of the current packet. The Tx state machine does not transmit any more packets.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmitter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver Enable
When this bit is set, the Rx state machine of the MAC is enabled for receiving packets from the RMII interface. When this bit is reset, the MAC Rx state machine is disabled after it completes the reception of the current packet. The Rx state machine does not receive any more packets from the RMII interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receiver is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receiver is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_EXT_CONFIGURATION</name>
          <description>MAC Extended Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>EIPG</name>
              <description>Extended Inter-Packet Gap
The value in this field is applicable when the EIPGEN bit is set. This field (as Most Significant bits), along with the ETH_MAC_CONFIGURATION[IPG] field, gives the minimum IPG greater than 96-bit times in steps of 8 bit times:{EIPG, IPG}
0x0: 104-bit times
0x1: 112-bit times
0x2: 120-bit times
0xFF: 2144-bit times</description>
              <bitRange>[29:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EIPGEN</name>
              <description>Extended Inter-Packet Gap Enable
When this bit is set, the MAC interprets EIPG field and the ETH_MAC_CONFIGURATION[IPG] field together as minimum IPG greater than 96-bit times in steps of 8 bit times.
When this bit is reset, the MAC ignores EIPG field and interprets the ETH_MAC_CONFIGURATION[IPG] field as minimum IPG less than or equal to 96-bit times in steps of 8 bit times.
Note: The extended Inter-Packet Gap feature must be enabled when operating in Full-Duplex mode only. There may be undesirable effects on back-pressure function and frame transmission if it is enabled in Half-Duplex mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Extended inter-packet gap is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Extended inter-packet gap is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USP</name>
              <description>Unicast Slow Protocol Packet Detect
When this bit is set, the MAC detects the Slow Protocol packets with unicast address of the station specified in the ETH_MAC_ADDRESS0_HIGH and ETH_MAC_ADDRESS0_LOW registers. The MAC also detects the Slow Protocol packets with the Slow Protocols multicast address (01-80-C2-00-00-02).
When this bit is reset, the MAC detects only Slow Protocol packets with the Slow Protocol multicast address specified in the IEEE 802.3-2015 Specification, Section </description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unicast slow protocol packet detection is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Unicast slow protocol packet detection is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPEN</name>
              <description>Slow Protocol Detection Enable
When this bit is set, MAC processes the Slow Protocol packets (Ether Type 0x8809) and provides the Rx status. The MAC discards the Slow Protocol packets with invalid sub-types.
When this bit is reset, the MAC forwards all error-free Slow Protocol packets to the application. The MAC considers such packets as normal Type packets.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slow protocol detection is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slow protocol detection is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCRCC</name>
              <description>Disable CRC Checking for Received Packets
When this bit is set, the MAC receiver does not check the CRC field in the received packets. When this bit is reset, the MAC receiver always checks the CRC field in the received packets.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CRC checking is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC checking is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPSL</name>
              <description>Giant Packet Size Limit
If the received packet size is greater than the value programmed in this field in units of bytes, the MAC declares the received packet as Giant packet. The value programmed in this field must be greater than or equal to 1,518 bytes. Any other programmed value is considered as 1,518 bytes.
For VLAN tagged packets, the MAC adds 4 bytes to the programmed value. When the Enable Double VLAN Processing option is selected, the MAC adds 8 bytes to the programmed value for double VLAN tagged packets. The value in this field is applicable when the GPSLCE bit is set in ETH_MAC_CONFIGURATION register.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PACKET_FILTER</name>
          <description>MAC Packet Filter Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>RA</name>
              <description>Receive All
When this bit is set, the MAC Receiver module passes all received packets to the application, irrespective of whether they pass the address filter or not. The result of the SA or DA filtering is updated (pass or fail) in the corresponding bit in the Rx Status Word.
When this bit is reset, the Receiver module passes only those packets to the application that pass the SA or DA address filter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive all is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive all is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VTFE</name>
              <description>VLAN Tag Filter Enable
When this bit is set, the MAC drops the VLAN tagged packets that do not match the VLAN Tag. When this bit is reset, the MAC forwards all packets irrespective of the match status of the VLAN Tag.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN tag filter is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN tag filter is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCF</name>
              <description>Pass Control Packets
These bits control the forwarding of all control packets (including unicast and multicast Pause packets).</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC filters all control packets from reaching the application</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC forwards all control packets except pause packets to the application even if they fail the address filter</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>MAC forwards all control packets to the application even if they fail the address filter</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>MAC forwards the control packets that pass the address filter</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBF</name>
              <description>Disable Broadcast Packets
When this bit is set, the AFM module blocks all incoming broadcast packets. In addition, it overrides all other filter settings.
When this bit is reset, the AFM module passes all received broadcast packets.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enable broadcast packets</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Disable broadcast packets</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PM</name>
              <description>Pass All Multicast
When this bit is set, it indicates that all received packets with a multicast destination address (first bit in the destination address field is '1') are passed. When this bit is reset, filtering of multicast packet depends on HMC bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Pass all multicast is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Pass all multicast is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAIF</name>
              <description>DA Inverse Filtering
When this bit is set, the Address Check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast packets. When this bit is reset, normal filtering of packets is performed.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DA inverse filtering is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DA inverse filtering is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PR</name>
              <description>Promiscuous Mode
When this bit is set, the Address Filtering module passes all incoming packets irrespective of the destination or source address. The SA or DA Filter Fails status bits of the Rx Status Word are always cleared when PR is set.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Promiscuous mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Promiscuous mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_WATCHDOG_TIMEOUT</name>
          <description>Watchdog Timeout Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWE</name>
              <description>Programmable Watchdog Enable
When this bit is set and the ETH_MAC_CONFIGURATION[WD] bit is reset, the WTO field is used as watchdog timeout for a received packet. When this bit is cleared, the watchdog timeout for a received packet is controlled by setting of the ETH_MAC_CONFIGURATION[WD] and ETH_MAC_CONFIGURATION[JE] bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Programmable watchdog is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable watchdog is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WTO</name>
              <description>Watchdog Timeout
When the PWE bit is set and the ETH_MAC_CONFIGURATION[WD] bit is reset, this field is used as watchdog timeout for a received packet. If the length of a received packet exceeds the value of this field, such packet is terminated and declared as an error packet.
Note: When the PWE bit is set, the value in this field should be more than 1,522 (0x5F2). Otherwise, the IEEE 802.3-specified valid tagged packets are declared as error packets and then dropped.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2KB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3KB</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>4KB</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>5KB</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>6KB</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>7KB</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>8KB</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>9KB</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>10KB</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>11KB</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>12KB</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>13KB</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>14KB</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>15KB</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>16383 bytes</description>
                  <value>0xE</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_VLAN_TAG</name>
          <description>VLAN Tag Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>EVLRXS</name>
              <description>Enable VLAN Tag in Rx status
When this bit is set, MAC provides the outer VLAN Tag in the Rx status. When this bit is reset, the MAC does not provide the outer VLAN Tag in Rx status.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN tag in Rx status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN tag in Rx status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EVLS</name>
              <description>Enable VLAN Tag Stripping on Receive
This field indicates the stripping operation on the outer VLAN Tag in received packet.</description>
              <bitRange>[22:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not strip</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Strip if VLAN filter passes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Strip if VLAN filter fails</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Always strip</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DOVLTC</name>
              <description>Disable VLAN Type Check
When this bit is set, the MAC does not check whether the VLAN Tag specified by the ERIVLT bit is of type S-VLAN or C-VLAN.
When this bit is reset, the MAC filters or matches the VLAN Tag specified by the ERIVLT bit only when VLAN Tag type is similar to the one specified by the ERSVLM bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN type check is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN type check is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERSVLM</name>
              <description>Enable Receive S-VLAN Match
When this bit is set, the MAC receiver enables filtering or matching for S-VLAN (Type = 0x88A8) packets. When this bit is reset, the MAC receiver enables filtering or matching for C-VLAN (Type = 0x8100) packets.
The ERIVLT bit determines the VLAN tag position considered for filtering or matching.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive S-VLAN match is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive S-VLAN match is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESVL</name>
              <description>Enable S-VLAN
When this bit is set, the MAC transmitter and receiver consider the S-VLAN packets (Type = 0x88A8) as valid VLAN tagged packets.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>S-VLAN is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>S-VLAN is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VTIM</name>
              <description>VLAN Tag Inverse Match Enable
When this bit is set, this bit enables the VLAN Tag inverse matching. The packets without matching VLAN Tag are marked as matched. When reset, this bit enables the VLAN Tag perfect matching. The packets with matched VLAN Tag are marked as matched.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN tag inverse match is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VLAN tag inverse match is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETV</name>
              <description>Enable 12-Bit VLAN Tag Comparison
When this bit is set, a 12-bit VLAN identifier is used for comparing and filtering instead of the complete 16-bit VLAN tag. Bits[11-0] of VLAN tag are compared with the corresponding field in the received VLAN-tagged packet. Similarly, when enabled, only 12 bits of the VLAN tag in the received packet are used for hash-based VLAN filtering.
When this bit is reset, all 16 bits of the 15th and 16th bytes of the received VLAN packet are used for comparison and VLAN hash filtering.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>12-Bit VLAN tag comparison is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>12-Bit VLAN tag comparison is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VL</name>
              <description>VLAN Tag Identifier for Receive Packets
This field contains the 802.1Q VLAN tag to identify the VLAN packets. This VLAN tag identifier is compared to the 15th and 16th bytes of the packets being received for VLAN packets. The following list describes the bits of this field:
Bits[15-13]: User Priority
Bit 12: Canonical Format Indicator (CFI) or Drop Eligible Indicator (DEI)
Bits[11-0]: VLAN Identifier (VID) field of VLAN tag
If this field ([11-0] if ETV is set) is all zeros, the MAC does not check the 15th and 16th bytes for VLAN tag comparison and declares all packets with Type field value of 0x8100 or 0x88A8 as VLAN packets.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_Q0_TX_FLOW_CTRL</name>
          <description>Flow Control Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PT</name>
              <description>Pause Time
This field holds the value to be used in the Pause Time field in the Tx control packet. If the Pause Time bits are configured to be double-synchronized to the RMII clock domain, consecutive writes to this register should be performed only after at least four clock cycles in the destination clock domain.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZPQ</name>
              <description>Disable Zero-Quanta Pause
When this bit is set, it disables the automatic generation of the zero-quanta Pause packets.
When this bit is reset, normal operation with automatic zero-quanta Pause packet generation is enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Zero-quanta pause packet generation is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Zero-quanta pause packet generation is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLT</name>
              <description>Pause Low Threshold
This field configures the automatic retransmission interval of the Pause packet.
The value should always be less than the Pause Time configured in the PT field. For example, if PT = 0x100 (256 slot times), and PLT = 0x1, a second Pause packet is automatically transmitted at 228 (256-28) slot times after the first Pause packet is transmitted.
The following list provides the threshold values for different values.The slot time is defined as the time taken to transmit 512 bits (64 bytes) on the RMII interface.
This (approximate) computation is based on the packet size (64, 1518, 2000, 9018, 16384, or 32768) + 2 Pause Packet Size + IPG in Slot Times.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Pause time minus 4 slot times (PT - 4 slot times)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Pause time minus 28 slot times (PT - 28 slot times)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Pause time minus 36 slot times (PT - 36 slot times)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Pause time minus 144 slot times (PT - 144 slot times)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Pause time minus 256 slot times (PT - 256 slot times)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Pause time minus 512 slot times (PT - 512 slot times)</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit Flow Control Enable
Full-Duplex Mode:
In the full-duplex mode, when this bit is set, the MAC enables the flow control operation to Tx Pause packets. When this bit is reset, the flow control operation in the MAC is disabled, and the MAC does not transmit any Pause packets.
Half-Duplex Mode:
In the half-duplex mode, when this bit is set, the MAC enables the backpressure operation. When this bit is reset, the backpressure feature is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit flow control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit flow control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FCB_BPA</name>
              <description>Flow Control Busy or Backpressure Activate
This bit initiates a Pause packet in the full-duplex mode and activates the backpressure function in the half-duplex mode if the TFE bit is set.
Full-Duplex Mode:
In the full-duplex mode, this bit should be read as 0x0 before writing to this register. To initiate a Pause packet, the application must set this bit to 0x1. During Control packet transfer, this bit continues to be set to indicate that a packet transmission is in progress. When Pause packet transmission is complete, the MAC resets this bit to 0x0. The user should not write to this register until this bit is cleared.
Half-Duplex Mode:
When this bit is set (and TFE bit is set) in the half-duplex mode, the MAC asserts the backpressure. During backpressure, when the MAC receives a new packet, the transmitter starts sending a JAM pattern resulting in a collision.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Flow control busy or backpressure activate is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flow control busy or backpressure activate is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_RX_FLOW_CTRL</name>
          <description>Receive Flow Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Unicast Pause Packet Detect
A pause packet is processed when it has the unique multicast address specified in the IEEE 802.3 Specification. When this bit is set, the MAC can also detect Pause packets with unicast address of the station. This unicast address should be as specified in ETH_MAC_ADDRESS0_HIGH and ETH_MAC_ADDRESS0_LOW.
When this bit is reset, the MAC only detects Pause packets with unique multicast address.
Note: The MAC does not process a Pause packet if the multicast address is different from the unique multicast address. This is also applicable to the received PFC packet when the Priority Flow Control (PFC) is enabled. The unique multicast address (0x1_80_C2_00_00_01) is as specified in the IEEE 802.1 Qbb-2011 Specification.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unicast pause packet detect disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Unicast pause packet detect enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFE</name>
              <description>Receive Flow Control Enable
When this bit is set and the MAC is operating in full-duplex mode, the MAC decodes the received Pause packet and disables its transmitter for a specified (Pause) time. When this bit is reset or the MAC is operating in half-duplex mode, the decode function of the Pause packet is disabled.
When PFC is enabled, flow control is enabled for PFC packets. The MAC decodes the received PFC packet and disables the Transmit queue, with matching priorities, for a duration of received Pause time.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive flow control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive flow control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_INTERRUPT_STATUS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC7018</resetMask>
          <fields>
            <field>
              <name>MDIOIS</name>
              <description>MDIO Interrupt Status
This bit indicates an interrupt event after the completion of MDIO operation. To reset this bit, the application has to read this bit/Write 1 to this bit when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MDIO interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MDIO interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSTSIS</name>
              <description>Receive Status Interrupt
This bit indicates the status of received packets. This bit is set when the RWT bit is set in the ETH_MAC_RX_TX_STATUS register. This bit is cleared when the corresponding interrupt source bit is read (or corresponding interrupt source bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set) in the ETH_MAC_RX_TX_STATUS register.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSTSIS</name>
              <description>Transmit Status Interrupt
This bit indicates the status of transmitted packets. This bit is set when any of the following bits is set:
- ETH_MAC_RX_TX_STATUS[EXCOL]
- ETH_MAC_RX_TX_STATUS[LCOL]
- ETH_MAC_RX_TX_STATUS[EXDEF]
- ETH_MAC_RX_TX_STATUS[LCARR]
- ETH_MAC_RX_TX_STATUS[NCARR]
- ETH_MAC_RX_TX_STATUS[TJT]</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIS</name>
              <description>Timestamp Interrupt Status
This bit is set when any of the following conditions is true:
- The ETH_MAC_TIMESTAMP_STATUS[TSTRGTERR0] bit is set.
- The ETH_MAC_TIMESTAMP_STATUS[TSTARGT0] bit is set.
- The ETH_MAC_TIMESTAMP_STATUS[TSSOVF] bit is set.
- When drop transmit status is enabled in MTL, this bit is set when the captured transmit timestamp is updated in the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS and ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS registers.
This bit is cleared when the corresponding interrupt source bit is read in the ETH_MAC_TIMESTAMP_STATUS register or the corresponding interrupt source bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PMTIS</name>
              <description>PMT Interrupt Status
This bit is set when a Magic packet or Wake-on-LAN packet is received in the power-down mode (the ETH_MAC_PMT_CONTROL_STATUS[RWKPRCVD] and ETH_MAC_PMT_CONTROL_STATUS[MGKPRCVD] bits). This bit is cleared when corresponding interrupt source bit are cleared because of a Read operation to the ETH_MAC_PMT_CONTROL_STATUS register (or corresponding interrupt source bit of ETH_MAC_PMT_CONTROL_STATUS register is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PMT interrupt status not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT interrupt status active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYIS</name>
              <description>PHY Interrupt
This bit is set when rising edge is detected on the ETH_IRQ input. This bit is cleared when this register is read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PHY interrupt not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PHY interrupt detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_INTERRUPT_ENABLE</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFC7FF8</resetMask>
          <fields>
            <field>
              <name>MDIOIE</name>
              <description>MDIO Interrupt Enable
When this bit is set, it enables the assertion of the interrupt when the ETH_MAC_INTERRUPT_STATUS[MDIOIS] bit is set.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MDIO interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MDIO interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXSTSIE</name>
              <description>Receive Status Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[RXSTSIS] bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive status interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive status interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSTSIE</name>
              <description>Transmit Status Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[TXSTSIS] bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp status interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp status interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIE</name>
              <description>Timestamp Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[TSIS] bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PMTIE</name>
              <description>PMT Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[PMTIS] bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PMT interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYIE</name>
              <description>PHY Interrupt Enable
When this bit is set, it enables the assertion of the interrupt signal because of the setting of the ETH_MAC_INTERRUPT_STATUS[PHYIS] bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PHY interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PHY interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_RX_TX_STATUS</name>
          <description>Receive Transmit Status Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RWT</name>
              <description>Receive Watchdog Timeout
This bit is set when a packet with length greater than 2,048 bytes is received (10, 240 bytes when Jumbo Packet mode is enabled) and the ETH_MAC_CONFIGURATION[WD] bit is reset. This bit is also set when a packet with length greater than 16,383 bytes is received and the ETH_MAC_CONFIGURATION[WD] bit is set.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No receive watchdog timeout</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive watchdog timed out</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXCOL</name>
              <description>Excessive Collisions
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the transmission aborted after 16 successive collisions while attempting to transmit the current packet. If the DR bit is set in the ETH_MAC_CONFIGURATION register, this bit is set after the first collision and the packet transmission is aborted.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No collision</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Excessive collision is sensed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCOL</name>
              <description>Late Collision
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the packet transmission aborted because a collision occurred after the collision window (64 bytes including preamble).
This bit is not valid if the Underflow error occurs.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No collision</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Late collision is sensed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXDEF</name>
              <description>Excessive Deferral
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set and the DC bit is set in the ETH_MAC_CONFIGURATION register, this bit indicates that the transmission ended because of excessive deferral of over 24,288-bit times (155,680 when Jumbo packet is enabled).
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No excessive deferral</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Excessive deferral</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCARR</name>
              <description>Loss of Carrier
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the loss of carrier occurred during packet transmission, that is, the ETH_CRS_DV signal was inactive for one or more transmission clock periods during packet transmission. This bit is valid only for packets transmitted without collision.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Carrier is present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Loss of carrier</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NCARR</name>
              <description>No Carrier
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set, this bit indicates that the carrier signal from the PHY is not present at the end of preamble transmission.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Carrier is present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No carrier</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TJT</name>
              <description>Transmit Jabber Timeout
This bit indicates that the Transmit Jabber Timer expired which happens when the packet size exceeds 2,048 bytes (10,240 bytes when the Jumbo packet is enabled) and JD bit is reset in the ETH_MAC_CONFIGURATION register. This bit is set when the packet size exceeds 16,383 bytes and the JD bit is set in the ETH_MAC_CONFIGURATION register.
Access restriction applies. Clears on read (or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmit jabber timeout</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit jabber timeout occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PMT_CONTROL_STATUS</name>
          <description>PMT Control and Status Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RWKFILTRST</name>
              <description>Remote Wake-Up Packet Filter Register Pointer Reset
When this bit is set, the remote wake-up packet filter register pointer is reset to 0x0. It is automatically cleared after 1 clock cycle.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet filter register pointer is not reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet filter register pointer is reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKPTR</name>
              <description>Remote Wake-up FIFO Pointer
This field gives the current value of the Remote Wake-up Packet Filter register pointer.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RWKPFE</name>
              <description>Remote Wake-up Packet Forwarding Enable
When this bit is set along with RWKPKTEN, the MAC receiver drops all received frames until it receives the expected wake-up frame. All frames after that event including the received wake-up frame are forwarded to application. This bit is then self-cleared on receiving the wake-up packet. The application can also clear this bit before the expected wake-up frame is received. In such cases, the MAC reverts to the default behavior where packets received are forwarded to the application. This bit must only be set when RWKPKTEN is set high and PWRDWN is set low. The setting of this bit has no effect when PWRDWN is set high.
Note: If Magic Packet Enable and Wake-Up Frame Enable are both set along with setting of this bit and Magic Packet is received prior to wake-up frame, this bit is self-cleared on receiving Magic Packet, the received Magic packet is dropped, and all frames after received Magic Packet are forwarded to application.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet forwarding is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet forwarding is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GLBLUCAST</name>
              <description>Global Unicast
When this bit set, any unicast packet filtered by the MAC (DAF) address recognition is detected as a remote wake-up packet.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Global unicast is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Global unicast is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKPRCVD</name>
              <description>Remote Wake-Up Packet Received
When this bit is set, it indicates that the power management event is generated because of the reception of a remote wake-up packet. This bit is cleared when this register is read.
Access restriction applies. Clears on read or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set. Self-set to 1 on internal event.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet is received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet is received</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGKPRCVD</name>
              <description>Magic Packet Received
When this bit is set, it indicates that the power management event is generated because of the reception of a magic packet. This bit is cleared when this register is read.
Access restriction applies. Clears on read or write of 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set. Self-set to 1 on internal event.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No magic packet is received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Magic packet is received</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKPKTEN</name>
              <description>Remote Wake-Up Packet Enable
When this bit is set, a power management event is generated when the MAC receives a remote wake-up packet.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Remote wake-up packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Remote wake-up packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGKPKTEN</name>
              <description>Magic Packet Enable
When this bit is set, a power management event is generated when the MAC receives a magic packet.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Magic packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Magic packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PWRDWN</name>
              <description>Power Down
When this bit is set, the MAC receiver drops all received packets until it receives the expected magic packet or remote wake-up packet. This bit is then self-cleared and the power-down mode is disabled. The software can clear this bit before the expected magic packet or remote wake-up packet is received. The packets received by the MAC after this bit is cleared are forwarded to the application. This bit must only be set when the MGKPKTEN, GLBLUCAST, or RWKPKTEN bit is set high.
Note: The user can gate-off the CLK_CSR during power-down mode. However, when the CLK_CSR is gated-off, the user cannot perform any read or write operations on this register. Therefore, software cannot clear this bit.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power down is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power down is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_BYTE_MASK</name>
          <description>Remote Wakeup Filter Byte Mask Register</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER_BYTE_MASK</name>
              <description>Filter0 to Filter3 32-bit Mask
This field defines the bytes of the packet that are examined by the corresponding filter (0 to 3) to determine whether or not a packet is a wake-up packet. Bit 31 must be
zero. Bits [30-0] are the byte mask.
 Each bit in this mask corresponds to one byte in the detected packet. If the bit is 1, the corresponding byte is taken into the CRC16 calculation.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_COMMAND</name>
          <description>Remote Wakeup Filter Command Register</description>
          <alternateRegister>ETH_RWK_FILTER_BYTE_MASK</alternateRegister>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER3_COMMAND</name>
              <description>Filter3 Command
The 4-bit filter command controls the filter operation.
Bit 27 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 26 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 26, along with Bit 25, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 25 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 24 is the enable for filter. If Bit 24 is not set, filter is disabled.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2_COMMAND</name>
              <description>Filter2 Command
The 4-bit filter command controls the filter operation.
Bit 19 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 18 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 18, along with Bit 17, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 17 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 16 is the enable for filter. If Bit 16 is not set, filter is disabled.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1_COMMAND</name>
              <description>Filter1 Command
The 4-bit filter command controls the filter operation.
Bit 11 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 10 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 10, along with Bit 9, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 9 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 8 is the enable for filter. If Bit 8 is not set, filter is disabled.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER0_COMMAND</name>
              <description>Filter0 Command
The 4-bit filter command controls the filter operation.
Bit 3 specifies the address type, defining the destination address type of the pattern. When the bit is set, the pattern applies to only multicast packets; when the bit is reset, the pattern applies only to unicast packet.
Bit 2 (Inverse Mode), when set, reverses the logic of the CRC16 hash function signal, to reject a packet with matching CRC_16 value.
Bit 2, along with Bit 1, allows a MAC to reject a subset of remote wake-up packets by creating filter logic such as Pattern 1 AND NOT Pattern 2.
Bit 1 (And_Previous) implements the Boolean logic. When set, the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two, three, or four filters. This depends on the number of filters that have the And_Previous bit set.
Bit 0 is the enable for filter. If Bit 0 is not set, filter is disabled.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_OFFSET</name>
          <description>Remote Wakeup Filter Offset Register</description>
          <alternateRegister>ETH_RWK_FILTER_BYTE_MASK</alternateRegister>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER3_OFFSET</name>
              <description>Filter3 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2_OFFSET</name>
              <description>Filter2 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1_OFFSET</name>
              <description>Filter1 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER0_OFFSET</name>
              <description>Filter0 Offset
This filter offset defines the offset (within the packet) from which the filter examines the packets.
This 8-bit pattern-offset is the offset for the filter first byte to be examined.
The minimum allowed offset is 12, which refers to the 13th byte of the packet.
The offset value 0 refers to the first byte of the packet.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_RWK_FILTER_CRC</name>
          <description>Remote Wakeup Filter CRC-16 Register</description>
          <alternateRegister>ETH_RWK_FILTER_BYTE_MASK</alternateRegister>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER1_3_CRC</name>
              <description>Filter1 and Filter3 CRC-16
This field contains the CRC_16 value calculated from the pattern and also the byte mask programmed to the wake-up filter register block.
The 16-bit CRC calculation uses the following polynomial:
G(x) = x^16 + x^15 + x^2 + 1
Each mask, used in the hash function calculation, is compared with a 16-bit value associated with that mask. Each filter has the following:
- 32-bit mask: Each bit in this mask corresponds to one byte in the detected packet. If the bit is 1, the corresponding byte is taken into the CRC-16 calculation.
- 8-bit offset pointer: Specifies the byte to start the CRC-16 computation.
The pointer and the mask are used together to locate the bytes to be used in the CRC-16 calculations.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER0_2_CRC</name>
              <description>Filter0 and Filter2 CRC-16
This field contains the CRC_16 value calculated from the pattern and also the byte mask programmed to the wake-up filter register block.
The 16-bit CRC calculation uses the following polynomial:
G(x) = x^16 + x^15 + x^2 + 1
Each mask, used in the hash function calculation, is compared with a 16-bit value associated with that mask. Each filter has the following:
- 32-bit mask: Each bit in this mask corresponds to one byte in the detected packet. If the bit is 1, the corresponding byte is taken into the CRC-16 calculation.
- 8-bit offset pointer: Specifies the byte to start the CRC-16 computation.
The pointer and the mask are used together to locate the bytes to be used in the CRC-16 calculations.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_VERSION</name>
          <description>Module Version Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00001051</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USERVER</name>
              <description>User-defined version</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SNPSVER</name>
              <description>Vendor-defined version</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_DEBUG</name>
          <description>Debug Register</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFCSTS</name>
              <description>Reserved</description>
              <bitRange>[18:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TPESTS</name>
              <description>MAC RMII Transmit Protocol Engine Status
When this bit is set, it indicates that the MAC RMII transmit protocol engine is actively transmitting data, and it is not in the Idle state.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC RMII transmit protocol engine status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC RMII transmit protocol engine status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFCFCSTS</name>
              <description>Reserved</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RPESTS</name>
              <description>MAC RMII Receive Protocol Engine Status
When this bit is set, it indicates that the MAC RMII receive protocol engine is actively receiving data, and it is not in the Idle state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC RMII receive protocol engine status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC RMII receive protocol engine status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE0</name>
          <description>ETH Hardware Feature Register 0</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x400152E5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACTPHYSEL</name>
              <description>Active PHY Selected</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>RMII</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAVLANINS</name>
              <description>Source Address or VLAN Insertion Enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Source address or VLAN insertion disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSTSSEL</name>
              <description>Timestamp System Time Source</description>
              <bitRange>[26:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Internal</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MACADR64SEL</name>
              <description>MAC Addresses 64-127 Selected</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC addresses 64-127 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MACADR32SEL</name>
              <description>MAC Addresses 32-63 Selected</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC addresses 32-63 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDMACADRSEL</name>
              <description>MAC Addresses 1-31 Selected</description>
              <bitRange>[22:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC addresses 1-31 disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXCOESEL</name>
              <description>Receive Checksum Offload Enabled</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive checksum offload enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXCOESEL</name>
              <description>Transmit Checksum Offload Enabled</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit checksum offload enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EEESEL</name>
              <description>Energy Efficient Ethernet Enabled</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Energy efficient ethernet disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSEL</name>
              <description>IEEE 1588-2008 Timestamp Enabled</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IEEE 1588-2008 timestamp enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARPOFFSEL</name>
              <description>ARP Offload Enabled</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ARP offload disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MMCSEL</name>
              <description>RMON Module Enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RMON module disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MGKSEL</name>
              <description>PMT Magic Packet Enable</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT magic packet enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWKSEL</name>
              <description>PMT Remote Wake-up Packet Enable</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PMT remote wake-up packet enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMASEL</name>
              <description>SMA (MDIO) Interface</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SMA (MDIO) interface selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VLHASH</name>
              <description>VLAN Hash Filter Selected</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VLAN hash filter not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCSSEL</name>
              <description>PCS Registers (TBI, SGMII, or RTBI PHY interface)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No PCS registers (TBI, SGMII, or RTBI PHY interface)</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HDSEL</name>
              <description>Half-duplex Support</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Half-duplex supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GMIISEL</name>
              <description>1000 Mbps Support</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No 1000 Mbps supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MIISEL</name>
              <description>10 or 100 Mbps Support</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>10 or 100 Mbps supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE1</name>
          <description>ETH Hardware Feature Register 1</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000C0124</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>L3L4FNUM</name>
              <description>Total number of L3 or L4 Filters</description>
              <bitRange>[30:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No L3 or L4 filter</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HASHTBLSZ</name>
              <description>Hash Table Size</description>
              <bitRange>[25:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No hash table</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POUOST</name>
              <description>One Step for PTP over UDP/IP Enable</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>One step for PTP over UDP/IP is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAVSEL</name>
              <description>Rx Side Only AV Enable</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx side only AV is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVSEL</name>
              <description>AV Enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AV fature is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBGMEMA</name>
              <description>DMA Debug Registers Enable</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA debug registers enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSOEN</name>
              <description>TCP Segmentation Offload Enable</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TCP segmentation offload is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPHEN</name>
              <description>Split Header Enable</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Split header is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCBEN</name>
              <description>DCB Enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DCB is not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR64</name>
              <description>Address Width.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>32</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADVTHWORD</name>
              <description>IEEE 1588 High Word Register Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IEEE 1588 high word register is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PTOEN</name>
              <description>PTP Offload Enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PTP offload is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSTEN</name>
              <description>One-Step Timestamping Enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>One-step timestamping is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXFIFOSIZE</name>
              <description>MTL Transmit FIFO Size</description>
              <bitRange>[10:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2048 bytes</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPRAM</name>
              <description>Single Port RAM Enable</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Single port RAM is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIFOSIZE</name>
              <description>MTL Receive FIFO Size</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2048 bytes</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE2</name>
          <description>ETH Hardware Feature Register 2</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUXSNAPNUM</name>
              <description>Number of Auxiliary Snapshot Inputs</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No auxiliary input</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PPSOUTNUM</name>
              <description>Number of PPS Outputs</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No PPS output</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXCHCNT</name>
              <description>Number of DMA Transmit Channels</description>
              <bitRange>[21:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 MTL Tx channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXCHCNT</name>
              <description>Number of DMA Receive Channels</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 MTL Rx channel</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXQCNT</name>
              <description>Number of MTL Transmit Queues</description>
              <bitRange>[9:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 MTL Tx Queue</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXQCNT</name>
              <description>Number of MTL Receive Queues</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 MTL Rx Queue</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_HW_FEATURE3</name>
          <description>ETH Hardware Feature Register 3</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ASP</name>
              <description>Automotive Safety Package</description>
              <bitRange>[29:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No safety features selected</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSSEL</name>
              <description>Time Based Scheduling Enable</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Time based scheduling disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FPESEL</name>
              <description>Frame Preemption Enable</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Frame preemption disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESTWID</name>
              <description>Width of the Time Interval field in the Gate Control List</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Width not configured</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESTDEP</name>
              <description>Depth of the Gate Control List</description>
              <bitRange>[19:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No depth configured</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ESTSEL</name>
              <description>Enhancements to Scheduling Traffic Enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enhancements to scheduling traffic disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRPES</name>
              <description>Flexible Receive Parser Table Entries size</description>
              <bitRange>[14:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 entries</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRPBS</name>
              <description>Flexible Receive Parser Buffer size</description>
              <bitRange>[12:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64 bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRPSEL</name>
              <description>Flexible Receive Parser Select</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Flexible receive parser disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDUPSEL</name>
              <description>Broadcast/Multicast Packet Duplication</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Broadcast/multicast packet duplication disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DVLAN</name>
              <description>Double VLAN Tag Processing Select</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Double VLAN tag processing disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBTISEL</name>
              <description>Queue/Channel based VLAN tag insertion on Tx Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Queue/Channel based VLAN tag insertion on Tx disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NRVF</name>
              <description>Number of Extended VLAN Tag Filters Enable</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No extended Rx VLAN filters</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_MDIO_ADDRESS</name>
          <description>MDIO Address Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PSE</name>
              <description>Preamble Suppression Enable
When this bit is set, the MDIO suppresses the 32-bit preamble and transmits MDIO frames with only 1 preamble bit. When this bit is 0, the MDIO frame always has 32 bits of preamble as definedin the IEEE specifications.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Preamble suppression disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Preamble suppression enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BTB</name>
              <description>Back to Back transactions
When this bit is set and the NTC has value greater than 0, then the MAC informs the completion of a read or write command at the end of frame transfer (before the trailing clocks are transmitted). The software can thus initiate the next command which is executed immediately irrespective of the number trailing clocks generated for the previous frame. When this bit is reset, then the read/write command completion (GB iscleared) only after the trailing clocks are generated. In this mode, it is ensured that the NTC is always generated after each frame. This bit must not be set when NTC=0.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Back to back transactions disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Back to back transactions enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PA</name>
              <description>Physical Layer Address
This field indicates which Clause 22 PHY devices (out of 32 devices) the MAC is accessing. This field indicates which Clause 45 capable PHYs (out of 32 PHYs) the MAC is accessing.</description>
              <bitRange>[25:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDA</name>
              <description>Register/Device Address
These bits select the PHY register in selected Clause 22 PHY device. These bits select the Device (MMD) in selected Clause 45 capable PHY.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NTC</name>
              <description>Number of Trailing Clocks
This field controls the number of trailing clock cycles generated on ETH_MDC after the end of transmission of MDIO frame. The valid values can be from 0 to 7. Programming the value to 0x3 indicates that there are additional three clock cycles on the ETH_MDC line after the end of MDIO frame transfer.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CR</name>
              <description>CSR Clock (CLK_CSR) Range
The CLK_CSR range selection determines the frequency of the MDC clock (ETH_MDC) according to the CLK_CSR frequency:
The suggested range of CLK_CSR frequency applicable for each value (when Bit 11 = 0) ensures that the ETH_MDC is approximately between 1.0 MHz to 2.5 MHz freqency range.
When Bit 11 is set, the user can achieve a higher frequency of the ETH_MDC than the frequency limit of 2.5 MHz (specified in the IEEE 802.3 Specification) and program a clock divider of lower value. For example, when CLK_CSR is of 100 MHz frequency and the user programs the CR field to 0xA, the resultant ETH_MDC is of 12.5 MHz which is above the range specified in IEEE 802.3 Specification. Program the following values only if the interfacing chips support faster MDC clocks:</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CLK_CSR = 60-100 MHz; ETH_MDC = CLK_CSR / 42</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLK_CSR = 100-150 MHz; ETH_MDC = CLK_CSR / 62</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CLK_CSR = 20-35 MHz; ETH_MDC = CLK_CSR / 16</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CLK_CSR = 35-60 MHz; ETH_MDC = CLK_CSR / 26</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>CLK_CSR = 150-250 MHz; ETH_MDC = CLK_CSR / 102</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>CLK_CSR = 250-300 MHz; ETH_MDC = CLK_CSR / 124</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>CLK_CSR = 300-500 MHz; ETH_MDC = CLK_CSR / 204</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>CLK_CSR = 500-800 MHz; ETH_MDC = CLK_CSR / 324</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>CLK_CSR / 4</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>CLK_CSR / 6</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>CLK_CSR / 8</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>CLK_CSR / 10</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>CLK_CSR / 12</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>CLK_CSR / 14</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>CLK_CSR / 16</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>CLK_CSR / 18</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SKAP</name>
              <description>Skip Address Packet
When this bit is set, the MDIO does not send the address packets before read, write, or post-read increment address packets. This bit is valid only when the C45E bit is set.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Skip address packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Skip address packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GOC_1</name>
              <description>Operation Command 1
This is the higher bit of the operation command to the PHY. GOC_1 and GOC_O are encoded as follows:
0x0: Reserved
0x1: Write
0x2: Post read increment address for Clause 45 PHY
0x3: Read
GOC_1 is encoded as follows:
0x0: Operation command 1 is disabled
0x1: Operation command 1 is enabled</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GOC_0</name>
              <description>Operation Command 0
This is the lower bit of the operation command to the PHY. When in MDIO mode (MDIO master) this bit along with GOC_1 determines the operation to be performed to the PHY.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Operation command 0 is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Operation command 0 is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>C45E</name>
              <description>Clause 45 PHY Enable
When this bit is set, Clause 45 capable PHY is connected to MDIO. When this bit is reset, Clause 22 capable PHY is connected to MDIO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clause 45 PHY is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clause 45 PHY is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GB</name>
              <description>RMII Busy
The application sets this bit to instruct the MDIO to initiate a Read or Write access to the MDIO slave. The MAC clears this bit after the MDIO frame transfer is completed. Hence the software must not write or change any of the fields in ETH_MAC_MDIO_ADDRESS and ETH_MAC_MDIO_DATA registers as long as this bit is set.
For write transfers, the application must first write 16-bit data in the ETH_MAC_MDIO_DATA[GD] field (and also ETH_MAC_MDIO_DATA[RA] field when the C45E bit is set) before setting this bit. When the C45E bit is set, it should also write into the ETH_MAC_MDIO_DATA[RA] field before initiating a read transfer. When a read transfer is completed (GB=0), the data read from the PHY register is valid in the ETH_MAC_MDIO_DATA[GD] field.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RMII busy is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RMII busy is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_MDIO_DATA</name>
          <description>MDIO Data Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RA</name>
              <description>Register Address
This field is valid only when the ETH_MAC_MDIO_ADDRESS[C45E] bit is set. It contains the Register Address in the PHY to which the MDIO frame is intended for.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GD</name>
              <description>RMII Data
This field contains the 16-bit data value read from the PHY after a Management Read operation or the 16-bit data value to be written to the PHY before a Management Write operation.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_ARP_ADDRESS</name>
          <description>ARP Address Register</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARPPA</name>
              <description>ARP Protocol Address
This field contains the IPv4 Destination Address of the MAC. This address is used for perfect match with the Protocol Address of Target field in the received ARP packet.
This field is available only when the Enable IPv4 ARP Offload option is selected.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_CSR_SW_CTRL</name>
          <description>CSR Software Control Register</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEEN</name>
              <description>Slave Error Response Enable
When this bit is set, the MAC responds with Slave Error for accesses to reserved registers in CSR space.
When this bit is reset, the MAC responds with OKAY response to any register accessed from CSR space.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave error response is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave error response is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RCWE</name>
              <description>Register Clear on Write 1 Enable
When this bit is set, the access mode of some register fields changes to Clear on Write 1, the application needs to set that respective bit to 1 to clear it.
When this bit is reset, the access mode of these register fields remain as Clear on Read.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Register clear on write 1 is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Register clear on write 1 is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_ADDRESS0_HIGH</name>
          <description>MAC Address 0 High Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AE</name>
              <description>Address Enable
This bit is always set to 1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ivalid. This bit must be always set to 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>This bit is always set to 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRHI</name>
              <description>MAC Address0[47-32]
This field contains the upper 16 bits [47-32] of the first 6-byte MAC address. The MAC uses this field for filtering the received packets and inserting the MAC address in the Transmit Flow Control (Pause) Packets.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_ADDRESS0_LOW</name>
          <description>MAC Address 0 Low Register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRLO</name>
              <description>MAC Address0[31-0]
This field contains the lower 32 bits of the first 6-byte MAC address. The MAC uses this field for filtering the received packets and inserting the MAC address in the Transmit Flow Control (Pause) Packets.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_CONTROL</name>
          <description>Timestamp Control Register</description>
          <addressOffset>0xB00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AV8021ASMEN</name>
              <description>AV 802.1AS Mode Enable
When this bit is set, the MAC processes only untagged PTP over Ethernet packets for providing PTP status and capturing timestamp snapshots, that is, IEEE 802.1AS mode of operation.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AV 802.1AS mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AV 802.1AS mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXTSSTSM</name>
              <description>Transmit Timestamp Status Mode
When this bit is set, the MAC overwrites the earlier transmit timestamp status even if it is not read by the software. The MAC indicates this by setting the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS[TXTSSMIS] bit.
When this bit is reset, the MAC ignores the timestamp status of current packet if the timestamp status of previous packet is not read by the software. The MAC indicates this by setting the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS[TXTSSMIS] bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit timestamp status mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit timestamp status mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSENMACADDR</name>
              <description>Enable MAC Address for PTP Packet Filtering
When this bit is set, the DA MAC address (that matches ETH_MAC_ADDRESS0_HIGH[ADDRHI] and ETH_MAC_ADDRESS0_LOW[ADDRLO]) is used to filter the PTP packets when PTP is directly sent over Ethernet.
When this bit is set, received PTP packets with DA containing a special multicast or unicast address that matches the one programmed in the ETH_MAC_ADDRESS0_HIGH and ETH_MAC_ADDRESS0_LOW registers are considered for processing, when PTP is directly sent over Ethernet.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC address for PTP packet filtering is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC address for PTP packet filtering is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SNAPTYPSEL</name>
              <description>Select PTP packets for Taking Snapshots
This field, along with the TSMSTRENA and TSEVNTENA bits, decide the set of PTP packet types for which snapshot needs to be taken. The encoding is as follows:
- SNAPTYPSEL = 0x0; TSMSTRENA = X; TSEVNTENA = 0x0:
 SYNC, Follow_Up, Delay_Req, Delay_Resp
- SNAPTYPSEL = 0x0; TSMSTRENA = 0x0; TSEVNTENA = 0x1:
 SYNC
- SNAPTYPSEL = 0x0; TSMSTRENA = 0x1; TSEVNTENA = 0x1:
 Delay_Req
- SNAPTYPSEL = 0x1; TSMSTRENA = X; TSEVNTENA = 0x0:
 SYNC, Follow_Up, Delay_Req, Delay_Resp, Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up
- SNAPTYPSEL = 0x1; TSMSTRENA = 0x0; TSEVNTENA = 0x1:
 SYNC, Pdelay_Req, Pdelay_Resp
- SNAPTYPSEL = 0x1; TSMSTRENA = 0x1; TSEVNTENA = 0x1:
 Delay_Req, Pdelay_Req, Pdelay_Resp
- SNAPTYPSEL = 0x2; TSMSTRENA = X; TSEVNTENA = X:
 SYNC, Delay_Req
- SNAPTYPSEL = 0x3; TSMSTRENA = X; TSEVNTENA = X:
 Pdelay_Req, Pdelay_Resp
Note: X means 'don't care'.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TSMSTRENA</name>
              <description>Enable Snapshot for Messages Relevant to Master
When this bit is set, the snapshot is taken only for the messages that are relevant to the master node. Otherwise, the snapshot is taken for the messages relevant to the slave node.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Snapshot for messages relevant to master is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Snapshot for messages relevant to master is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSEVNTENA</name>
              <description>Enable Timestamp Snapshot for Event Messages
When this bit is set, the timestamp snapshot is taken only for event messages (SYNC, Delay_Req, Pdelay_Req, or Pdelay_Resp). When this bit is reset, the snapshot is taken for all messages except Announce, Management, and Signaling.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp snapshot for event messages is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp snapshot for event messages is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIPV4ENA</name>
              <description>Enable Processing of PTP Packets Sent over IPv4-UDP
When this bit is set, the MAC receiver processes the PTP packets encapsulated in IPv4-UDP packets. When this bit is reset, the MAC ignores the PTP transported over IPv4-UDP packets. This bit is set by default.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Processing of PTP packets sent over IPv4-UDP is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Processing of PTP packets sent over IPv4-UDP is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIPV6ENA</name>
              <description>Enable Processing of PTP Packets Sent over IPv6-UDP
When this bit is set, the MAC receiver processes the PTP packets encapsulated in IPv6-UDP packets. When this bit is clear, the MAC ignores the PTP transported over IPv6-UDP packets.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Processing of PTP packets sent over IPv6-UDP is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Processing of PTP packets sent over IPv6-UDP is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIPENA</name>
              <description>Enable Processing of PTP over Ethernet Packets
When this bit is set, the MAC receiver processes the PTP packets encapsulated directly in the Ethernet packets. When this bit is reset, the MAC ignores the PTP over Ethernet packets.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Processing of PTP over Ethernet packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Processing of PTP over Ethernet packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSVER2ENA</name>
              <description>Enable PTP Packet Processing for Version 2 Format
When this bit is set, the IEEE 1588 version 2 format is used to process the PTP packets. When this bit is reset, the IEEE 1588 version 1 format is used to process the PTP packets.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PTP packet processing for version 2 format is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PTP packet processing for version 2 format is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSCTRLSSR</name>
              <description>Timestamp Digital or Binary Rollover Control
When this bit is set, the ETH_MAC_SYSTEM_TIME_NANOSECONDS register rolls over after 0x3B9A_C9FF value (that is, 1 nanosecond accuracy) and increments the ETH_MAC_SYSTEM_TIME_SECONDS register. When this bit is reset, the rollover value of the ETH_MAC_SYSTEM_TIME_NANOSECONDS register is 0x7FFF_FFFF. The sub-second increment must be programmed correctly depending on the CLK_PTP frequency and the value of this bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp digital or binary rollover control is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp digital or binary rollover control is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSENALL</name>
              <description>Enable Timestamp for All Packets
When this bit is set, the timestamp snapshot is enabled for all packets received by the MAC.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp for all packets disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp for all packets enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSADDREG</name>
              <description>Update the ETH_MAC_TIMESTAMP_ADDEND register
When this bit is set, the content of the ETH_MAC_TIMESTAMP_ADDEND register is updated in the PTP block for fine correction. This bit is cleared when the update is complete. This bit should be zero before it is set.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Addend register is not updated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Addend register is updated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSTRIG</name>
              <description>Enable Timestamp Interrupt Trigger
When this bit is set, the timestamp interrupt is generated when the System Time becomes greater than the value written in the Target Time register. This bit is reset after the Timestamp Trigger Interrupt is generated.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp interrupt trigger is not enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp interrupt trigger is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSUPDT</name>
              <description>Update Timestamp
When this bit is set, the system time is updated (added or subtracted) with the value specified in ETH_MAC_SYSTEM_TIME_SECONDS_UPDATE and ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE registers.
This bit should be zero before updating it. This bit is reset when the update is complete in hardware.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp is not updated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp is updated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSINIT</name>
              <description>Initialize Timestamp
When this bit is set, the system time is initialized (overwritten) with the value specified in the ETH_MAC_SYSTEM_TIME_SECONDS_UPDATE and ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE registers.
This bit should be zero before it is updated. This bit is reset when the initialization is complete. Only the ETH_MAC_SYSTEM_TIME_SECONDS register can be initialized.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp is not initialized</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp is initialized</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSCFUPDT</name>
              <description>Fine or Coarse Timestamp Update
When this bit is set, the Fine method is used to update system timestamp. When this bit is reset, Coarse method is used to update the system timestamp.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Coarse method is used to update system timestamp</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fine method is used to update system timestamp</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSENA</name>
              <description>Enable Timestamp
When this bit is set, the timestamp is added for Transmit and Receive packets. When disabled, timestamp is not added for transmit and receive packets and the Timestamp Generator is also suspended. The user needs to initialize the Timestamp (system time) after enabling this mode.
On the Receive side, the MAC processes the 1588 packets only if this bit is set.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SUB_SECOND_INCREMENT</name>
          <description>Sub-second Increment Register</description>
          <addressOffset>0xB04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>SSINC</name>
              <description>Sub-second Increment Value
The value programmed in this field is accumulated every clock cycle (of CLK_PTP) with the contents of the ETH_MAC_SYSTEM_TIME_NANOSECONDS register. For example, when the PTP clock is 50 MHz (period is 20 ns), the user should program 20 (0x14) when the ETH_MAC_SYSTEM_TIME_NANOSECONDS register has an accuracy of 1 ns (the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is set). When TSCTRLSSR is cleard, the ETH_MAC_SYSTEM_TIME_NANOSECONDS register has a resolution of ~0.465 ns. In this case, the user should program a value of 43 (0x2B) which is derived by 20 ns/0.465.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_SECONDS</name>
          <description>System Time Seconds Register</description>
          <addressOffset>0xB08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Second
The value in this field indicates the current value in seconds of the System Time maintained by the MAC.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_NANOSECONDS</name>
          <description>System Time Nanoseconds Register</description>
          <addressOffset>0xB0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
The value in this field has the sub-second representation of time, with an accuracy of 0.46 ns. When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is set, each bit represents 1 ns. The maximum value is 0x3B9A_C9FF after which it rolls-over to zero.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_SECONDS_UPDATE</name>
          <description>System Time Seconds Update Register</description>
          <addressOffset>0xB10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Seconds
The value in this field is the seconds part of the update.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is reset, this field must be programmed with the seconds part of the update value.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is set, this field must be programmed with the complement of the seconds part of the update value.
For example, if 2.000000001 seconds need to be subtracted from the system time, the TSS field must be 0xFFFF_FFFE (that is, 2^32 - 2).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE</name>
          <description>System Time Nanoseconds Update Register</description>
          <addressOffset>0xB14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDSUB</name>
              <description>Add or Subtract Time
When this bit is set, the time value is subtracted with the contents of the update register. When this bit is reset, the time value is added with the contents of the update register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Add time</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Subtract time</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
The value in this field is the sub-seconds part of the update.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is reset, this field must be programmed with the sub-seconds part of the update value, with an accuracy based on the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit.
When ETH_MAC_SYSTEM_TIME_NANOSECONDS_UPDATE[ADDSUB] is set, this field must be programmed with the complement of the sub-seconds part of the update value as described below.
When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit set, the programmed value must be 10^9 - &lt;sub-second value&gt;. When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit reset, the programmed value must be 2^31 - &lt;sub-second_value&gt;.
When the TSCTRLSSR bit is reset in the ETH_MAC_TIMESTAMP_CONTROL register, each bit represents an accuracy of 0.46 ns. When the TSCTRLSSR bit is set in the ETH_MAC_TIMESTAMP_CONTROL register, each bit represents 1 ns and the programmed value should not exceed 0x3B9A_C9FF.
For example, if 2.000000001 seconds need to be subtracted from the system time, then the TSSS field must be 0x7FFF_FFFF (that is, 2^31 - 1), when the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit reset and 0x3B9A_C9FF (that is, 10^9 - 1), when the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit set.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_ADDEND</name>
          <description>Timestamp Addend Register</description>
          <addressOffset>0xB18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSAR</name>
              <description>Timestamp Addend Register
This field indicates the 32-bit time value to be added to the Accumulator register to achieve time synchronization.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_STATUS</name>
          <description>Timestamp Status Register</description>
          <addressOffset>0xB20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFB</resetMask>
          <fields>
            <field>
              <name>TXTSSIS</name>
              <description>Tx Timestamp Status Interrupt Status
When drop transmit status is enabled in MTL, this bit is set when the captured transmit timestamp is updated in the ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS and ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS registers.
This bit is cleared when the ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS register is read (or write to ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS register when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx timestamp status interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx timestamp status interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSTRGTERR0</name>
              <description>Timestamp Target Time Error
This bit is set when the latest target time programmed in the ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers elapses.
Access restriction applies. Clears on read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp target time error status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp target time error status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSTARGT0</name>
              <description>Timestamp Target Time Reached
When set, this bit indicates that the value of system time is greater than or equal to the value specified in the ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers.
Access restriction applies. Clears on read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp target time reached status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp target time reached status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSOVF</name>
              <description>Timestamp Seconds Overflow
When this bit is set, it indicates that the ETH_MAC_SYSTEM_TIME_SECONDS[TSS] value has overflowed beyond 0xFFFF_FFFF.
Access restriction applies. Clears on read (or this bit is written to 1 when the ETH_MAC_CSR_SW_CTRL[RCWE] bit is set). Self-set to 1 on internal event.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Timestamp seconds overflow status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Timestamp seconds overflow status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TX_TIMESTAMP_STATUS_NANOSECONDS</name>
          <description>Transmit Timestamp Status Nanoseconds Register</description>
          <addressOffset>0xB30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTSSMIS</name>
              <description>Transmit Timestamp Status Missed
When this bit is set, it indicates one of the following:
The timestamp of the current packet is ignored if the ETH_MAC_TIMESTAMP_CONTROL[TXTSSTSM] bit is reset
The timestamp of the previous packet is overwritten with timestamp of the current packet if the ETH_MAC_TIMESTAMP_CONTROL[TXTSSTSM] bit is set.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit timestamp status missed status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit timestamp status missed status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXTSSLO</name>
              <description>Transmit Timestamp Status Low
This field contains the 31 bits of the Nanoseconds field of the Transmit packet's captured timestamp.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TX_TIMESTAMP_STATUS_SECONDS</name>
          <description>Transmit Timestamp Status Seconds Register</description>
          <addressOffset>0xB34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTSSHI</name>
              <description>Transmit Timestamp Status High
This field contains the lower 32 bits of the Seconds field of Transmit packet's captured timestamp.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND</name>
          <description>Timestamp Ingress Correction Nanoseconds Register</description>
          <addressOffset>0xB58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSIC</name>
              <description>Timestamp Ingress Correction
This field contains the ingress path correction value as defined by the Ingress Correction expression.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND</name>
          <description>Timestamp Egress Correction Nanoseconds Register</description>
          <addressOffset>0xB5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSEC</name>
              <description>Timestamp Egress Correction
This field contains the nanoseconds part of the egress path correction value as defined by the Egress Correction expression.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_INGRESS_LATENCY</name>
          <description>Ingress MAC latency Register</description>
          <addressOffset>0xB68</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ITLNS</name>
              <description>Ingress Timestamp Latency, in sub-nanoseconds
This register holds the average latency in sub-nanoseconds between the input ports (ETH_RXD[1-0]) of MAC and the actual point (RMII) where the ingress timestamp is taken.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ITLSNS</name>
              <description>Ingress Timestamp Latency, in nanoseconds
This register holds the average latency in nanoseconds between the input ports (ETH_RXD[1-0]) of MAC and the actual point (RMII) where the ingress timestamp is taken.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_TIMESTAMP_EGRESS_LATENCY</name>
          <description>Egress MAC latency Register</description>
          <addressOffset>0xB6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETLNS</name>
              <description>Egress Timestamp Latency, in nanoseconds
This register holds the average latency in nanoseconds between the actual point (RMII) where the egress timestamp is taken and the output ports (ETH_TXD[1-0]) of the MAC.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ETLSNS</name>
              <description>Egress Timestamp Latency, in sub-nanoseconds
This register holds the average latency in sub-nanoseconds between the actual point (RMII) where the egress timestamp is taken and the output ports (ETH_TXD[1-0]) of the MAC.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PPS_CONTROL</name>
          <description>PPS Control Register</description>
          <addressOffset>0xB70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PPSCTRL</name>
              <description>Pulse Per Second (PPS) Frequency Control
This field controls the PPS frequency. The default value of PPSCTRL is 0x0, and the PPS frequency is 1 pulse every second. For other values of PPSCTRL, the PPS becomes a generated clock of the following frequencies:
Note:
In the binary rollover mode, the PPS frequency has a duty cycle of 50 percent with these frequencies.
In the digital rollover mode, the PPS frequency is an average number. The actual clock is of different frequency that gets synchronized every second. For example:
When PPSCTRL = 0x1, the PPS (1 Hz) has a low period of 537 ms and a high period of 463 ms
When PPSCTRL = 0x2, the PPS (2 Hz) is a sequence of:
- One clock of 50 percent duty cycle and 537 ms period
- Second clock of 463 ms period (268 ms low and 195 ms high)
When PPSCTRL = 0x3, the PPS (4 Hz) is a sequence of:
- Fourth clock of 195 ms period (134 ms low and 61 ms high)
This behavior is because of the non-linear toggling of bits in the digital rollover mode in the ETH_MAC_SYSTEM_TIME_NANOSECONDS register.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The binary rollover is 2 Hz, and the digital rollover is 1 Hz.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>The binary rollover is 4 Hz, and the digital rollover is 2 Hz.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>The binary rollover is 8 Hz, and the digital rollover is 4 Hz.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>The binary rollover is 16 Hz, and the digital rollover is 8 Hz.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>The binary rollover is 32.768 kHz and the digital rollover is 16.384 kHz.</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PPS0_TARGET_TIME_SECONDS</name>
          <description>PPS0 Target Time Seconds Register</description>
          <addressOffset>0xB80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSTRH0</name>
              <description>PPS Target Time Seconds
This field stores the time in seconds. When the timestamp value matches or exceeds both ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers, the MAC generates an interrupt (if enabled).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS</name>
          <description>PPS0 Target Time Nanoseconds Register</description>
          <addressOffset>0xB84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTSL0</name>
              <description>Target Time Low for PPS Register
This register stores the time in (signed) nanoseconds. When the value of the timestamp matches the value in both ETH_MAC_PPS0_TARGET_TIME_SECONDS and ETH_MAC_PPS0_TARGET_TIME_NANOSECONDS registers, the MAC generates an interrupt (if enabled).
When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is reset, this value should be (time in ns / 0.465).
When the ETH_MAC_TIMESTAMP_CONTROL[TSCTRLSSR] bit is set, this value should not exceed 0x3B9A_C9FF.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_OPERATION_MODE</name>
          <description>Operation Mode Register</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTCLR</name>
              <description>Counters Reset
When this bit is set, all counters are reset. This bit is cleared automatically after 1 clock cycle.
If this bit is set along with CNT_PRESET, the CNT_PRESET has precedence.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Counters are not reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>All counters are reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CNTPRST</name>
              <description>Counters Preset
When this bit is set,
The ETH_MTL_TXQ0_UNDERFLOW register is initialized/preset to 0x7F0.
The ETH_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT[MISPKTCNT] and ETH_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT[OVFPKTCNT] fields are initialized/preset to 0x7F0.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Counters preset is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Counters preset is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTXSTS</name>
              <description>Drop Transmit Status
When this bit is set, the Tx packet status received from the MAC is dropped in the MTL. When this bit is reset, the Tx packet status received from the MAC is forwarded to the application.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Drop transmit status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Drop transmit status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_DBG_CTL</name>
          <description>FIFO Debug Access Control and Status Register</description>
          <addressOffset>0xC08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STSIE</name>
              <description>Transmit Status Available Interrupt Status Enable
When this bit is set, an interrupt is generated when Transmit status is available in slave mode.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit packet available interrupt status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit packet available interrupt status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTIE</name>
              <description>Receive Packet Available Interrupt Status Enable
When this bit is set, an interrupt is generated when EOP of received packet is written to the Rx FIFO.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive packet available interrupt status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive packet available interrupt status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOSEL</name>
              <description>FIFO Selected for Access
This field indicates the FIFO selected for debug access:</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx Status FIFO (only read access when SLVMOD is set)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>TSO FIFO (cannot be accessed when SLVMOD is set)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Rx FIFO</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOWREN</name>
              <description>FIFO Write Enable
When this bit is set, it enables the Write operation on selected FIFO when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO write is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO write is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFORDEN</name>
              <description>FIFO Read Enable
When this bit is set, it enables the Read operation on selected FIFO when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO read is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO read is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSTSEL</name>
              <description>Reset Pointers of Selected FIFO
When this bit is set, the pointers of the currently-selected FIFO are reset when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset pointers of selected FIFO is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset pointers of selected FIFO is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSTALL</name>
              <description>Reset All Pointers
When this bit is set, the pointers of all FIFOs are reset when FIFO Debug Access is enabled.
This bit must not be written to 1 when FIFO Debug Access is not enabled, that is FDBGEN bit is 0.
Access restriction applies. Self-cleared. Setting 0 clears. Setting 1 sets.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset all pointers is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset all pointers is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTSTATE</name>
              <description>Encoded Packet State
This field is used to write the control information to the Tx FIFO or Rx FIFO.
Tx FIFO:
0x0: Packet data
0x1: Control word
0x2: SOP data
0x3: EOP data
Rx FIFO:
0x0: Packet data
0x1: Normal status
0x2: Last status
0x3: EOP</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEEN</name>
              <description>Byte Enables
This field indicates the number of data bytes valid in the data register during Write operation. This is valid only when PKTSTATE is 0x2 (EOP) and Tx FIFO or Rx FIFO is selected.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Byte 0 valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 0 and Byte 1 are valid</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Byte 0, Byte 1, and Byte 2 are valid</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>All four bytes are valid</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBGMOD</name>
              <description>Debug Mode Access to FIFO
When this bit is set, it indicates that the current access to the FIFO is read, write, and debug access. In this mode, the following access types are allowed:
Read and Write access to Tx FIFO, TSO FIFO, and Rx FIFO
Read access is allowed to Tx Status FIFO.
Write access to the Tx FIFO
Read access to the Rx FIFO and Tx Status FIFO</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Debug mode access to FIFO is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Debug mode access to FIFO is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FDBGEN</name>
              <description>FIFO Debug Access Enable
When this bit is set, it indicates that the debug mode access to the FIFO is enabled. When this bit is reset, it indicates that the FIFO can be accessed only through a master interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO debug access is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO debug access is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_DBG_STS</name>
          <description>FIFO Debug Status Register</description>
          <addressOffset>0xC0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00800018</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCR</name>
              <description>Remaining Locations in the FIFO
Slave Access Mode:
This field indicates the space available in selected FIFO.
Debug Access Mode:
This field contains the Write or Read pointer value of the selected FIFO during Write or Read operation, respectively.</description>
              <bitRange>[31:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STSI</name>
              <description>Transmit Status Available Interrupt Status
When set, this bit indicates that the Slave mode Tx packet is transmitted, and the status is available in Tx Status FIFO. This bit is reset when 1 is written to this bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit status available interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit status available interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTI</name>
              <description>Receive Packet Available Interrupt Status
When set, this bit indicates that MAC layer has written the EOP of received packet to the Rx FIFO. This bit is reset when 1 is written to this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive packet available interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive packet available interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYTEEN</name>
              <description>Byte Enables
This field indicates the number of data bytes valid in the data register during Read operation. This is valid only when PKTSTATE is 0x2 (EOP) and Tx FIFO or Rx FIFO is selected.</description>
              <bitRange>[4:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Byte 0 valid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 0 and Byte 1 are valid</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Byte 0, Byte 1, and Byte 2 are valid</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>All four bytes are valid</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PKTSTATE</name>
              <description>Encoded Packet State
This field is used to get the control or status information of the selected FIFO.
Tx FIFO:</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Packet data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Control word/normal status</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>SOP data/last status</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>EOP data/EOP</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFOBUSY</name>
              <description>FIFO Busy
When set, this bit indicates that a FIFO operation is in progress in the MAC and content of the following fields is not valid:
All other fields of this register
All fields of the ETH_MTL_FIFO_DEBUG_DATA register</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO busy not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FIFO busy detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_FIFO_DEBUG_DATA</name>
          <description>FIFO Debug Data Register</description>
          <addressOffset>0xC10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FDBGDATA</name>
              <description>FIFO Debug Data
During debug or slave access write operation, this field contains the data to be written to the Tx FIFO, Rx FIFO, or TSO FIFO. During debug or slave access read operation, this field contains the data read from the Tx FIFO, Rx FIFO, TSO FIFO, or Tx Status FIFO.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_INTERRUPT_STATUS</name>
          <description>MTL Interrupt Status Register</description>
          <addressOffset>0xC20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFE0001</resetMask>
          <fields>
            <field>
              <name>DBGIS</name>
              <description>Debug Interrupt status
This bit indicates an interrupt event during the slave access. To reset this bit, the application must read the ETH_MTL_DBG_STS register to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Debug interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Debug interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>Q0IS</name>
              <description>Queue 0 Interrupt status
This bit indicates that there is an interrupt from Queue 0. To reset this bit, the application must read Queue 0 Interrupt Control and Status register to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Queue 0 interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Queue 0 interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_TXQ0_OPERATION_MODE</name>
          <description>Queue 0 Transmit Operation Mode Register</description>
          <addressOffset>0xD00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF3</resetMask>
          <fields>
            <field>
              <name>TTC</name>
              <description>Transmit Threshold Control
These bits control the threshold level of the MTL Tx Queue. The transmission starts when the packet size within the MTL Tx Queue is larger than the threshold. In addition, full packets with length less than the threshold are also transmitted. These bits are used only when the TSF bit is reset.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>32</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>64</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>96</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>128</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>192</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>256</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>384</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>512</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSF</name>
              <description>Transmit Store and Forward
When this bit is set, the transmission starts when a full packet resides in the MTL Tx Queue. When this bit is set, the TTC value is ignored. This bit should be changed only when the transmission is stopped.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit store and forward is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit store and forward is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FTQ</name>
              <description>Flush Transmit Queue
When this bit is set, the Tx Queue controller logic is reset to its default values. Therefore, all the data in the Tx Queue is lost or flushed. This bit is internally reset when the flushing operation is complete. Until this bit is reset, the user should not write to the ETH_MTL_TXQ0_OPERATION_MODE register. The data which is already accepted by the MAC transmitter is not flushed. It is scheduled for transmission and results in underflow and runt packet transmission.
Note: The flush operation is complete only when the Tx Queue is empty and the application has accepted the pending Tx Status of all transmitted packets.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Flush transmit queue is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flush transmit queue is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_TXQ0_UNDERFLOW</name>
          <description>Queue 0 Underflow Counter Register</description>
          <addressOffset>0xD04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UFCNTOVF</name>
              <description>Overflow Bit for Underflow Packet Counter
This bit is set every time the Tx Queue Underflow Packet Counter field overflows, that is, it has crossed the maximum count. In such a scenario, the overflow packet counter is reset to all-zeros and this bit indicates that the rollover happened.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Overflow not detected for underflow packet counter</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Overflow detected for underflow packet counter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UFFRMCNT</name>
              <description>Underflow Packet Counter
This field indicates the number of packets aborted by the controller because of Tx Queue Underflow. This counter is incremented each time the MAC aborts outgoing packet because of underflow.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_TXQ0_DEBUG</name>
          <description>Queue 0 Transmit Debug Register</description>
          <addressOffset>0xD08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STXSTSF</name>
              <description>Number of Status Words in Tx Status FIFO of Queue
This field indicates the current number of status in the Tx Status FIFO of this queue.
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set to 1, this field does not reflect the number of status words in Tx Status FIFO.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PTXQ</name>
              <description>Number of Packets in the Transmit Queue
This field indicates the current number of packets in the Tx Queue.
When the ETH_MTL_OPERATION_MODE[DTXSTS] bit is set to 1, this field does not reflect the number of packets in the Transmit queue.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TXSTSFSTS</name>
              <description>MTL Tx Status FIFO Full Status
When high, this bit indicates that the MTL Tx Status FIFO is full. Therefore, the MTL cannot accept any more packets for transmission.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Tx Status FIFO full status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Tx Status FIFO full status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXQSTS</name>
              <description>MTL Tx Queue Not Empty Status
When this bit is high, it indicates that the MTL Tx Queue is not empty and some data is left for transmission.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Tx Queue not empty status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Tx Queue not empty status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TWCSTS</name>
              <description>MTL Tx Queue Write Controller Status
When high, this bit indicates that the MTL Tx Queue Write Controller is active, and it is transferring the data to the Tx Queue.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Tx Queue write controller status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Tx Queue write controller status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRCSTS</name>
              <description>MTL Tx Queue Read Controller Status
This field indicates the state of the Tx Queue Read Controller:</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read state (transferring data to the MAC transmitter)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Waiting for pending Tx status from the MAC transmitter</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Flushing the Tx Queue because of the packet abort request from the MAC</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXQPAUSED</name>
              <description>Transmit Queue in Pause
When this bit is high and the Rx flow control is enabled, it indicates that the Tx Queue is in the Pause condition (in the full-duplex only mode) because of the following:
Reception of the PFC packet for the priorities assigned to the Tx Queue when PFC is enabled
Reception of 802.3x Pause packet when PFC is disabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit queue in pause status is not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit queue in pause status is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_Q0_INTERRUPT_CONTROL_STATUS</name>
          <description>Queue 0 Interrupt Enable and Status Register</description>
          <addressOffset>0xD2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOIE</name>
              <description>Receive Queue Overflow Interrupt Enable
When this bit is set, the receive queue overflow interrupt is enabled. When this bit is reset, the Receive Queue Overflow interrupt is disabled.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive queue overflow interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive queue overflow interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOVFIS</name>
              <description>Receive Queue Overflow Interrupt Status
This bit indicates that the receive queue had an overflow while receiving the packet. If a partial packet is transferred to the application, the overflow status is set in RDES3[21]. This bit is cleared when the application writes 1 to this bit.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive queue overflow interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive queue overflow interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXUIE</name>
              <description>Transmit Queue Underflow Interrupt Enable
When this bit is set, the transmit queue underflow interrupt is enabled. When this bit is reset, the Transmit Queue Underflow interrupt is disabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit queue underflow interrupt status is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit queue underflow interrupt status is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXUNFIS</name>
              <description>Transmit Queue Underflow Interrupt Status
This bit indicates that the transmit queue had an underflow while transmitting the packet. Transmission is suspended and an Underflow Error TDES3[2] is set. This bit is cleared when the application writes 1 to this bit.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit queue underflow interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit queue underflow interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_RXQ0_OPERATION_MODE</name>
          <description>Queue 0 Receive Operation Mode Register</description>
          <addressOffset>0xD30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIS_TCP_EF</name>
              <description>Disable Dropping of TCP/IP Checksum Error Packets
When this bit is set, the MAC does not drop the packets which only have the errors detected by the Receive Checksum Offload engine. Such packets have errors only in the encapsulated payload. There are no errors (including FCS error) in the Ethernet packet received by the MAC.
When this bit is reset, all error packets are dropped if the FEP bit is reset.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Dropping of TCP/IP checksum error packets is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dropping of TCP/IP checksum error packets is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSF</name>
              <description>Receive Queue Store and Forward
When this bit is set, the ETH module reads a packet from the Rx Queue only after the complete packet has been written to it, ignoring the RTC field of this register. When this bit is reset, the Rx Queue operates in the Threshold (cut-through) mode, subject to the threshold specified by the RTC field of this register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive queue store and forward is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive queue store and forward is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FEP</name>
              <description>Forward Error Packets
When this bit is reset, the Rx Queue drops packets with error status (CRC error, GMII_ER, watchdog timeout, or overflow). However, if the start byte (write) pointer of a packet is already transferred to the read controller side (in Threshold mode), the packet is not dropped.
When this bit is set, all packets except the runt error packets are forwarded to the application or DMA. If the RSF bit is set and the Rx Queue overflows when a partial packet is written, the packet is dropped irrespective of the setting of this bit. However, if the RSF bit is reset and the Rx Queue overflows when a partial packet is written, a partial packet may be forwarded to the application or DMA.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Forward error packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Forward error packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FUP</name>
              <description>Forward Undersized Good Packets
When this bit is set, the Rx Queue forwards the undersized good packets (packets with no error and length less than 64 bytes), including pad-bytes and CRC. When this bit is reset, the Rx Queue drops all packets of less than 64 bytes, unless a packet is already transferred because of the lower value of Rx Threshold, for example, RTC = 01.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Forward undersized good packets is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Forward undersized good packets is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTC</name>
              <description>Receive Queue Threshold Control
These bits control the threshold level of the MTL Rx Queue (in bytes):The received packet is transferred to the application or DMA when the packet size within the MTL Rx Queue is larger than the threshold. In addition, full packets with length less than the threshold are automatically transferred.
This field is valid only when the RSF bit is zero. This field is ignored when the RSF bit is set to 1.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>32</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>96</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>128</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_RXQ0_MISSED_PACKET_OVERFLOW_CNT</name>
          <description>Queue 0 Missed Packet and Overflow Counter Register</description>
          <addressOffset>0xD34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MISCNTOVF</name>
              <description>Missed Packet Counter Overflow Bit
When set, this bit indicates that the Rx Queue Missed Packet Counter crossed the maximum limit.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Missed packet counter overflow not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Missed packet counter overflow detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MISPKTCNT</name>
              <description>Missed Packet Counter
This counter is incremented by 1 when the DMA discards the packet because of buffer unavailability.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[26:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVFCNTOVF</name>
              <description>Overflow Counter Overflow Bit
When set, this bit indicates that the Rx Queue Overflow Packet Counter field crossed the maximum limit.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Overflow counter overflow not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Overflow counter overflow detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVFPKTCNT</name>
              <description>Overflow Packet Counter
This field indicates the number of packets discarded by the ETH module because of Receive queue overflow. This counter is incremented each time the ETH module discards an incoming packet because of overflow.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_MTL_RXQ0_DEBUG</name>
          <description>Queue 0 Receive Debug Register</description>
          <addressOffset>0xD38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRXQ</name>
              <description>Number of Packets in Receive Queue
This field indicates the current number of packets in the Rx Queue. theoretical maximum value for this field is 256KB/16B = 16KB Packets, that is, Max_Queue_Size/Min_Packet_Size.</description>
              <bitRange>[29:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RXQSTS</name>
              <description>MTL Rx Queue Fill-Level Status
This field gives the status of the fill-level of the Rx Queue:</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx Queue empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx Queue fill-level below flow-control deactivate threshold</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Rx Queue fill-level above flow-control activate threshold</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Rx Queue full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RRCSTS</name>
              <description>MTL Rx Queue Read Controller State
This field gives the state of the Rx Queue Read controller:</description>
              <bitRange>[2:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Idle state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reading packet data</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Reading packet status (or timestamp)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Flushing the packet data and status</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWCSTS</name>
              <description>MTL Rx Queue Write Controller Active Status
When high, this bit indicates that the MTL Rx Queue Write controller is active, and it is transferring a received packet to the Rx Queue.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL Rx Queue write controller active status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL Rx Queue write controller active status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_MODE</name>
          <description>Bus Mode Register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTM</name>
              <description>Interrupt Mode
This field defines the interrupt mode of the ETH module and changes the behavior of the ETH_SBD_IRQ signal.
It also changes the behavior of the ETH_DMA_CH0_STATUS[RI] and ETH_DMA_CH0_STATUS[TI] bits.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ETH_SBD_IRQ is asserted when corresponding interrupts are enabled, and cleared only when software clears the corresponding RI/TI status bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ETH_SBD_IRQ is not asserted on TX/RX packet transfer completion event.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>ETH_SBD_IRQ is not asserted on TX/RX packet transfer completion event.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSPW</name>
              <description>Descriptor Posted Write
When this bit is set to 0, the descriptor writes are always non-posted.
When this bit is set to 1, the descriptor writes are non-posted only when IOC (Interrupt on completion) is set in last descriptor, otherwise the descriptor writes are always posted.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Descriptor posted write is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Descriptor posted write is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWR</name>
              <description>Software Reset
When this bit is set, the MAC and the DMA controller reset the logic and all internal registers of the DMA, MTL, and MAC. This bit is automatically cleared after the reset operation is complete in all ETH module clock domains. Before reprogramming any ETH module register, a value of zero should be read in this bit.
This bit must be read at least 4 CLK_CSR cycles after it is written to 1.
Note: The reset operation is complete only when all resets in all active clock domains are de-asserted. Therefore, it is essential that all PHY inputs clocks (applicable for the selected PHY interface) are present for software reset completion. The time to complete the software reset operation depends on the frequency of the slowest active clock.
Access restriction applies. Setting 1 sets. Self-cleared. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Software reset is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Software reset is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_SYSBUS_MODE</name>
          <description>System Bus Mode Register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01010000</resetValue>
          <resetMask>0xFFFF37FF</resetMask>
          <fields>
            <field>
              <name>EN_LPI</name>
              <description>Enable Low Power Interface (LPI)
When set to 1, this bit enables the LPI mode and accepts the LPI request from the AXI System Clock controller.
When set to 0, this bit disables the LPI mode and always denies the LPI request from the AXI System Clock controller.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPI is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPI is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPI_XIT_PKT</name>
              <description>Unlock on Magic Packet or Remote Wake-Up Packet
When set to 1, this bit enables the AXI master to come out of the LPI mode only when the magic packet or remote wake-up packet is received. When set to 0, this bit enables the AXI master to come out of the LPI mode when any packet is received.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Unlock on magic packet or remote wake-up packet is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Unlock on magic packet or remote wake-up packet is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_OSR_LMT</name>
              <description>AXI Maximum Write Outstanding Request Limit
This value limits the maximum outstanding request on the AXI write interface. Maximum outstanding requests = WR_OSR_LMT + 1.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_OSR_LMT</name>
              <description>AXI Maximum Read Outstanding Request Limit
This value limits the maximum outstanding request on the AXI read interface. Maximum outstanding requests = RD_OSR_LMT + 1.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ONEKBBE</name>
              <description>1KB Boundary Crossing Enable for the AXI Master
When set, the burst transfers performed by the AXI master do not cross 1KB boundary. When reset, the burst transfers performed by the AXI master do not cross 4KB boundary.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1KB boundary crossing for the AXI master beats is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1KB boundary crossing for the AXI master beats is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AAL</name>
              <description>Address-Aligned Beats
When this bit is set to 1, the AXI master performs address-aligned burst transfers on Read and Write channels.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Address-aligned beats is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Address-aligned beats is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AALE</name>
              <description>Automatic AXI LPI enable
When set to 1, enables the AXI master to enter into LPI state when there is no activity in the ETH module for number of system clock cycles programmed in the ETH_AXI_LPI_ENTRY_INTERVAL[LPIEI] field.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Automatic AXI LPI is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Automatic AXI LPI is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN16</name>
              <description>AXI Burst Length 16
When this bit is set to 1 or the FB bit is set to 0, the AXI master can select a burst length of 16 on the AXI interface.
When the FB bit is set to 0, setting this bit has no effect.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI burst length 16</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN8</name>
              <description>AXI Burst Length 8
When this bit is set to 1 or the FB bit is set to 0, the AXI master can select a burst length of 8 on the AXI interface.
When the FB bit is set to 0, setting this bit has no effect.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI burst length 8</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLEN4</name>
              <description>AXI Burst Length 4
When this bit is set to 1 or the FB bit is set to 0, the AXI master can select a burst length of 4 on the AXI interface.
When the FB bit is set to 0, setting this bit has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No effect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI burst length 4</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FB</name>
              <description>Fixed Burst Length
When this bit is set to 1, the AXI master initiates burst transfers of specified lengths as given below.
Burst transfers of length 1
When this bit is set to 0, the AXI master initiates burst transfers that are equal to or less than the maximum allowed burst length programmed in Bits[3-1].</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Fixed burst length is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fixed burst length is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_INTERRUPT_STATUS</name>
          <description>DMA, MTL, and MAC Interrupt Status Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MACIS</name>
              <description>MAC Interrupt Status
This bit indicates an interrupt event in the MAC. To reset this bit to 0x0, the software must read the corresponding register in the MAC to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MAC interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MAC interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MTLIS</name>
              <description>MTL Interrupt Status
This bit indicates an interrupt event in the MTL. To reset this bit to 0x0, the software must read the corresponding register in the MTL to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MTL interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MTL interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DC0IS</name>
              <description>DMA Channel 0 Interrupt Status
This bit indicates an interrupt event in DMA Channel 0. To reset this bit to 0x0, the software must read the corresponding register in DMA Channel 0 to get the exact cause of the interrupt and clear its source.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA channel 0 interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA channel 0 interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_DEBUG_STATUS0</name>
          <description>Debug Status 0 Register</description>
          <addressOffset>0x100C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TPS0</name>
              <description>DMA Channel 0 Transmit Process State
This field indicates the Tx DMA FSM state for Channel 0. The MSB of this field always returns 0. This field does not generate an interrupt.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped (reset or stop transmit command issued)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running (fetching Tx transfer descriptor)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Running (waiting for status)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Running (reading data from system memory buffer and queuing it to the Tx buffer (Tx FIFO))</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Timestamp write state</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Suspended (Tx descriptor unavailable or Tx buffer underflow)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Running (closing Tx descriptor)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPS0</name>
              <description>DMA Channel 0 Receive Process State
This field indicates the Rx DMA FSM state for Channel 0. The MSB of this field always returns 0. This field does not generate an interrupt.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stopped (reset or stop receive command issued)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Running (fetching Rx transfer descriptor)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Running (waiting for Rx packet)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Suspended (Rx descriptor unavailable)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Running (closing the Rx descriptor)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Timestamp write state</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Running (transferring the received packet data from the Rx buffer to the system memory)</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AXRHSTS</name>
              <description>AXI Master Read Channel Status
When high, this bit indicates that the read channel of the AXI master is active, and it is transferring the data.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI master read channel status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI master read channel status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AXWHSTS</name>
              <description>AXI Master Write Channel
When high, this bit indicates that the write channel of the AXI master is active, and it is transferring data.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AXI master write channel status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AXI master write channel status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_AXI_LPI_ENTRY_INTERVAL</name>
          <description>AXI LPI Entry Interval Register</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPIEI</name>
              <description>LPI Entry Interval
Contains the number of system clock cycles, multiplied by 64, to wait for an activity in the ETH module to enter into the AXI low power state.
0x0 indicates 64 clock cycles</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CONTROL</name>
          <description>DMA Channel 0 Control Register</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSL</name>
              <description>Descriptor Skip Length
This bit specifies the Dword to skip between two unchained descriptors. The address skipping starts from the end of the current descriptor to the start of the next descriptor.
When the DSL value is equal to zero, the DMA takes the descriptor table as contiguous.</description>
              <bitRange>[20:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBLX8</name>
              <description>8xPBL mode
When this bit is set, the PBL value programmed in the ETH_DMA_CH0_TX_CONTROL[TXPBL] and ETH_DMA_CH0_RX_CONTROL[RXPBL] fields is multiplied by eight times. Therefore, the DMA transfers the data in 8, 16, 32, 64, 128, and 256 beats depending on the PBL value.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8xPBL mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8xPBL mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSS</name>
              <description>Maximum Segment Size
This field specifies the maximum segment size that should be used while segmenting the packet. This field is valid only if the ETH_DMA_CH0_TX_CONTROL[TSE] bit is set.
It is recommended to use a MSS value of 64 bytes or more.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TX_CONTROL</name>
          <description>DMA Channel 0 Transmit Control Register</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF9FF1</resetMask>
          <fields>
            <field>
              <name>TXPBL</name>
              <description>Transmit Programmable Burst Length
These bits indicate the maximum number of beats to be transferred in one DMA block data transfer. The DMA always attempts max burst as specified in PBL each time it starts a burst transfer on the application bus. The user can program PBL with any of the following values: 1, 2, 4, 8, 16, or 32. Any other value results in undefined behavior.
To transfer more than 32 beats, perform the following steps:
1. Set the 8xPBL mode in ETH_DMA_CH0_CONTROL register.
2. Set the TxPBL.
Note: The maximum value of TxPBL must be less than or equal to half the Tx Queue size in terms of beats. This is required so that the Tx Queue has space to store at least another Tx PBL worth of data while the MTL Tx Queue Controller is transferring data to MAC. For example, the total locations in Tx Queue of size 512 bytes is 64, TxPBL and 8xPBL needs to be programmed to less than or equal to 32.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPBL</name>
              <description>Ignore PBL Requirement
When this bit is set, the DMA does not check for PBL number of locations in the MTL before initiating a transfer. If space is not available, the MTL may use handshaking to slow the DMA.
Note: This bit/mode must not be used when multiple Transmit DMA Channels are enabled as it may block other Transmit and Receive DMA Channels from accessing the Read Data Channel of AXI bus until space is available in Transmit Queue for current transfer.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore PBL requirement is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ignore PBL requirement is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSE</name>
              <description>TCP Segmentation Enabled
When this bit is set, the DMA performs the TCP segmentation or UDP Segmentation/Fragmentation for packets in this channel. The TCP segmentation or UDP packet's segmentation/Fragmentation is done only for those packets for which the TSE bit (TDES0[19]) is set in the Tx Normal descriptor.When this bit is set, the TxPBL value must be greater than 4.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TCP segmentation is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TCP segmentation is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OSF</name>
              <description>Operate on Second Packet
When this bit is set, it instructs the DMA to process the second packet of the Transmit data even before the status for the first packet is obtained.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Operate on second packet disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Operate on second packet enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ST</name>
              <description>Start or Stop Transmission Command
When this bit is set, transmission is placed in the Running state. The DMA checks the Transmit list at the current position for a packet to be transmitted.
The DMA tries to acquire descriptor from either of the following positions:
The current position in the list
The position at which the transmission was previously stopped
When this bit is reset, the transmission process is placed in the Stopped state after completing the transmission of the current packet. The Next Descriptor position in the Transmit list is saved, and it becomes the current position when the transmission is restarted. To change the list address, the user needs to program ETH_DMA_CH0_TXDESC_LIST_ADDRESS register with a new value when this bit is reset. The new value is considered when this bit is set again. The stop transmission command is effective only when the transmission of the current packet is complete or the transmission is in the Suspended state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop transmission command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Start transmission command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RX_CONTROL</name>
          <description>DMA Channel 0 Receive Control Register</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPF</name>
              <description>Rx Packet Flush.
When this bit is set to 1, then the ETH module automatically flushes the packet from the Rx Queues destined to this DMA Rx Channel, when it is stopped. When this bit remains set and the DMA is re-started by the software driver, the packets residing in the Rx Queues that were received when this Rx DMA was stopped, get flushed out. The packets that are received by the MAC after the Rx DMA is re-started are routed to the Rx DMA. The flushing happens on the Read side of the Rx Queue.
When this bit is set to 0, the ETH module does not flush the packet in the Rx Queue destined to this Rx DMA Channel when it is STOP state. This may in turn cause head-of-line blocking in the corresponding RxQueue.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx packet flush is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx packet flush is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXPBL</name>
              <description>Receive Programmable Burst Length
These bits indicate the maximum number of beats to be transferred in one DMA block data transfer. The DMA always attempts max burst as specified in PBL each time it starts a burst transfer on the application bus. The user can program PBL with any of the following values: 1, 2, 4, 8, 16, or 32. Any other value results in undefined behavior.
To transfer more than 32 beats, perform the following steps:
1. Set the 8xPBL mode in the ETH_DMA_CH0_CONTROL register.
2. Set the RxPBL.
Note: The maximum value of RxPBL must be less than or equal to half the Rx Queue size in terms of beats. This is required so that the Rx Queue has space to store at least another Rx PBL worth of data while the Rx DMA is transferring a block of data. For example, the total locations in Rx Queue of size 512 bytes is 64, so RxPBL and 8xPBL needs to be programmed to less than or equal to 32.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RBSZ_13_Y</name>
              <description>Receive Buffer Size High
RBSZ[13-0] is split into two fields higher RBSZ_13_y and lower RBSZ_x_0. The RBSZ[13-0] field indicates the size of the Rx buffers specified in bytes. The maximum buffer size is limited to 16KB. The buffer size is applicable to payload buffers when split headers are enabled.
Note: The buffer size must be a multiple of 4, 8, or 16 depending on the data bus widths (32-bit, 64-bit, or 128-bit respectively). This is required even if the value of buffer address pointer is not aligned to data bus width. Hence the lower RBSZ_x_0 bits are read-only and the value is considered as all-zero. Thus the RBSZ_13_y indicates the buffer size in terms of locations (with the width same as bus-width).</description>
              <bitRange>[14:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RBSZ_X_0</name>
              <description>Receive Buffer Size Low
RBSZ[13-0] is split into two fields RBSZ_13_Y and RBSZ_X_0. The RBSZ_X_0 is the lower field.</description>
              <bitRange>[3:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR</name>
              <description>Start or Stop Receive
When this bit is set, the DMA tries to acquire the descriptor from the Receive list and processes the incoming packets.
The DMA tries to acquire descriptor from either of the following positions:
The current position in the list
The position at which the Rx process was previously stopped
When this bit is reset, the Rx DMA operation is stopped after the transfer of the current packet. The next descriptor position in the Receive list is saved, and it becomes the current position after the Rx process is restarted. The Stop Receive command is effective only when the Rx process is in the Running (waiting for Rx packet) or Suspended state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop receive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Start receive</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TXDESC_LIST_ADDRESS</name>
          <description>DMA Channel 0 Transmit Descriptor List Address Register</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDESLA</name>
              <description>Start of Transmit List
This field contains the base address of the first descriptor in the Transmit descriptor list.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RXDESC_LIST_ADDRESS</name>
          <description>DMA Channel 0 Receive Descriptor List Address Register</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDESLA</name>
              <description>Start of Receive List
This field contains the base address of the first descriptor in the Rx Descriptor list.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TXDESC_TAIL_POINTER</name>
          <description>DMA Channel 0 Transmit Descriptor Tail Pointer Register</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDTP</name>
              <description>Transmit Descriptor Tail Pointer
This field contains the tail pointer for the Tx descriptor ring. The software writes the tail pointer to add more descriptors to the Tx channel. The hardware tries to transmit all packets referenced by the descriptors between the head and the tail pointer registers.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RXDESC_TAIL_POINTER</name>
          <description>DMA Channel 0 Receive Descriptor Tail Pointer Register</description>
          <addressOffset>0x1128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDTP</name>
              <description>Receive Descriptor Tail Pointer
This field contains the tail pointer for the Rx descriptor ring. The software writes the tail pointer to add more descriptors to the Rx channel. The hardware tries to write all received packets to the descriptors referenced between the head and the tail pointer registers.</description>
              <bitRange>[31:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_TXDESC_RING_LENGTH</name>
          <description>DMA Channel 0 Transmit Descriptor Ring Length Register</description>
          <addressOffset>0x112C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDRL</name>
              <description>Transmit Descriptor Ring Length
This field sets the maximum number of Tx descriptors in the circular descriptor ring. The maximum number of descriptors is limited to 1KB descriptors. It is recommended a minimum ring descriptor length of 4. For example, any value up to 0x3FF can be programmed in this field. If 0x3FF is programmed, the descriptors are 1024. If 10 descriptors are needed, program it to a value of 0x9.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RXDESC_RING_LENGTH</name>
          <description>DMA Channel 0 Receive Descriptor Ring Length Register</description>
          <addressOffset>0x1130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDRL</name>
              <description>Receive Descriptor Ring Length
This register sets the maximum number of Rx descriptors in the circular descriptor ring. The maximum number of descriptors is limited to 1KB descriptors. For example, any value up to 0x3FF can be programmed in this field. If 0x3FF is programmed, the descriptors are 1024. If 10 descriptors are needed, program it to a value of 0x9.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_INTERRUPT_ENABLE</name>
          <description>DMA Channel 0 Interrupt Enable Register</description>
          <addressOffset>0x1134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NIE</name>
              <description>Normal Interrupt Summary Enable
When this bit is set, the normal interrupt summary is enabled. This bit enables the following interrupts in the ETH_DMA_CH0_STATUS register:
Bit 0: Transmit Interrupt
Bit 2: Transmit Buffer Unavailable
Bit 6: Receive Interrupt
Bit 11: Early Receive Interrupt</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal interrupt summary is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Normal interrupt summary is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIE</name>
              <description>Abnormal Interrupt Summary Enable
When this bit is set, the abnormal interrupt summary is enabled. This bit enables the following interrupts in the ETH_DMA_CH0_STATUS register:
Bit 1: Transmit Process Stopped
Bit 7: Rx Buffer Unavailable
Bit 8: Receive Process Stopped
Bit 9: Receive Watchdog Timeout
Bit 10: Early Transmit Interrupt
Bit 12: Fatal Bus Error
Bit 13: Context Descriptor Error</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Abnormal interrupt summary is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Abnormal interrupt summary is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CDEE</name>
              <description>Context Descriptor Error Enable
When this bit is set along with the AIE bit, the descriptor error interrupt is enabled. When this bit is reset, the descriptor error interrupt is disabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Context descriptor error is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Context descriptor error is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FBEE</name>
              <description>Fatal Bus Error Enable
When this bit is set along with the AIE bit, the fatal bus error interrupt is enabled. When this bit is reset, the fatal bus error error interrupt is disabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Fatal bus error is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fatal bus error is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERIE</name>
              <description>Early Receive Interrupt Enable
When this bit is set along with the NIE bit, the early receive interrupt is enabled. When this bit is reset, the early receive interrupt is disabled.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early receive interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early receive interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETIE</name>
              <description>Early Transmit Interrupt Enable
When this bit is set along with the AIE bit, the early transmit interrupt is enabled. When this bit is reset, the early transmit interrupt is disabled.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early transmit interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early transmit interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWTE</name>
              <description>Receive Watchdog Timeout Enable
When this bit is set along with the AIE bit, the receive watchdog timeout interrupt is enabled. When this bit is reset, the receive watchdog timeout interrupt is disabled.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive watchdog timeout is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive watchdog timeout is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSE</name>
              <description>Receive Stopped Enable
When this bit is set along with the AIE bit, the receive stopped interrupt is enabled. When this bit is reset, the receive stopped interrupt is disabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive stopped is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive stopped is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RBUE</name>
              <description>Receive Buffer Unavailable Enable
When this bit is set along with the AIE bit, the receive buffer unavailable interrupt is enabled. When this bit is reset, the receive buffer unavailable interrupt is disabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive buffer unavailable is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive buffer unavailable is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RIE</name>
              <description>Receive Interrupt Enable
When this bit is set along with the NIE bit, the receive interrupt is enabled. When this bit is reset, the receive interrupt is disabled.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBUE</name>
              <description>Transmit Buffer Unavailable Enable
When this bit is set along with the NIE bit, the transmit buffer unavailable interrupt is enabled. When this bit is reset, the transmit buffer unavailable interrupt is disabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit buffer unavailable is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit buffer unavailable is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSE</name>
              <description>Transmit Stopped Enable
When this bit is set along with the AIE bit, the transmission stopped interrupt is enabled. When this bit is reset, the transmission stopped interrupt is disabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit stopped is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit stopped is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIE</name>
              <description>Transmit Interrupt Enable
When this bit is set along with the NIE bit, the transmit interrupt is enabled. When this bit is reset, the transmit interrupt is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit interrupt is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit interrupt is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RX_INTERRUPT_WATCHDOG_TIMER</name>
          <description>DMA Channel 0 Receive Interrupt Watchdog Timer Register</description>
          <addressOffset>0x1138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RWTU</name>
              <description>Receive Interrupt Watchdog Timer Count Units
This fields indicates the number of system clock cycles corresponding to one unit in RWT field.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>256</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>512</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>1024</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>2048</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWT</name>
              <description>Receive Interrupt Watchdog Timer Count
This field indicates the number of system clock cycles, multiplied by factor indicated in RWTU field, for which the watchdog timer is set.
The watchdog timer is triggered with the programmed value after the Rx DMA completes the transfer of a packet for which the RI bit is not set in the ETH_DMA_CH0_STATUS register, because of the setting of Interrupt Enable bit in the corresponding descriptor RDES3[30].
When the watchdog timer runs out, the RI bit is set and the timer is stopped. The watchdog timer is reset when the RI bit is set high because of automatic setting of RI as per the Interrupt Enable bit RDES3[30] of any received packet.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_TXDESC</name>
          <description>DMA Channel 0 Current Application Transmit Descriptor Register</description>
          <addressOffset>0x1144</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTDESAPTR</name>
              <description>Application Transmit Descriptor Address Pointer
The DMA updates this pointer during Tx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_RXDESC</name>
          <description>DMA Channel 0 Current Application Receive Descriptor Register</description>
          <addressOffset>0x114C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRDESAPTR</name>
              <description>Application Receive Descriptor Address Pointer
The DMA updates this pointer during Rx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_TXBUFFER</name>
          <description>DMA Channel 0 Current Application Transmit Buffer Address Register</description>
          <addressOffset>0x1154</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTBUFAPTR</name>
              <description>Application Transmit Buffer Address Pointer
The DMA updates this pointer during Tx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_CURRENT_APP_RXBUFFER</name>
          <description>DMA Channel 0 Current Application Receive Buffer Address Register</description>
          <addressOffset>0x115C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRBUFAPTR</name>
              <description>Application Receive Buffer Address Pointer
The DMA updates this pointer during Rx operation. This pointer is cleared on reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_STATUS</name>
          <description>DMA Channel 0 Status Register</description>
          <addressOffset>0x1160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REB</name>
              <description>Rx DMA Error Bits
This field indicates the type of error that caused a Bus Error. For example, error response on the AXI interface.
Bit 21
0x0: No error during data transfer by Rx DMA
0x1: Error during data transfer by Rx DMA
Bit 20
0x0: Error during data buffer access
0x1: Error during descriptor access
Bit 19
0x0: Error during write transfer
0x1: Error during read transfer</description>
              <bitRange>[21:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEB</name>
              <description>Tx DMA Error Bits
This field indicates the type of error that caused a Bus Error. For example, error response on the AXI interface.
Bit 18
0x0: No error during data transfer by Tx DMA
0x1: Error during data transfer by Tx DMA
Bit 17
0x0: Error during data buffer access
0x1: Error during descriptor access
Bit 16
0x0: Error during write transfer
0x1: Error during read transfer</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NIS</name>
              <description>Normal Interrupt Summary
Normal Interrupt Summary bit value is the logical OR of the following bits when the corresponding interrupt bits are enabled in the ETH_DMA_CH0_INTERRUPT_ENABLE register:
Bit 0: Transmit Interrupt
Bit 2: Transmit Buffer Unavailable
Bit 6: Receive Interrupt
Bit 11: Early Receive Interrupt
This is a sticky bit. The user must clear this bit (by writing 1 to this bit) each time a corresponding bit which causes NIS to be set is cleared.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal interrupt summary status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Normal interrupt summary status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIS</name>
              <description>Abnormal Interrupt Summary
Abnormal Interrupt Summary bit value is the logical OR of the following when the corresponding interrupt bits are enabled in the ETH_DMA_CH0_INTERRUPT_ENABLE register:
Bit 1: Transmit Process Stopped
Bit 7: Receive Buffer Unavailable
Bit 8: Receive Process Stopped
Bit 10: Early Transmit Interrupt
Bit 12: Fatal Bus Error
Bit 13: Context Descriptor Error
This is a sticky bit. The user must clear this bit (by writing 1 to this bit) each time a corresponding bit, which causes AIS to be set, is cleared.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Abnormal interrupt summary status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Abnormal interrupt summary status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CDE</name>
              <description>Context Descriptor Error
This bit indicates that the DMA Tx/Rx engine received a descriptor error, which indicates invalid context in the middle of packet flow ( intermediate descriptor) or all one's descriptor in Tx case and on Rx side it indicates DMA has read a descriptor with either of the buffer address as ones which is considered to be invalid.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Context descriptor error status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Context descriptor error status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FBE</name>
              <description>Fatal Bus Error
This bit indicates that a bus error occurred (as described in the EB field). When this bit is set, the corresponding DMA channel engine disables all bus accesses.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Fatal bus error status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fatal bus error status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ERI</name>
              <description>Early Receive Interrupt
This bit when set indicates that the Rx DMA has completed the transfer of packet data to the memory.
The setting of RI bit automatically clears this bit.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early receive interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early receive interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETI</name>
              <description>Early Transmit Interrupt
This bit when set indicates that the Tx DMA has completed the transfer of packet data to the MTL TXFIFO memory.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Early transmit interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Early transmit interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RWT</name>
              <description>Receive Watchdog Timeout
This bit is asserted when a packet with length greater than 2,048 bytes (10,240 bytes when Jumbo Packet mode is enabled) is received.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive watchdog timeout status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive watchdog timeout status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RPS</name>
              <description>Receive Process Stopped
This bit is asserted when the Rx process enters the Stopped state.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive process stopped status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive process stopped status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RBU</name>
              <description>Receive Buffer Unavailable
This bit indicates that the application owns the next descriptor in the Receive list, and the DMA cannot acquire it. The Rx process is suspended. To resume processing Rx descriptors, the application should change the ownership of the descriptor and issue a Receive Poll Demand command. If this command is not issued, the Rx process resumes when the next recognized incoming packet is received. In ring mode, the application should advance the Receive Descriptor Tail Pointer register of a channel. This bit is set only when the DMA owns the previous Rx descriptor.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive buffer unavailable status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive buffer unavailable status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RI</name>
              <description>Receive Interrupt
This bit indicates that the packet reception is complete. When packet reception is complete, Bit 31 of RDES3 is reset in the last descriptor, and the specific packet status information is updated in the descriptor.
The reception remains in the Running state.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBU</name>
              <description>Transmit Buffer Unavailable
This bit indicates that the application owns the next descriptor in the Transmit list, and the DMA cannot acquire it. Transmission is suspended. the ETH_DMA_DEBUG_STATUS0[TPS0] field explains the Transmit Process state transitions.
To resume processing the Transmit descriptors, the application should do the following:
1. Change the ownership of the descriptor by setting Bit 31 of TDES3.
2. Issue a Transmit Poll Demand command.
For ring mode, the application should advance the Transmit Descriptor Tail Pointer register of a channel.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit buffer unavailable status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit buffer unavailable status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPS</name>
              <description>Transmit Process Stopped
This bit is set when the transmission is stopped.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit process stopped status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit process stopped status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TI</name>
              <description>Transmit Interrupt
This bit indicates that the packet transmission is complete. When transmission is complete, Bit 31 of TDES3 is reset in the last descriptor, and the specific packet status information is updated in the descriptor.
Access restriction applies. Self-set to 1 on internal event. Setting 1 clears. Setting 0 has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit interrupt status not detected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit interrupt status detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_MISS_FRAME_CNT</name>
          <description>DMA Channel 0 Dropped Packet Counter Register</description>
          <addressOffset>0x1164</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MFCO</name>
              <description>Overflow status of the MFC Counter
When this bit is set then the MFC counter does not get incrementedfurther. The bit gets cleared when this register is read.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Miss frame counter overflow not occurred</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Miss frame counter overflow occurred</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFC</name>
              <description>Dropped Packet Counters
This counter indicates the number of packet counters that are dropped by the DMA either because of bus error or because of programingthe ETH_DMA_CH0_CONTROL[RPF] field. The counter gets cleared when this register is read.
Access restriction applies. Clears on read. Self-set to 1 on internal event.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_DMA_CH0_RX_ERI_CNT</name>
          <description>DMA Channel 0 Receive ERI Counter Register</description>
          <addressOffset>0x1168</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECNT</name>
              <description>ERI Counter</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDMMC</name>
      <baseAddress>0x48102000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>3952</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>SDMMC_IRQ</name>
        <description>SDMMC Interrupt request</description>
        <value>102</value>
      </interrupt>
      <interrupt>
        <name>SDMMC_WAKEUP_IRQ</name>
        <description>SDMMC Wakeup event interrupt request</description>
        <value>103</value>
      </interrupt>
      <registers>
        <register>
          <name>SDMMC_SDMASA_R</name>
          <description>SDMA System Address Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCKCNT_SDMASA</name>
              <description>32-bit Block Count-SDMA System Address.
SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0: The BLOCKCNT_SDMASA bit field contains the system memory address for an SDMA transfer in the 32-bit addressing Mode. When the Host Controller stops an SDMA transfer, this bit field points to the system address of the next contiguous data position. It can be accessed only if no transaction is executing. Reading this bit field during data transfers may return invalid value.
32-bit Block Count
SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x1: From the Host Controller Version 4.10 Specification, the BLOCKCNT_SDMASA bit field is redefined as 32-bit Block Count. The Host Controller decrements the block count of this bit field for every block transfer and the data transfer stops when the count reaches zero. This bit field must be accessed when no transaction is executing. Reading this bit field during data transfers may return invalid value.
Note: For the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0, the Host Driver does not program the system address in this bit field while operating in ADMA mode. The system address must be programmed in the ADMA System Address register (SDMMC_ADMA_SA_LOW_R).
For the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0, the Host Driver programs a non-zero 32-bit block count value in this bit field when Auto CMD23 is enabled for non-DMA and ADMA modes. Auto CMD23 cannot be used with SDMA.
This bit field must be programmed with a non-zero value for data transfer if the 32-bit Block Count register is used instead of the 16-bit Block Count register (SDMMC_BLOCKCOUNT_R).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0xFFFFFFFF</name>
                  <description>4GB-1 Block</description>
                  <value>0xFFFFFFFF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x00000002</name>
                  <description>2 Blocks</description>
                  <value>0x00000002</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x00000001</name>
                  <description>1 Block</description>
                  <value>0x00000001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x00000000</name>
                  <description>Stop count</description>
                  <value>0x00000000</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BLOCKSIZE_R</name>
          <description>Block Size Register</description>
          <addressOffset>0x4</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SDMA_BUF_BDARY</name>
              <description>SDMA Buffer Boundary.
These bits specify the size of a contiguous buffer in the system memory. The SDMA transfer waits at every boundary specified by these bits and the Host Controller generates the DMA interrupt to request the Host Driver to update the SDMMC_SDMASA_R register.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>4KB Bytes SDMA buffer boundary</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8KB Bytes SDMA buffer boundary</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>16KB Bytes SDMA buffer boundary</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>32KB Bytes SDMA buffer boundary</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>64KB Bytes SDMA buffer boundary</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>128KB Bytes SDMA buffer boundary</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>256KB Bytes SDMA buffer boundary</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>512KB Bytes SDMA buffer boundary</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_BLOCK_SIZE</name>
              <description>Transfer Block Size.
These bits specify the block size of data transfers. In case of memory, it is set to 512 bytes. It can be accessed only if no transaction is executing. Read operations during transfers may return an invalid value, and write operations are ignored. Following are the values for this bit field:</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 Byte</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 Bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>3 Bytes</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1FF</name>
                  <description>511 Byte</description>
                  <value>0x1FF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x200</name>
                  <description>512 Bytes</description>
                  <value>0x200</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x800</name>
                  <description>2048 Bytes</description>
                  <value>0x800</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BLOCKCOUNT_R</name>
          <description>16-bit Block Count Register</description>
          <addressOffset>0x6</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCK_CNT</name>
              <description>16-bit Block Count.
If the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x0 or this bit field is set to non-zero, the 16-bit Block Count register is selected.
If the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x1 and this bit field is set to zero, the 32-bit Block Count register is selected.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop count</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 Block</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 Blocks</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFFFF</name>
                  <description>65535 Blocks</description>
                  <value>0xFFFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ARGUMENT_R</name>
          <description>Argument Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARGUMENT</name>
              <description>Command Argument.
These bits specify the SD or eMMC command argument that is specified in bits 39 to 8 of the Command Format.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_XFER_MODE_R</name>
          <description>Transfer Mode Register</description>
          <addressOffset>0xC</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RESP_INT_DISABLE</name>
              <description>Response Interrupt Disable.
The Host Controller supports response check function to avoid overhead of response error check by the Host Driver. Response types of only R1 and R5 can be checked by the Host Controller.
If the Host Driver checks the response error, this bit should be set to 0x0 and wait for Command Complete interrupt and then check the respective response register (SDMMC_RESP01_R, SDMMC_RESP23_R, SDMMC_RESP45_R, and SDMMC_RESP67_R).
If the Host Controller checks the response error, this bit and the SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE] bit should be set to 0x1. The Command Complete interrupt is disabled by this bit regardless of the Command Complete Signal Enable (SDMMC_NORMAL_INT_SIGNAL_EN_R[CMD_COMPLETE_SIGNAL_EN]).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Response interrupt is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response interrupt is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR_CHK_ENABLE</name>
              <description>Response Error Check Enable.
The Host Controller supports response check function to avoid overhead of response error check by the Host Driver. Response types of only R1 and R5 can be checked by the Controller. If the Host Controller checks the response error, this bit and the SDMMC_XFER_MODE_R[RESP_INT_DISABLE] bit should be set to 0x1. If an error is detected, the Response Error interrupt is generated (see SDMMC_ERROR_INT_STAT_R[RESP_ERR] bit).
Note: Response error check must not be enabled for any response types other than R1 and R5.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Response Error Check is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response Error Check is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_TYPE</name>
              <description>Response Type R1/R5.
This bit selects either R1 or R5 as a response type when the Response Error Check is selected (SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE]).
Error statuses checked in R1:
- OUT_OF_RANGE
- ADDRESS_ERROR
- BLOCK_LEN_ERROR
- WP_VIOLATION
- CARD_IS_LOCKED
- COM_CRC_ERROR
- CARD_ECC_FAILED
- CC_ERROR
- ERROR
- COM_CRC_ERROR
- ERROR
- FUNCTION_NUMBER
- OUT_OF_RANGE</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R1 (Memory)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R5 (SDIO)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MULTI_BLK_SEL</name>
              <description>Multi/Single Block Select.
This bit is set when issuing multiple-block transfer commands using the DAT line. If this bit is set to 0x0, it is not necessary to set the SDMMC_BLOCKCOUNT_R register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Single block</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Multiple block</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_XFER_DIR</name>
              <description>Data Transfer Direction Select.
This bit defines the direction of the DAT line data transfers. This bit is set to 0x1 by the Host Driver to transfer data from the SD or eMMC card to the Host Controller and it is set to 0x0 for all other commands.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write (Host to Card)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read (Card to Host)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ENABLE</name>
              <description>Auto Command Enable.
This bit field determines use of Auto Command functions.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto Command disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD12 enable</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Auto CMD23 enable</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Auto CMD Auto select</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLOCK_COUNT_ENABLE</name>
              <description>Block Count Enable.
This bit is used to enable the SDMMC_BLOCKCOUNT_R register, which is relevant for multiple block transfers. If this bit is set to 0x0, the SDMMC_BLOCKCOUNT_R register is disabled, which is useful in executing an infinite transfer. The Host Driver must set this bit to 0x0 when ADMA is used.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_ENABLE</name>
              <description>DMA Enable.
This bit enables the DMA functionality. If this bit is set to 0x1, a DMA operation begins when the Host Driver writes to the SDMMC_CMD_R register. One of the DMA modes can be selected by setting the SDMMC_HOST_CTRL1_R[DMA_SEL] bit field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No data transfer or non-DMA data transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA data transfer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CMD_R</name>
          <description>Command Register</description>
          <addressOffset>0xE</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_INDEX</name>
              <description>Command Index.
These bits are set to the command number that is specified in bits 45 to 40 of the Command Format.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_TYPE</name>
              <description>Command Type.
These bits indicate the command type.
Note: While issuing Abort CMD using CMD12/CMD52 or reset CMD using CMD0/CMD52, CMD_TYPE, these bits must be set to 0x3.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Suspend</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Resume</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Abort</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_PRESENT_SEL</name>
              <description>Data Present Select.
This bit is set to 0x1 to indicate that data is present and that the data is transferred using the DAT line. This bit is set to 0x0 in the following instances:
- Command using the CMD line
- Command with no data transfer but using busy signal on the DAT[0] line
- Resume Command</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No data present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data present</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_CHK_ENABLE</name>
              <description>Command Index Check Enable.
This bit enables the Host Controller to check the index field in the response to verify if it has the same value as the command index. If the value is not the same, it is reported as a Command Index error.
Note: Index Check enable must be set to 0x0 for the command with no response, R2 response, R3 response and R4 response.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_CHK_ENABLE</name>
              <description>Command CRC Check Enable.
This bit enables the Host Controller to check the CRC field in the response. If an error is detected, it is reported as a Command CRC error.
Note: CRC Check enable must be set to 0x0 for the command with no response, R3 response, and R4 response.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUB_CMD_FLAG</name>
              <description>Sub-command Flag.
This bit distinguishes between a main command and a Sub-command.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Main command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sub-command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_TYPE_SELECT</name>
              <description>Response Type Select.
This bit field indicates the type of response expected from the card.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No response</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response length 136</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Response length 48</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Response length 48; Check busy after response</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP01_R</name>
          <description>Response Register 0/1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP01</name>
              <description>Command Response.
These bits reflect 39 to 8 bits of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP23_R</name>
          <description>Response Register 2/3</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP23</name>
              <description>Command Response.
These bits reflect 71 to 40 bits of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP45_R</name>
          <description>Response Register 4/5</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP45</name>
              <description>Command Response.
These bits reflect 103 to 72 bits of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_RESP67_R</name>
          <description>Response Register 6/7</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP67</name>
              <description>Command Response.
These bits reflect bits 135 to 104 of the SD or eMMC response field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BUF_DATA_R</name>
          <description>Buffer Data Port Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUF_DATA</name>
              <description>Buffer Data.
These bits enable access to the Host Controller packet buffer.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PSTATE_REG</name>
          <description>Present State Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IN_DORMANT_ST</name>
              <description>In Dormant Status.
for both SD or eMMC modes, this bit always returns 0x0.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not in Dormant state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>In Dormant state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUB_CMD_STAT</name>
              <description>Sub-command Status.
This bit is used to distinguish between a main command and a Sub-command status.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Main command status</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sub-command status</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_ISSUE_ERR</name>
              <description>Command Not Issued by Error.
This bit is set if a command cannot be issued after setting the SDMMC_CMD_R register due to an error except the Auto CMD12 error.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error for issuing a command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command cannot be issued</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_LINE_LVL</name>
              <description>Command-Line Signal Level.
This bit is used to check the CMD line level to recover from errors and for debugging. These bits reflect the value of the SD_CMD input signal.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_3_0</name>
              <description>DAT[3-0] Line Signal Level.
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the SD_D[0-3] input (lower nibble) signals.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PROTECT_SW_LVL</name>
              <description>Write Protect Switch Pin Level.
This bit is supported only for memory and combo cards. This bit reflects the synchronized value of the card write protect signal.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write protected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Write enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_DETECT_PIN_LEVEL</name>
              <description>Card Detect Pin Level.
This bit reflects the inverse synchronized value of the card detect signal.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No card present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card present</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_STABLE</name>
              <description>Card Stable.
This bit indicates the stability of the Card Detect Pin Level (see CARD_DETECT_PIN_LEVEL bit). A card is not detected if this bit is set to 0x1 and the value of the CARD_INSERTED bit is 0x0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset or debouncing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>No card or Inserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTED</name>
              <description>Card Inserted.
This bit indicates whether a card has been inserted. The Host Controller debounces this signal so that Host Driver need not wait for it to stabilize.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset, debouncing, or no card</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card inserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_ENABLE</name>
              <description>Buffer Read Enable.
This bit is used for non-DMA transfers. This bit is set if valid data exists in the Host buffer.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Read disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Read enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_ENABLE</name>
              <description>Buffer Write Enable.
This bit is used for non-DMA transfers. This bit is set if space is available for writing data.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Write disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Write enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_XFER_ACTIVE</name>
              <description>Read Transfer Active.
This bit indicates whether a read transfer is active for both SD or eMMC modes.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No valid data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transferring data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WR_XFER_ACTIVE</name>
              <description>Write Transfer Active.
This status indicates whether a write transfer is active for both SD or eMMC modes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No valid data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transferring data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAT_7_4</name>
              <description>DAT[7-4] Line Signal Level.
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the SD_D[7-4] input (upper nibble) signals.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_LINE_ACTIVE</name>
              <description>DAT Line Active (SD or eMMC mode only).
This bit indicates whether one of the DAT lines on the SD or eMMC bus is in use.
In the case of read transactions, this bit indicates whether a read transfer is executing on the SD or eMMC bus.
In the case of write transactions, this bit indicates whether a write transfer is executing on the SD or eMMC bus.
For a command with busy, this status indicates whether the command executing busy is executing on an SD or eMMC bus.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DAT line inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DAT line active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_INHIBIT_DAT</name>
              <description>Command Inhibit for DAT line
This bit is applicable for both SD or eMMC modes and is generated if either DAT line active or Read transfer active is set to 0x1. If this bit is set to 0x0, it indicates that the Host Controller can issue subsequent SD or eMMC commands.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Can issue command which used DAT line</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Cannot issue command which used DAT line</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_INHIBIT</name>
              <description>Command Inhibit for CMD line
This bit indicates the following:
SD or eMMC mode: If this bit is set to 0x0, it indicates that the CMD line is not in use and the Host controller can issue an SD or eMMC command using the CMD line. This bit is set when the SDMMC_CMD_R register is written. This bit is cleared when the command response is received. This bit is not cleared by the response of auto CMD12/23 but cleared by the response of read/write command.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host Controller is ready to issue a command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host Controller is not ready to issue a command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_HOST_CTRL1_R</name>
          <description>Host Control 1 Register</description>
          <addressOffset>0x28</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CARD_DETECT_SIG_SEL</name>
              <description>Card Detect Signal Selection.
This bit selects a source for card detection. When the source for the card detection is switched, the interrupt must be disabled during the switching period.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card detect signal is selected (for normal use)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card detect test level is selected (for test purpose)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_DETECT_TEST_LVL</name>
              <description>Card Detect Test Level.
This bit is enabled while the SDMMC_HOST_CTRL1_R[CARD_DETECT_SIG_SEL] bit is set to 0x1 and it indicates whether a card inserted or not.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No card</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card inserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXT_DAT_XFER</name>
              <description>Extended Data Transfer Width.
This bit controls 8-bit bus width mode of embedded device.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Bus width is selected by the SDMMC_HOST_CTRL1_R [DAT_XFER_WIDTH] bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8-bit bus width</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_SEL</name>
              <description>DMA Select.
This field is used to select the DMA type.
When the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x1:
0x0: SDMA is selected
0x1: Reserved
0x2: ADMA2 is selected
0x3: ADMA2 or ADMA3 is selected
When the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x0:
0x0: SDMA is selected
0x1: Reserved
0x2: 32-bit Address ADMA2 is selected
0x3: 64-bit Address ADMA2 is selected</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAT_XFER_WIDTH</name>
              <description>Data Transfer Width.
For both SD or eMMC modes, this bit selects the data transfer width of the Host Controller. The Host Driver sets it to match the data width of the SD or eMMC card.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1-bit mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LED_CTRL</name>
              <description>LED Control.
This bit is used to caution not to remove the card while the SD card is being accessed. The value is reflected on the led control signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LED off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LED on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PWR_CTRL_R</name>
          <description>Power Control Register</description>
          <addressOffset>0x29</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SD_BUS_VOL_VDD2</name>
              <description>SD Bus Voltage Select for VDD2.
 This is irrelevant for SD and eMMC card.</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>VDD2 Not Supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>1.8 V</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Not used</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Not used</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_BUS_PWR_VDD2</name>
              <description>SD Bus Power for VDD2.
 This is irrelevant for SD and eMMC card.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_BUS_VOL_VDD1</name>
              <description>SD Bus Voltage Select for VDD1/eMMC Bus Voltage Select for VDD.
These bits enable the Host Driver to select the voltage level for an SD or eMMC card. Before setting these bits, the Host Driver checks the Voltage Support bits in the Capabilities register (SDMMC_CAPABILITIES1_R and SDMMC_CAPABILITIES2_R). If an unsupported voltage is selected, the Host System does not supply the SD Bus voltage. The value set in this field is available on the SDMMC output signal, which is used by the voltage switching circuitry.
SD Bus Voltage Select options:
0x0 - 0x4: Reserved
0x5: 1.8 V (Typical) for Embedded
0x6: 3.0 V (Typical)
0x7: 3.3 V (Typical)
eMMC Bus Voltage Select options:
0x0 - 0x4: Reserved
0x5: 1.2 V (Typical)
0x6: 1.8 V (Typical)
0x7: 3.3 V (Typical)</description>
              <bitRange>[3:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SD_BUS_PWR_VDD1</name>
              <description>SD Bus Power for VDD1.
It can be used to control the VDD1 power supply of the card. Before setting this bit, the SD Host Driver sets the SD Bus Voltage Select bit. If the Host Controller detects a No Card state, this bit is cleared.
In SD mode, if this bit is cleared, the Host Controller stops the SD clock by clearing the SDMMC_CLK_CTRL_R[SD_CLK_IN] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BGAP_CTRL_R</name>
          <description>Block Gap Control Register</description>
          <addressOffset>0x2A</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT_AT_BGAP</name>
              <description>Interrupt at Block Gap.
This bit is valid only in the 4-bit mode of an SDIO card and is used to select a sample point in the interrupt cycle. Setting this bit to 0x1 enables interrupt detection at the block gap for a multiple block transfer.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_WAIT_CTRL</name>
              <description>Read Wait Control.
This bit is used to enable the read wait protocol to stop read data using SD_D[2] line if the card supports read wait. Otherwise, the Host Controller has to stop the card clock to hold the read data.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable read wait control</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable read wait control</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONTINUE_REQ</name>
              <description>Continue Request.
This bit is used to restart the transaction, which was stopped using the Stop at Block Gap Request (SDMMC_BGAP_CTRL_R[STOP_BG_REQ]). The Host Controller automatically clears this bit when the transaction restarts. If stop at block gap request is set to 0x1, any write to this bit is ignored.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No affect</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Restart</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_BG_REQ</name>
              <description>Stop at Block Gap Request.
This bit is used to stop executing read and write transactions at the next block gap for non-DMA, SDMA, and ADMA transfers.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transfer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Stop</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_WUP_CTRL_R</name>
          <description>Wakeup Control Register</description>
          <addressOffset>0x2B</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CARD_REMOVAL</name>
              <description>Wakeup Event Enable on SD Card Removal.
This bit enables wakeup event through Card Removal assertion in the SDMMC_NORMAL_INT_STAT_EN_R register. For the SDIO card, wake up support in the Card Information Structure (CIS) register does not affect this bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERT</name>
              <description>Wakeup Event Enable on SD Card Insertion.
This bit enables wakeup event through Card Insertion assertion in the SDMMC_NORMAL_INT_STAT_EN_R register. Wake Up Support in CIS register does not affect this bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INT</name>
              <description>Wakeup Event Enable on Card Interrupt.
This bit enables wakeup event through a Card Interrupt assertion in the SDMMC_NORMAL_INT_STAT_EN_R register. This bit can be set to 0x1 if Wake Up Support in CIS register is set to 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CLK_CTRL_R</name>
          <description>Clock Control Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FREQ_SEL</name>
              <description>SD_CLK Frequency Select.
These bits are used to select the frequency of the SD_CLK signal. These bits depend on setting of the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] bit. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x0, these bits are set by the Host Driver. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x1, these bits are automatically set to a value specified in one of the Preset Value register.
10-bit Divided Clock Mode:
0x000: Base clock
0x001: 1/2 Divided clock
0x002: 1/4 Divided clock
...
N: 1/2N Divided clock
...
0x3FF: 1/2046 Divided clock
Programmable Clock mode (enables the Host System to select a fine grain SD clock frequency):
0x000: Base clock x M
0x001: Base clock x M/2
0x002: Base clock x M/3
...
N-1: Base clock x M/N
...
0x3FF: Base clock x M/1024</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPPER_FREQ_SEL</name>
              <description>These bits specify the upper 2 bits of 10-bit SD_CLK Frequency Select control (FREQ_SEL bit field).</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GEN_SELECT</name>
              <description>Clock Generator Select.
This bit is used to select the clock generator mode in SD_CLK Frequency Select-FREQ_SEL bit. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x0, this bit is set by the Host Driver. If the SDMMC_HOST_CTRL2_R[PRESET_VAL_ENABLE] = 0x1, this bit is automatically set to a value specified in one of the Preset Value registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divided clock mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL_ENABLE</name>
              <description>PLL Enable.
This bit is used to activate the PLL (applicable when the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x1).
When the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x0, the INTERNAL_CLK_EN bit may be used to activate PLL.
Note: If this bit is not used to active the PLL when the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] = 0x1, it is recommended to set it to 0x1.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PLL is in low power mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>PLL is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_CLK_EN</name>
              <description>SD or eMMC Clock Enable.
This bit stops the SD_CLK when is set to 0x0. The FREQ_SEL bit field can be changed when this bit is set to 0x0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable providing SD_CLK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable providing SD_CLK</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTERNAL_CLK_STABLE</name>
              <description>Internal Clock Stable.
This bit enables the Host Driver to check the clock stability twice after the SDMMC_CLK_CTRL_R[INTERNAL_CLK_EN] bit is set and after both INTERNAL_CLK_EN and PLL_ENABLE bits are set.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not ready</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTERNAL_CLK_EN</name>
              <description>Internal Clock Enable.
This bit is set to 0x0 when the Host Driver is not using the Host Controller or the Host Controller awaits a wakeup interrupt. The Host Controller must stop its internal clock to enter a very low power state. However, registers can still be read and written to.
Note: If this bit is not used to control the internal clock (base clock and master clock), it is recommended to set it to 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Oscillate</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_TOUT_CTRL_R</name>
          <description>Timeout Control Register</description>
          <addressOffset>0x2E</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TOUT_CNT</name>
              <description>Data Timeout Counter Value.
This value determines the interval by which DAT line timeouts are detected. The timeout clock frequency is generated by dividing the base clock (BCLK) value by this value. When setting this bit field, the user should prevent inadvertent timeout events by clearing the SDMMC_ERROR_INT_STAT_EN_R[DATA_TOUT_ERR_STAT_EN] bit.
The values for these bits are:
Note: During a boot operating in an eMMC mode, an application must configure the boot data timeout value (approximately 1 second) in this bit field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TMCLK x 2^13</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TMCLK x 2^14</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>TMCLK x 2^27</description>
                  <value>0xE</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_SW_RST_R</name>
          <description>Software Reset Register</description>
          <addressOffset>0x2F</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SW_RST_DAT</name>
              <description>Software Reset for DAT line.
This bit is used in SD or eMMC modes and it resets only a part of the data circuit and the DMA circuit is also reset.
The following registers and bits are cleared by this bit:
SDMMC_BUF_DATA_R register:
- Buffer is cleared and initialized.
SDMMC_PSTATE_REG register:
- Buffer Read Enable
- Buffer Write Enable
- Read Transfer Active
- Write Transfer Active
- DAT Line Active
- Command Inhibit (DAT)
SDMMC_BGAP_CTRL_R register:
- Continue Request
- Stop at Block Gap Request
SDMMC_NORMAL_INT_STAT_EN_R register:
- Buffer Read Ready
- Buffer Write Ready
- DMA Interrupt
- Block Gap Event
- Transfer Complete</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Work</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RST_CMD</name>
              <description>Software Reset for CMD line.
This bit resets only a part of the command circuit to be able to issue a command. This reset is effective only for a command issuing circuit (including response error statuses related to Command Inhibit for CMD line control) and does not affect the data transfer circuit. Host Controller can continue data transfer even after this reset is executed while handling subcommand-response errors.
The following registers and bits are cleared by this bit:
- SDMMC_PSTATE_REG register: CMD_INHIBIT bit
- SDMMC_NORMAL_INT_STAT_EN_R register: Command Complete bit
- SDMMC_ERROR_INT_STAT_EN_R register: Response error statuses related to CMD_INHIBIT bit</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Work</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RST_ALL</name>
              <description>Software Reset for All.
This reset affects the entire Host Controller except for the card detection circuit. During its initialization, the Host Driver sets this bit to 0x1 to reset the Host Controller. All registers are reset except the capabilities register (SDMMC_CAPABILITIES1_R and SDMMC_CAPABILITIES2_R). If this bit is set to 0x1, the Host Driver must issue reset command and reinitialize the card.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Work</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_NORMAL_INT_STAT_R</name>
          <description>Normal Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_INTERRUPT</name>
              <description>Error Interrupt.
If any of the operating bits in the SDMMC_ERROR_INT_STAT_R register are set, then this bit is set.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FX_EVENT</name>
              <description>FX Event.
This status is set when R[14] of response register is set to 0x1 and Response Type R1/R5 is set to 0x0 in the SDMMC_XFER_MODE_R register. This interrupt is used with response check function.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>FX Event is detected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_C</name>
              <description>INT_C (Embedded).
This bit is set if INT_C is enabled.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT_B</name>
              <description>INT_B (Embedded).
This bit is set if INT_B is enabled.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT_A</name>
              <description>INT_A (Embedded).
This bit is set if INT_A is enabled.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CARD_INTERRUPT</name>
              <description>Card Interrupt.
This bit reflects the synchronized value of DAT[1] Interrupt input for SD mode</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No card interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Generate card Interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_REMOVAL</name>
              <description>Card Removal.
This bit is set if the Card Inserted in the Present State register changes from 0x1 to 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card state stable or debouncing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card removed. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTION</name>
              <description>Card Insertion.
This bit is set if the Card Inserted in the Present State register changes from 0x0 to 0x1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card state stable or debouncing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card inserted. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_READY</name>
              <description>Buffer Read Ready.
This bit is set if the SDMMC_PSTATE_REG[BUF_RD_ENABLE] bit changes from 0x0 to 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not ready to read buffer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to read buffer. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_READY</name>
              <description>Buffer Write Ready.
This bit is set if the SDMMC_PSTATE_REG[BUF_WR_ENABLE] bit changes from 0x0 to 0x1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not ready to write buffer</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ready to write buffer. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_INTERRUPT</name>
              <description>DMA Interrupt.
This bit is set if the Host Controller detects the SDMA Buffer Boundary during transfer (refer to SDMMC_BLOCKSIZE_R). In case of ADMA, by setting the Interrupt field in the descriptor table, the Host Controller generates this interrupt. This interrupt is not generated after a Transfer Complete.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No DMA interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA Interrupt is generated. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BGAP_EVENT</name>
              <description>Block Gap Event.
This bit is set when both read and write transaction is stopped at block gap due to a Stop at Block Gap Request (SDMMC_BGAP_CTRL_R[STOP_BG_REQ]).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No block gap event</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transaction stopped at block gap. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_COMPLETE</name>
              <description>Transfer Complete.
This bit is set when a read and write transfer and a command with status busy is completed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not complete</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command execution is completed. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_COMPLETE</name>
              <description>Command Complete.
In both SD and eMMC modes, this bit is set when the end bit of a response except for Auto CMD12 and Auto CMD23.
This interrupt is not generated when the SDMMC_XFER_MODE_R[RESP_INT_DISABLE] bit is set to 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No command complete</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command complete. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ERROR_INT_STAT_R</name>
          <description>Error Interrupt Status Register</description>
          <addressOffset>0x32</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VENDOR_ERR3</name>
              <description>Reserved. It always returns 0x0.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VENDOR_ERR2</name>
              <description>Reserved. It always returns 0x0.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VENDOR_ERR1</name>
              <description>Reserved. It always returns 0x0.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BOOT_ACK_ERR</name>
              <description>Boot Acknowledgement Error.
This bit is set when there is a timeout for boot acknowledgement or when detecting boot ACK status having a value other than 0x0. This is applicable only when boot acknowledgement is expected in eMMC mode.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR</name>
              <description>Response Error.
Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by the Host Driver during DMA execution. If the SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE] bit is set to 0x1, the Host Controller checks R1 or R5 response. If an error is detected in a response, this bit is set to 0x1. This is applicable in SD or eMMC modes.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR</name>
              <description>ADMA Error.
This bit is set when the Host Controller detects error during ADMA-based data transfer. The error could be due to Error response received from System bus (Master interface)-ADMA3, ADMA2 Descriptors invalid</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ERR</name>
              <description>Auto CMD Error.
This error status is used by Auto CMD12 and Auto CMD23 in SD or eMMC modes. This bit is set when detecting that any of the bits D00 to D05 in Auto CMD Error Status register has changed from 0x0 to 0x1. D07 is effective in case of Auto CMD12. The Auto CMD Error Status register is valid while this bit is set to 0x1 and may be cleared by clearing of this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CUR_LMT_ERR</name>
              <description>Current Limit Error.
By setting the SD Bus Power bit in the SDMMC_PWR_CTRL_R register, the Host Controller is requested to supply power for the SD Bus. If the Host Controller supports the Current Limit function, it can be protected from an illegal card by stopping power supply to the card in which case this bit indicates a failure status. A reading of 0x1 for this bit means that the Host Controller is not supplying power to the SD card due to some failure. A reading of 0x0 for this bit means that the Host Controller is supplying power and no error has occurred. The Host Controller may require some sampling time to detect the current limit. If the SDMMC Host Controller does not support this function, this bit is always set to 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power Fail. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_END_BIT_ERR</name>
              <description>Data End Bit Error.
This error occurs in SD or eMMC modes either when detecting 0x0 at the end bit position of read data that uses the DAT line or at the end bit position of the CRC status.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_CRC_ERR</name>
              <description>Data CRC Error.
This error occurs in SD or eMMC modes when detecting CRC error when transferring read data which uses the DAT line, when detecting the Write CRC status having a value of other than 0x0 or when write CRC status timeout.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_TOUT_ERR</name>
              <description>Data Timeout Error.
This bit is set in SD or eMMC modes when detecting one of the following timeout conditions:
- Busy timeout for R1b, R5b type
- Busy timeout after Write CRC status
- Write CRC Status timeout
- Read Data timeout</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Time out. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_ERR</name>
              <description>Command Index Error.
This bit is set if a Command Index error occurs in the command response in SD or eMMC modes.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_BIT_ERR</name>
              <description>Command End Bit Error.
This bit is set when detecting that the end bit of a command response is 0x0 in SD or eMMC modes.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>End bit error generated. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_ERR</name>
              <description>Command CRC Error.
Command CRC Error is generated in SD or eMMC modes for following two cases.
If a response is returned and the Command Timeout Error (SDMMC_ERROR_INT_STAT_R[CMD_TOUT_ERR]) is set to 0x0 (indicating no timeout), this bit is set to 0x1 when detecting a CRC error in the command response.
The Host Controller detects a CMD line conflict by monitoring the CMD line when a command is issued. If the Host Controller drives the CMD line to 0x1 level, but detects 0x0 level on the CMD line at the next SD clock edge, then the Host Controller aborts the command (stop driving CMD line) and set this bit to 0x1. The SDMMC_ERROR_INT_STAT_R[CMD_TOUT_ERR] bit is also set to 0x1 to distinguish a CMD line conflict.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC error generated. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TOUT_ERR</name>
              <description>Command Timeout Error.
 in SD or eMMC modes, this bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command. If the Host Controller detects a CMD line conflict, along with the SDMMC_ERROR_INT_STAT_R[CMD_CRC_ERR] bit, this bit is set to 0x1, without waiting for 64 SD or eMMC card clock cycles.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Time out. Write 0x1 to clear.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_NORMAL_INT_STAT_EN_R</name>
          <description>Normal Interrupt Status Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FX_EVENT_STAT_EN</name>
              <description>FX Event Status Enable.
This bit is added from Version 4.10.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_C_STAT_EN</name>
              <description>INT_C (Embedded) Status Enable.
If this bit is set to 0x0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_B_STAT_EN</name>
              <description>INT_B (Embedded) Status Enable.
If this bit is set to 0x0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_A_STAT_EN</name>
              <description>INT_A (Embedded) Status Enable.
If this bit is set to 0x0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INTERRUPT_STAT_EN</name>
              <description>Card Interrupt Status Enable.
If this bit is set to 0x0, the Host Controller clears the interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 0x1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
By setting this bit to 0x0, interrupt input must be masked by implementation so that the interrupt input is not affected by external signal in any state (for example: floating).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_REMOVAL_STAT_EN</name>
              <description>Card Removal Status Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTION_STAT_EN</name>
              <description>Card Insertion Status Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_READY_STAT_EN</name>
              <description>Buffer Read Ready Status Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_READY_STAT_EN</name>
              <description>Buffer Write Ready Status Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_INTERRUPT_STAT_EN</name>
              <description>DMA Interrupt Status Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BGAP_EVENT_STAT_EN</name>
              <description>Block Gap Event Status Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_COMPLETE_STAT_EN</name>
              <description>Transfer Complete Status Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_COMPLETE_STAT_EN</name>
              <description>Command Complete Status Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ERROR_INT_STAT_EN_R</name>
          <description>Error Interrupt Status Enable Register</description>
          <addressOffset>0x36</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_ACK_ERR_STAT_EN</name>
              <description>Boot Acknowledgment Error (eMMC mode only).
Setting this bit to 0x1 enables setting of Boot Acknowledgment Error in the SDMMC_ERROR_INT_STAT_R register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR_STAT_EN</name>
              <description>Response Error Status Enable (SD mode only).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR_STAT_EN</name>
              <description>ADMA Error Status Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ERR_STAT_EN</name>
              <description>Auto CMD Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CUR_LMT_ERR_STAT_EN</name>
              <description>Current Limit Error Status Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_END_BIT_ERR_STAT_EN</name>
              <description>Data End Bit Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_CRC_ERR_STAT_EN</name>
              <description>Data CRC Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_TOUT_ERR_STAT_EN</name>
              <description>Data Timeout Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_ERR_STAT_EN</name>
              <description>Command Index Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_BIT_ERR_STAT_EN</name>
              <description>Command End Bit Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_ERR_STAT_EN</name>
              <description>Command CRC Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TOUT_ERR_STAT_EN</name>
              <description>Command Timeout Error Status Enable (SD or eMMC mode only).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_NORMAL_INT_SIGNAL_EN_R</name>
          <description>Normal Interrupt Signal Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0x7FFF</resetMask>
          <fields>
            <field>
              <name>FX_EVENT_SIGNAL_EN</name>
              <description>FX Event Signal Enable.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_C_SIGNAL_EN</name>
              <description>INT_C (Embedded) Signal Enable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_B_SIGNAL_EN</name>
              <description>INT_B (Embedded) Signal Enable.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_A_SIGNAL_EN</name>
              <description>INT_A (Embedded) Signal Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INTERRUPT_SIGNAL_EN</name>
              <description>Card Interrupt Signal Enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_REMOVAL_SIGNAL_EN</name>
              <description>Card Removal Signal Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_INSERTION_SIGNAL_EN</name>
              <description>Card Insertion Signal Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_RD_READY_SIGNAL_EN</name>
              <description>Buffer Read Ready Signal Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_WR_READY_SIGNAL_EN</name>
              <description>Buffer Write Ready Signal Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_INTERRUPT_SIGNAL_EN</name>
              <description>DMA Interrupt Signal Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BGAP_EVENT_SIGNAL_EN</name>
              <description>Block Gap Event Signal Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XFER_COMPLETE_SIGNAL_EN</name>
              <description>Transfer Complete Signal Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_COMPLETE_SIGNAL_EN</name>
              <description>Command Complete Signal Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ERROR_INT_SIGNAL_EN_R</name>
          <description>Error Interrupt Signal Enable Register</description>
          <addressOffset>0x3A</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_ACK_ERR_SIGNAL_EN</name>
              <description>Boot Acknowledgment Error (eMMC mode only).
Setting this bit to 0x1 enables generating interrupt signal when Boot Acknowledgement Error in the SDMMC_ERROR_INT_STAT_R register is set.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_ERR_SIGNAL_EN</name>
              <description>Response Error Signal Enable (SD mode only).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR_SIGNAL_EN</name>
              <description>ADMA Error Signal Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_ERR_SIGNAL_EN</name>
              <description>Auto CMD Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CUR_LMT_ERR_SIGNAL_EN</name>
              <description>Current Limit Error Signal Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_END_BIT_ERR_SIGNAL_EN</name>
              <description>Data End Bit Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_CRC_ERR_SIGNAL_EN</name>
              <description>Data CRC Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_TOUT_ERR_SIGNAL_EN</name>
              <description>Data Timeout Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_IDX_ERR_SIGNAL_EN</name>
              <description>Command Index Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_END_BIT_ERR_SIGNAL_EN</name>
              <description>Command End Bit Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CRC_ERR_SIGNAL_EN</name>
              <description>Command CRC Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TOUT_ERR_SIGNAL_EN</name>
              <description>Command Timeout Error Signal Enable (SD or eMMC mode only).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_AUTO_CMD_STAT_R</name>
          <description>Auto CMD Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_NOT_ISSUED_AUTO_CMD12</name>
              <description>Command Not Issued By Auto CMD12 Error.
This bit is set to 0x0 when Auto CMD Error is generated by Auto CMD23.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not issued</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_RESP_ERR</name>
              <description>Auto CMD Response Error.
This bit is set when the SDMMC_XFER_MODE_R[RESP_ERR_CHK_ENABLE] bit is set to 0x1 and an error is detected in R1 response of either Auto CMD12 or CMD13. This status is ignored if any bit between D00 to D04 is set to 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_IDX_ERR</name>
              <description>Auto CMD Index Error.
This bit is set if the command index error occurs in response to a command.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_EBIT_ERR</name>
              <description>Auto CMD End Bit Error.
This bit is set when detecting that the end bit of command response is 0x0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>End bit error generated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_CRC_ERR</name>
              <description>Auto CMD CRC Error.
This bit is set when detecting a CRC error in the command response.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CRC Error Generated</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD_TOUT_ERR</name>
              <description>Auto CMD Timeout Error.
This bit is set if no response is returned with 64 SD_CLK cycles from the end bit of the command.
If this bit is set to 0x1, error status bits (D04 to D01) are meaningless.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Time out</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CMD12_NOT_EXEC</name>
              <description>Auto CMD12 Not Executed.
If multiple memory block data transfer is not started due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12. Setting this bit to 0x1 means that the Host Controller cannot issue Auto CMD12 to stop multiple memory block data transfer, due to some error. If this bit is set to 0x1, error status bits (D04 to D01) is meaningless.
This bit is set to 0x0 when Auto CMD Error is generated by Auto CMD23.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Executed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Not executed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_HOST_CTRL2_R</name>
          <description>Host Control 2 Register</description>
          <addressOffset>0x3E</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PRESET_VAL_ENABLE</name>
              <description>Preset Value Enable.
This bit enables automatic selection of SD_CLK frequency and Driver strength in Preset Value registers. When this bit is set, SD_CLK frequency generation (SDMMC_CLK_CTRL_R[CLK_GEN_SELECT], the SDMMC_CLK_CTRL_R[FREQ_SEL]), and the driver strength selection are performed by the Host Controller. These values are selected from set of Preset Value registers based on selected speed mode.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SD_CLK and driver strength are controlled by Host Driver</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Automatic selection by preset value are enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ASYNC_INT_ENABLE</name>
              <description>Asynchronous Interrupt Enable.
This bit can be set if a card supports asynchronous interrupts and this bit is set to 0x1 in the Capabilities registers (SDMMC_CAPABILITIES1_R and SDMMC_CAPABILITIES2_R).</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDRESSING</name>
              <description>64-bit Addressing.
This bit is effective when the HOST_VER4_ENABLE bit is set to 0x1.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>32 bits addressing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>64 bits addressing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOST_VER4_ENABLE</name>
              <description>Host Version 4 Enable.
This bit selects either Version 3.00 compatible mode or Version 4 mode.
Functions of following fields are modified for Host Version 4 mode:
- SDMA Address: SDMA uses the SDMMC_ADMA_SA_LOW_R register (0x58 - 0x5F) instead of the SDMMC_SDMASA_R register (0x0 - 0x3).
- ADMA2/ADMA3 selection: ADMA3 is selected by the SDMMC_HOST_CTRL1_R[DMA_SEL] bit field.
- 64-bit ADMA Descriptor Size: 128-bit descriptor is used instead of 96-bit descriptor when 64-bit Addressing is set to 0x1.
- Selection of 32-bit/64-bit System Addressing: Either 32-bit or 64-bit system addressing is selected by 64-bit Addressing bit in this register.
- 32-bit Block Count: The SDMMC_SDMASA_R register (0x0 - 0x3) is modified to 32-bit Block Count Register
Note: It is recommended not to program ADMA3 Integrated Descriptor Address registers, while operating in Host version less than 4 mode (HOST_VER4_ENABLE = 0x0).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Version 3.00 compatible mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Version 4 mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD23_ENABLE</name>
              <description>CMD23 Enable.
If the card supports CMD23, this bit is set to 0x1. This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 data transfer.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto CMD23 is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD23 is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA2_LEN_MODE</name>
              <description>ADMA2 Length Mode.
This bit selects ADMA2 Length mode to be either 16-bit or 26-bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>16-bit Data Length mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>26-bit Data Length mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_STRENGTH_SEL</name>
              <description>Driver Strength Select.
This bit is used to select the Host Controller output driver in 1.8 V signaling UHS-I or eMMC speed modes. The bit depends on setting of the PRESET_VAL_ENABLE bit.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver TYPEB is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver TYPEA is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver TYPEC is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver TYPED is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIGNALING_EN</name>
              <description>1.8 V Signaling Enable.
This bit controls voltage regulator for I/O cell in UHS-I or eMMC speed modes. Setting this bit from 0x0 to 0x1 starts changing the signal voltage from 3.3 V to 1.8 V. The Host Controller clears this bit if switching to 1.8 signaling fails.
Note: This bit must be set for all UHS-I speed modes (SDR12/SDR25/SDR50).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3.3 V signalling</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.8 V signalling</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UHS_MODE_SEL</name>
              <description>UHS Mode or eMMC Speed Mode Select.
These bits are used to select UHS mode in the SD mode of operation. In eMMC mode, these bits are used to select eMMC speed mode.
UHS mode (SD mode only):</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SDR12</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDR25</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>SDR50</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CAPABILITIES1_R</name>
          <description>Capabilities 1 Register (0 to 31)</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x274E648A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLOT_TYPE_R</name>
              <description>Slot Type.
These bits indicate usage of a slot by a specific Host System.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Removable card slot</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Embedded slot for one device</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Shared bus slot (SD mode)</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ASYNC_INT_SUPPORT</name>
              <description>Asynchronous Interrupt Support (SD mode only).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Asynchronous interrupt not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Asynchronous interrupt supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS_ADDR_64_V3</name>
              <description>64-bit System Address Support for V3.
This bit sets the Host controller to support 64-bit System Addressing of V3 mode.
SDMA cannot be used in 64-bit Addressing in Version 3 Mode.
If this bit is set to 0x1, 64-bit ADMA2 with using 96-bit Descriptor can be enabled by setting the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit to 0x0 and SDMMC_HOST_CTRL1_R[DMA_SEL] bit field to 0x3.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64-bit System address for V3 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>64-bit System address for V3 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYS_ADDR_64_V4</name>
              <description>64-bit System Address Support for V4.
This bit sets the Host Controller to support 64-bit System Addressing of V4 mode. When this bit is set to 0x1, full or part of 64-bit address must be used to decode the Host Controller registers so that Host Controller registers can be placed above system memory area. 64-bit address decode of Host Controller registers is effective regardless of setting to 64-bit Addressing in the SDMMC_HOST_CTRL2_R register.
If this bit is set to 0x1, 64-bit DMA Addressing for version 4 is enabled by setting the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] and SDMMC_HOST_CTRL2_R[ADDRESSING] bits to 0x1, SDMA can be used and ADMA2 uses 128-bit Descriptor.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>64-bit System address for V4 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>64-bit System address for V4 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOLT_18</name>
              <description>Voltage Support for 1.8 V.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1.8 V not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.8 V supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOLT_30</name>
              <description>Voltage Support for SD 3.0 V or Embedded 1.2 V.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SD 3.0 V or embedded 1.2 V not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SD 3.0 V or embedded supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VOLT_33</name>
              <description>Voltage Support for 3.3 V.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3.3 V not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3.3 V supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUS_RES_SUPPORT</name>
              <description>Suspense/Resume Support.
This bit indicates whether the Host Controller supports Suspend/Resume functionality. If this bit is 0x0, the Host Driver does not issue either Suspend or Resume commands because the Suspend and Resume mechanism is not supported.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SDMA_SUPPORT</name>
              <description>SDMA Support.
This bit indicates whether the Host Controller is capable of using SDMA to transfer data between the system memory and the Host Controller directly.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SDMA not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDMA supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HIGH_SPEED_SUPPORT</name>
              <description>High Speed Support.
This bit indicates whether the Host Controller and the Host System supports High Speed mode and they can supply the SD Clock frequency from 25 MHz to 50 MHz.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>High speed not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>High speed supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA2_SUPPORT</name>
              <description>ADMA2 Support.
This bit indicates whether the Host Controller is capable of using ADMA2.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ADMA2 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADMA2 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EMBEDDED_8_BIT</name>
              <description>8-bit Support for Embedded Device.
This bit indicates whether the Host Controller is capable of using an 8-bit bus width mode. This bit is not effective when the SLOT_TYPE_R bit is set to 0x2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8-bit bus width not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8-bit bus width supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_BLK_LEN</name>
              <description>Maximum Block Length.
This bit indicates the maximum block size that the Host Driver can read and write to the buffer in the Host Controller. The buffer transfers this block size without wait cycles. The transfer block length is always 512 Bytes for the SD Memory irrespective of this bit.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>512 Bytes</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1024 Bytes</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2048 Bytes</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BASE_CLK_FREQ</name>
              <description>Base Clock Frequency for SD Clock.
These bits indicate the base (maximum) clock frequency for the SD Clock. The definition of these bits depend on the Host Controller Version.
6-Bit Base Clock Frequency: This mode is supported by the Host Controller version 1.00 and 2.00. The upper 2 bits are not effective and are always 0x0. The unit values are 1 MHz. The supported clock range is 10 MHz to 63 MHz.
0x0: Get information through another method
0x1: 1 MHz
0x2: 2 MHz
...
0x3F: 63 MHz
0x40 - 0xFF: Not supported
8-Bit Base Clock Frequency: This mode is supported by the Host Controller version 3.00. The unit values are 1 MHz. The supported clock range is 10 MHz to 255 MHz.
0x0: Get information through another method
0x1: MHz
0x2: 2 MHz
...
0xFF: 255 MHz</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_CLK_UNIT</name>
              <description>Timeout Clock Unit.
This bit shows the unit of base clock frequency used to detect Data Timeout Error.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>kHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOUT_CLK_FREQ</name>
              <description>Timeout Clock Frequency.
This bit shows the base clock frequency used to detect Data Timeout Error. The Timeout Clock unit defines the unit of timeout clock frequency. It can be kHz or MHz.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Get information through another method</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 kHz / 1 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 kHz / 2 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>3 kHz / 3 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3F</name>
                  <description>63 kHz / 63 MHz</description>
                  <value>0x3F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CAPABILITIES2_R</name>
          <description>Capabilities 2 Register (32 to 63)</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x08000071</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDD2_18V_SUPPORT</name>
              <description>1.8 V VDD2 Support.
This bit indicates support of VDD2 for the Host System.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1.8 V VDD2 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.8 V VDD2 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA3_SUPPORT</name>
              <description>ADMA3 Support.
This bit indicates whether the Host Controller is capable of using ADMA3.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ADMA3 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADMA3 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_MUL</name>
              <description>Clock Multiplier.
These bits indicate the clock multiplier of the programmable clock generator. Setting these bits to 0x0 means that the Host Controller does not support a programmable clock generator.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock multiplier not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock multiplier M = 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock multiplier M = 3</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFF</name>
                  <description>Clock multiplier M = 256</description>
                  <value>0xFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_TYPED</name>
              <description>Driver Type D Support (UHS-I Only).
This bit indicates support of Driver Type D for 1.8 V Signaling.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type D not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type D supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_TYPEC</name>
              <description>Driver Type C Support (UHS-I Only).
This bit indicates support of Driver Type C for 1.8 V Signaling.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type C not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type C supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRV_TYPEA</name>
              <description>Driver Type A Support (UHS-I Only).
This bit indicates support of Driver Type A for 1.8 V Signaling.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type A not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SDR50_SUPPORT</name>
              <description>SDR50 Support (UHS-I Only).
This bit indicates that SDR50 is supported.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SDR50 not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDR50 supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_CURR_CAPABILITIES1_R</name>
          <description>Maximum Current Capabilities 1 Register (0 to 31)</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_CUR_18V</name>
              <description>Maximum Current for 1.8 V.
This bit specifies the card Maximum Current for 1.8 V VDD1 power supply.
0xFF 1020 mA</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Get information through another method</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 mA</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 mA</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>13 mA</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_CUR_30V</name>
              <description>Maximum Current for 3.0 V.
This bit specifies the card Maximum Current for 3.0 V VDD1 power supply.
0xFF 1020 mA</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Get information through another method</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 mA</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 mA</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>13 mA</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_CUR_33V</name>
              <description>Maximum Current for 3.3 V.
This bit specifies the card Maximum Current for 3.3 V VDD1 power supply.
0xFF 1020 mA</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Get information through another method</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 mA</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 mA</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>13 mA</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_FORCE_AUTO_CMD_STAT_R</name>
          <description>Force Event Register for Auto CMD Error Status</description>
          <addressOffset>0x50</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</name>
              <description>Force Event for Command Not Issued By Auto CMD12 Error.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command Not Issued By Auto CMD12 Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_RESP_ERR</name>
              <description>Force Event for Auto CMD Response Error.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Response Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_IDX_ERR</name>
              <description>Force Event for Auto CMD Index Error.</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Index Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_EBIT_ERR</name>
              <description>Force Event for Auto CMD End Bit Error.</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD End Bit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_CRC_ERR</name>
              <description>Force Event for Auto CMD CRC Error.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD CRC Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_TOUT_ERR</name>
              <description>Force Event for Auto CMD Timeout Error.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Timeout Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD12_NOT_EXEC</name>
              <description>Force Event for Auto CMD12 Not Executed.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD12 Not Executed Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_FORCE_ERROR_INT_STAT_R</name>
          <description>Force Event Register for Error Interrupt Status</description>
          <addressOffset>0x52</addressOffset>
          <size>16</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_BOOT_ACK_ERR</name>
              <description>Force Event for Boot ACK Error.</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Boot ACK Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_RESP_ERR</name>
              <description>Force Event for Response Error (SD mode only).</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Response Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_ADMA_ERR</name>
              <description>Force Event for ADMA Error.</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADMA Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_ERR</name>
              <description>Force Event for Auto CMD Error (SD and eMMC modes).</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto CMD Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CUR_LMT_ERR</name>
              <description>Force Event for Current Limit Error.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Current Limit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_DATA_END_BIT_ERR</name>
              <description>Force Event for Data End Bit Error (SD and eMMC modes).</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data End Bit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_DATA_CRC_ERR</name>
              <description>Force Event for Data CRC Error (SD and eMMC modes).</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data CRC Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_DATA_TOUT_ERR</name>
              <description>Force Event for Data Timeout Error (SD and eMMC modes).</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data Timeout Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_IDX_ERR</name>
              <description>Force Event for Command Index Error (SD or eMMC modes).</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command Index Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_END_BIT_ERR</name>
              <description>Force Event for Command End Bit Error (SD and eMMC modes).</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command End Bit Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_CRC_ERR</name>
              <description>Force Event for Command CRC Error (SD and eMMC modes).</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command CRC Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORCE_CMD_TOUT_ERR</name>
              <description>Force Event for Command Timeout Error (SD and eMMC modes).</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not affected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command Timeout Error Status is set</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ADMA_ERR_STAT_R</name>
          <description>ADMA Error Status Register</description>
          <addressOffset>0x54</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ADMA_LEN_ERR</name>
              <description>ADMA Length Mismatch Error States.
This error occurs in the following events:
- While the SDMMC_XFER_MODE_R[BLOCK_COUNT_ENABLE] bit is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length.
- When the total data length cannot be divided by the block length.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADMA_ERR_STATES</name>
              <description>ADMA Error States.
These bits indicate the state of ADMA when an error occurs during ADMA data transfer.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Stop DMA (SYS_ADR register points to a location next to the error descriptor)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fetch Descriptor (SYS_ADR register points to the error descriptor)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Never set this state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Transfer Data (SYS_ADR register points to a location next to the error descriptor)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ADMA_SA_LOW_R</name>
          <description>ADMA System Address Register (Low)</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADMA_SA_LOW</name>
              <description>ADMA System Address.
These bits indicate the lower 32 bits of the ADMA system address.
SDMA: If the SDMMC_HOST_CTRL2_R[HOST_VER4_ENABLE] bit is set to 0x1, this register stores the system address of the data location.
ADMA2: This register stores the byte address of the executing command of the descriptor table.
ADMA3: This register is set by ADMA3. ADMA2 increments the address of this register that points to the next line, every time a Descriptor line is fetched.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_INIT_R</name>
          <description>Register with Preset Value for Initialization</description>
          <addressOffset>0x60</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate that the Driver strength is supported by 1.8 V signaling bus speed modes. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the Host Controller supports a programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host Controller Ver2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock generator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_DS_R</name>
          <description>Register with Preset Value for Default Speed</description>
          <addressOffset>0x62</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported by 1.8 V signaling bus speed modes. This field is meaningless for the Default speed mode as it uses 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the Host Controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host Controller Ver2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock generator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_HS_R</name>
          <description>Register with Preset Value for High Speed</description>
          <addressOffset>0x64</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported by 1.8 V signaling bus speed modes. This field is meaningless for High speed mode as it uses 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the Host Controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host Controller Ver2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock generator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_SDR12_R</name>
          <description>Register with Preset Value for SDR12</description>
          <addressOffset>0x66</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported for the SDR12 bus speed mode. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the Host Controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host Controller Ver2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock generator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_SDR25_R</name>
          <description>Register with Preset Value for SDR25</description>
          <addressOffset>0x68</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate the Driver strength value supported for the SDR25 bus speed mode. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the Host Controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host Controller Ver2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock generator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_PRESET_SDR50_R</name>
          <description>Register with Preset Value for SDR50</description>
          <addressOffset>0x6A</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DRV_SEL_VAL</name>
              <description>Driver Strength Select Value.
These bits indicate Driver strength value supported for SDR50 bus speed mode. These bits are meaningless for 3.3 V signaling.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B is selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D is selected</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value.
This bit is effective when the Host Controller supports programmable clock generator.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host Controller Ver2.0 compatible clock generator</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock generator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SD_CLK Frequency Select Value.
10-bit preset value to be set in the SDMMC_CLK_CTRL_R[FREQ_SEL] bit field described by a Host System.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_ADMA_ID_LOW_R</name>
          <description>ADMA3 Integrated Descriptor Address Register (Low)</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADMA_ID_LOW</name>
              <description>ADMA Integrated Descriptor Address.
These bits indicate the lower 32-bit of the ADMA Integrated Descriptor Address. The start address of Integrated Descriptor is set to these register bits. The ADMA3 fetches one Integrated Descriptor Address and increments these bits to indicate the next Integrated Descriptor Address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_P_VENDOR_SPECIFIC_AREA</name>
          <description>Pointer for Vendor Specific Area 1</description>
          <addressOffset>0xE8</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0500</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>REG_OFFSET_ADDR</name>
              <description>Base offset Address for Vendor Specific registers.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_SLOT_INTR_STATUS_R</name>
          <description>Slot Interrupt Status Register</description>
          <addressOffset>0xFC</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>INTR_SLOT</name>
              <description>Interrupt Signal for each Slot.
These status bits indicate the logical OR of interrupt signal and wakeup signal for each slot. A maximum of 8 slots can be defined. If one interrupt signal is associated with multiple slots, the Host Driver can identify the interrupt that is generated by reading these bits. By a power on reset or by setting the SDMMC_SW_RST_R[SW_RST_ALL] bit, the interrupt signals are de-asserted and this status reads 0x0.
Bit 00: Slot 1
Bit 01: Slot 2
Bit 02: Slot 3
Bit 07: Slot 8</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_HOST_CNTRL_VERS_R</name>
          <description>Host Controller Version Register</description>
          <addressOffset>0xFE</addressOffset>
          <size>16</size>
          <access>read-only</access>
          <resetValue>0x0005</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VENDOR_VERSION_NUM</name>
              <description>Vendor version number</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPEC_VERSION_NUM</name>
              <description>Host controller specification version number</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MSHC_VER_ID_R</name>
          <description>MSHC Version ID Register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3138302A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSHC_VER_ID</name>
              <description>Current release number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MSHC_VER_TYPE_R</name>
          <description>MSHC Version Type Register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x67612A2A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSHC_VER_TYPE</name>
              <description>Current release type</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MSHC_CTRL_R</name>
          <description>SDMMC Host Controller Control Register</description>
          <addressOffset>0x508</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>NEDGE_SMPL_EN</name>
              <description>Samples CMD/DATA with respect to negative edge of CCLK_RX for Low-Speed SDR only support.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Samples CMD/DATA with respect to positive edge of CCLK_RX</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Samples CMD/DATA with respect to negative edge of CCLK_RX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEDGE_DRV_EN</name>
              <description>Launches CMD/DATA with respect to positive edge of CCLK_TX for Low-Speed SDR only support.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Launches CMD/DATA with respect to negative edge of CCLK_TX</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Launches CMD/DATA with respect to positive edge of CCLK_TX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CG_DIS</name>
              <description>Internal Clock Gating Disable Control.
This bit must be used to disable the SDMMC module internal clock gating when required (disabled clocks are not gated). The clocks to the core (except HCLK) must be stopped when programming this bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Internal clock gates are active and clock gating is controlled internally</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Internal clock gating is disabled, clocks are not gated internally</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_CONFLICT_CHECK</name>
              <description>Command Conflict Check.
This bit enables command conflict check.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable command conflict check</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Check for command conflict after 1 card clock cycle</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_MBIU_CTRL_R</name>
          <description>Master Bus Interface Unit Control Register</description>
          <addressOffset>0x510</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x0F</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>BURST_INCR16_EN</name>
              <description>INCR16 Burst.
Controls generation of INCR16 transfers on Master interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB INCR16 burst type is not generated on Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AHB INCR16 burst type can be generated on Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BURST_INCR8_EN</name>
              <description>INCR8 Burst.
Controls generation of INCR8 transfers on Master interface.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB INCR8 burst type is not generated on Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AHB INCR8 burst type can be generated on Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BURST_INCR4_EN</name>
              <description>INCR4 Burst.
Controls generation of INCR4 transfers on Master interface.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB INCR4 burst type is not generated on Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>AHB INCR4 burst type can be generated on Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UNDEFL_INCR_EN</name>
              <description>Undefined INCR Burst.
Controls generation of undefined length INCR transfer on Master interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Undefined INCR type burst is the least preferred burst on AHB Master interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Undefined INCR type burst is the most preferred burst on AHB Master interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_EMMC_CTRL_R</name>
          <description>eMMC Control Register</description>
          <addressOffset>0x52C</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x000C</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>EMMC_RST_N_OE</name>
              <description>Output Enable Control for eMMC Device Reset Signal PAD Control.
This field drives SD_RST output of the SDMMC module.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SD_RST is 0x0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SD_RST is 0x1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EMMC_RST_N</name>
              <description>eMMC Device Reset Signal Control.
This register field controls SD_RST output of the SDMMC module.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset to eMMC device asserted (active low)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset to eMMC device is de-asserted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DISABLE_DATA_CRC_CHK</name>
              <description>Disable Data CRC Check.
This bit controls masking of CRC16 error for Card Write in eMMC mode. This is useful in bus testing (CMD19) for an eMMC device. In bus testing, an eMMC card does not send CRC status for a block, which may generate CRC error. This CRC error can be masked using this bit during bus testing.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DATA CRC check is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DATA CRC check is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_IS_EMMC</name>
              <description>eMMC Card Present.
This bit indicates the type of card connected. An application program this bit based on the card connected to the SDMMC Host Controller.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Card connected to the SDMMC Host Controller is a non-eMMC card</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Card connected to the SDMMC Host Controller is an eMMC card</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_BOOT_CTRL_R</name>
          <description>eMMC Boot Control Register</description>
          <addressOffset>0x52E</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_TOUT_CNT</name>
              <description>Boot ACK Timeout Counter Value.
This value determines the interval by which boot ACK timeout (50 ms) is detected when boot ACK is expected during boot operation.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TMCLK x 2^13</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TMCLK x 2^14</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>TMCLK x 2^27</description>
                  <value>0xE</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_ACK_ENABLE</name>
              <description>Boot Acknowledge Enable.
When this bit set, the SDMMC module checks for boot acknowledge start pattern of 0-1-0 during boot operation. This bit is applicable for both mandatory and alternate boot mode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Boot ACK disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Boot ACK enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VALIDATE_BOOT</name>
              <description>Validate Mandatory Boot Enable Bit.
This bit is used to validate the SDMMC_BOOT_CTRL_R[MAN_BOOT_EN] bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Ignore mandatory boot enable bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Validate mandatory boot enable bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAN_BOOT_EN</name>
              <description>Mandatory Boot Enable.
This bit is used to initiate the mandatory boot operation. The application sets this bit along with the SDMMC_BOOT_CTRL_R[VALIDATE_BOOT] bit. Writing 0x0 is ignored. The SDMMC module clears this bit after the boot transfer is completed or terminated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mandatory boot disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Mandatory boot enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SDMMC_EMBEDDED_CTRL_R</name>
          <description>Embedded Control Register</description>
          <addressOffset>0xF6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BACK_END_PWR_CTRL</name>
              <description>Back-End Power Control (SD Mode).
Each bit of this bit field controls back-end power supply for an embedded device.
Bit 24: Back-End Power for Device 1
Bit 25: Back-End Power for Device 2
Bit 26: Back-End Power for Device 3
Bit 27: Back-End Power for Device 4
Bit 28: Back-End Power for Device 5
Bit 29: Back-End Power for Device 6
Bit 30: Back-End Power for Device 7
Function of each bit is defined as follows:</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Back-End Power is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Back-End Power is supplied</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INT_PIN_SEL</name>
              <description>Interrupt Pin Select.
These bits enable the interrupt pin inputs.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>Interrupts (INT_A, INT_B, INT_C) are disabled</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>INT_A is enabled</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b010</name>
                  <description>INT_B is enabled</description>
                  <value>0b010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>INT_C is enabled</description>
                  <value>0b100</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_PIN_SEL</name>
              <description>Clock Pin Select (SD Mode).
This bit is selected by one of clock pin outputs.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock pins are disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLK[1] is selected</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CLK[2] is selected</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>CLK[7] is selected</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUS_WIDTH_PRESET</name>
              <description>Bus Width Preset (SD Mode).
Each bit of this field specifies the bus width for each embedded device. The shared bus supports mixing of 4-bit and 8-bit bus width devices.
Bit 8: Bus Width Preset for Device 1
Bit 9: Bus Width Preset for Device 2
Bit 10: Bus Width Preset for Device 3
Bit 11: Bus Width Preset for Device 4
Bit 12: Bus Width Preset for Device 5
Bit 13: Bus Width Preset for Device 6
Bit 14: Bus Width Preset for Device 7
Function of each bit is defined as follows:</description>
              <bitRange>[14:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>4-bit bus width mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8-bit bus width mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_INT_PIN</name>
              <description>Number of Interrupt Input Pins.
This field indicates support of interrupt input pins for an embedded system.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_CLK_PIN</name>
              <description>Number of Clock Pins (SD Mode).
This field indicates support of clock pins to select one of devices for shared bus system. Up to 7 clock pins can be supported.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shared bus not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 SD_CLK supported</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 SD_CLK supported</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>7 SD_CLK supported</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPSPI">
      <name>SPI0</name>
      <baseAddress>0x48103000</baseAddress>
      <interrupt>
        <name>SPI0_IRQ</name>
        <description>SPI0 interrupt request</description>
        <value>137</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPSPI">
      <name>SPI1</name>
      <baseAddress>0x48104000</baseAddress>
      <interrupt>
        <name>SPI1_IRQ</name>
        <description>SPI1 interrupt request</description>
        <value>138</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPSPI">
      <name>SPI2</name>
      <baseAddress>0x48105000</baseAddress>
      <interrupt>
        <name>SPI2_IRQ</name>
        <description>SPI2 interrupt request</description>
        <value>139</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPSPI">
      <name>SPI3</name>
      <baseAddress>0x48106000</baseAddress>
      <interrupt>
        <name>SPI3_IRQ</name>
        <description>SPI3 interrupt request</description>
        <value>140</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>CRC0</name>
      <groupName>CRC</groupName>
      <baseAddress>0x48107000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CRC_CONTROL</name>
          <description>CRC Calculation Setup Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REFLECT_CRC</name>
              <description>Reflection of the CRC result as it is read out. An 8-bit CRC value is reflected on [7-0], bit7 to bit0, bit6 to bit1, etc. 16-bit and 32-bit CRC are reflected similarly. </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reflection is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reflection is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT_CRC</name>
              <description>Inverting of each bit of the calculated CRC as it is read out.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The CRC is not inverted.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Each bit is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USE_CUSTOM_POLY</name>
              <description>Use of a custom polynomial for CRC calculations. 
Note: Custom polynomials can only be used for 32-bit CRC algorithms.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Custom polynomial is not used. The algorithm selected in CRC_CONTROL[ALGORITHM_SEL] bit field is used for the CRC calculation.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the use of a custom polynomial. For more information of the supported polynomials and their format, see Section CRC Overview and Section CRC Polynomials.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIT_SWAP</name>
              <description>Bit swapping during CRC calculation.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not swap bits.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Swap the bits within each byte.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYTE_SWAP</name>
              <description>Byte swapping during CRC calculation.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not swap bytes.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Swap the bytes within each word (16-bit and 32-bit calculations only).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALGORITHM_SEL</name>
              <description>Algorithm selection.</description>
              <bitRange>[6:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CRC-8-CCITT</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CRC-16</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CRC-16-CCITT</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>CRC-32</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>CRC-32C</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALGO_SIZE</name>
              <description>Algorithm size selection.
Must program CRC_CONTROL[ALGO_SIZE] = 0x2 when using custom polynomials.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8-bit</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>32-bit</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INIT</name>
              <description>Writing INIT will load seed and polynomial. Reading will always return INIT = 0. 
Bit must always be written to 0x1 before starting CRC calculations.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_SEED</name>
          <description>Seed Value Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEED</name>
              <description>Seed value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POLY_CUSTOM</name>
          <description>Custom Polynomial Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_POLY_CUSTOM</name>
              <description>Bits 31-0 are used for custom 32-bit CRC calculations.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_OUT</name>
          <description>Accumulated CRC Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_OUT</name>
              <description>Bits 31-0 are used for reading out 32-bit CRC calculations. 
Bits 15-0 are used for reading out 16-bit CRCs.
Lowest eight bits 7-0 are used for reading out 8-bit CRCs.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>1</dimIncrement>
          <name>CRC_DATA_IN_8_[%s]</name>
          <description>8-bit Values Register n</description>
          <addressOffset>0x20</addressOffset>
          <size>8</size>
          <access>write-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0x00</resetMask>
          <fields>
            <field>
              <name>CRC_DATA_IN_8</name>
              <description>Data written in this register is for 8-bit and 16-bit calculations, but only 8-bits can be written per beat.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>40</dim>
          <dimIncrement>4</dimIncrement>
          <name>CRC_DATA_IN_32_[%s]</name>
          <description>32-bit Values Register n</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CRC_DATA_IN_32</name>
              <description>Data written in this register is for 32-bit calculations.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CRC0">
      <name>CRC1</name>
      <baseAddress>0x48108000</baseAddress>
    </peripheral>
    <peripheral>
      <name>USB</name>
      <baseAddress>0x48200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>51716</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>USB_IRQ</name>
        <description>USB interrupt</description>
        <value>101</value>
      </interrupt>
      <registers>
        <register>
          <name>CAPLENGTH</name>
          <description>Capability Registers Length</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01100020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCIVERSION</name>
              <description>Host controller interface version number.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CAPLENGTH</name>
              <description>Capability registers length.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCSPARAMS1</name>
          <description>Structural Parameters 1 Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01000140</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAXPORTS</name>
              <description>Number of ports.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXINTRS</name>
              <description>Number of interrupters.</description>
              <bitRange>[18:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXSLOTS</name>
              <description>Number of device slots.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCSPARAMS2</name>
          <description>Structural Parameters 2 Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0C0000F1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAXSCRATCHPADBUFS</name>
              <description>Maximum scratchpad buffers low.
Possible values are from 0x1 to 0x4.</description>
              <bitRange>[31:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPR</name>
              <description>Scratchpad restore.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXSCRATCHPADBUFS_HI</name>
              <description>Maximum scratchpad buffers high.</description>
              <bitRange>[25:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ERSTMAX</name>
              <description>Event ring segment table maximum.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IST</name>
              <description>Isochronous scheduling threshold.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCSPARAMS3</name>
          <description>Structural Parameters 3 Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x07FF000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>U2_DEVICE_EXIT_LAT</name>
              <description>U2 device exit latency.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>U1_DEVICE_EXIT_LAT</name>
              <description>U1 device exit latency.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCCPARAMS1</name>
          <description>Capability Parameters 1 Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0220FE6C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XECP</name>
              <description>xHCI extended capabilities pointer.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAXPSASIZE</name>
              <description>Maximum primary stream array size.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CFC</name>
              <description>Contiguous frame ID capability.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SEC</name>
              <description>Stopped EDLTA capability.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPC</name>
              <description>Short packet capability.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PAE</name>
              <description>Parse all event data.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NSS</name>
              <description>No secondary SID support.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LTC</name>
              <description>Latency tolerance messaging capability.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LHRC</name>
              <description>Light host controller reset capability.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PIND</name>
              <description>Port indicators.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PPC</name>
              <description>Port power control.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CSZ</name>
              <description>Context size.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BNC</name>
              <description>Bandwidth negotiation capability.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AC64</name>
              <description>64-bit addressing capability.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBOFF</name>
          <description>Doorbell Offset</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000480</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOORBELL_ARRAY_OFFSET</name>
              <description>Doorbell array offset.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTSOFF</name>
          <description>Run-time Register Space Offset</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000440</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RUNTIME_REG_SPACE_OFFSET</name>
              <description>Runtime register space offset.</description>
              <bitRange>[31:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HCCPARAMS2</name>
          <description>Host Controller Capability Parameters 2</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000002F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CIC</name>
              <description>Configuration information capability.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LEC</name>
              <description>Large ESIT payload capability.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTC</name>
              <description>Compliance transition capability.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FSC</name>
              <description>Force save context capability.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMC</name>
              <description>Configure endpoint command maximum exit latency too large capability.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>U3C</name>
              <description>U3 entry capability.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GSBUSCFG0</name>
          <description>Global SoC Bus Configuration Register 0</description>
          <addressOffset>0xC100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATRDREQINFO</name>
              <description>Data read request info.
AHB-prot/AXI-cache/OCP-ReqInfo for data read.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESRDREQINFO</name>
              <description>Descriptor read request info.
AHB-prot/AXI-cache/OCP-ReqInfo for descriptor read.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATWRREQINFO</name>
              <description>Data write request info.
AHB-prot/AXI-cache/OCP-ReqInfo for data write.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESWRREQINFO</name>
              <description>Descriptor write request info.
AHB-prot/AXI-cache/OCP-ReqInfo for descriptor write.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATBIGEND</name>
              <description>Data access is big endian.
This bit controls the endian mode for data accesses.
Note: For an AXI master, this bit must be set to 0x0.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Little-endian (default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Big-endian</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DESBIGEND</name>
              <description>Descriptor access is big endian.
This bit controls the endian mode for descriptor accesses.
Data is considered as embedded data in the descriptors in the following cases:
- Device mode: The buffer pointer of a Setup TRB points to the Setup TRB itself. In device mode, if the system uses different endian modes for descriptor and data, software must not use embedded data.
- Host mode: The Immediate Data (IDT) bit in a Transfer TRB is set to 0x1. In host mode, if the system uses different endian modes for data and descriptors, the controller treats embedded data as descriptor (not as data) in terms of endian mode handling. If this is not the expectation of the system, the software must manipulate the embedded data accordingly.
Note: For an AXI master, this bit must be set to 0x0.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Little-endian (default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Big-endian</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INCR256BRSTENA</name>
              <description>INCR256 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 256-beat burst.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR128BRSTENA</name>
              <description>INCR128 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 128-beat burst.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR64BRSTENA</name>
              <description>INCR64 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 64-beat burst.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR32BRSTENA</name>
              <description>INCR32 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 32-beat burst.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR16BRSTENA</name>
              <description>INCR16 burst type enable.
If software set this bit to 0x1, the AXI master uses INCR to do the 16-beat burst.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR8BRSTENA</name>
              <description>INCR8 burst type enable.
If software set this bit to 0x0, the AXI master uses INCR to do the 8-beat burst.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR4BRSTENA</name>
              <description>INCR4 burst type enable.
When this bit is enabled (set to 0x1), the controller is allowed to do bursts of beat length 1, 2, and 4.
It is highly recommended that this bit is enabled to prevent descriptor reads and writes from being broken up into separate transfers.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCRBRSTENA</name>
              <description>Undefined length INCR burst type enable.
This bit determines the set of burst lengths the master interface uses. It works in conjunction with the GSBUSCFG0[7-1] bits enables (INCR256/128/64/32/16/8/4).
ARLEN/AWLEN do not use INCR except in case of non-aligned burst transfers. In the case of address-aligned transfers, they use only the following burst lengths:
- 1
- 2, 4 (if GSBUSCFG0[INCR4BRSTENA] = 0x1)
- 8 (if GSBUSCFG0[INCR8BRSTENA] = 0x1)
- 16 (if GSBUSCFG0[INCR16BRSTENA] = 0x1)
- 32 (if GSBUSCFG0[INCR32BRSTENA] = 0x1)
- 64 (if GSBUSCFG0[INCR64BRSTENA] = 0x1)
- 128 (if GSBUSCFG0[INCR128BRSTENA] = 0x1)
- 256 (if GSBUSCFG0[INCR256BRSTENA] = 0x1)
Note: In case of non-address-aligned transfers, INCR may get generated at the beginning and end of the transfers to align the address boundaries, even though INCR is disabled.
AXI: ARLEN/AWLEN uses any length less than or equal to the largest-enabled burst length of INCR32/64/128/256.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>INCRX burst mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>INCR (undefined length) burst mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GSBUSCFG1</name>
          <description>Global SoC Bus Configuration Register 1</description>
          <addressOffset>0xC104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN1KPAGE</name>
              <description>1KB page boundary.
By default (this bit is disabled) the AXI breaks transfers at the 4KB page boundary. When this bit is enabled, the AXI master (DMA data) breaks transfers at the 1KB page boundary.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PIPETRANSLIMIT</name>
              <description>AXI pipelined transfers burst request limit.
This bit field controls the number of outstanding pipelined transfer requests the AXI master pushes to the AXI slave.
When the AXI master reaches this limit, it does not make any more requests on the AXI ARADDR and AWADDR buses until the associated data phases complete.
This bit field is encoded as follows:</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 request</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 requests</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 requests</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 requests</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16 requests</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GCTL</name>
          <description>Global Core Control Register</description>
          <addressOffset>0xC110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x18612004</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>BYPSSETADDR</name>
              <description>Bypass set address in Device mode.
This bit must be set to 0x0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRMSCLDWN</name>
              <description>Frame scales down.
This bit field scales down device view of a SOF/USOF/ITP duration.
For High Speed (HS) mode:
- Value of 3 implements interval to be 15.625 us
- Value of 2 implements interval to be 31.25 us
- Value of 1 implements interval to be 62.5 us
- Value of 0 implements interval to be 125 us</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRTCAPDIR</name>
              <description>Port capability direction.
Note: For static Host-only/Device-only applications, use DRD Host or DRD Device mode. The combination of this bit filed set to 0x3 with SRP and HNP/RSP disabled is not recommended for these applications.
The sequence for switching modes in DRD Device mode is as follows:
- For switching from Device to Host:
1. Reset the controller using the CORESOFTRESET bit.
2. Set the PRTCAPDIR bit field to 0x1 (Host mode).
3. Reset the host using USBCMD.HCRESET bit.
4. Follow the steps in Section Initializing Host Registers.
- For switching from Host to Device:
1. Reset the controller using the CORESOFTRESET bit.
2. Set the GCTL[PRTCAPDIR] bit field to 0x2 (Device mode).
3. Reset the device by setting the DCTL[CSFTRST] bit.
4. Follow the steps in Section Initializing Registers.
Programming this bit field with random data causes the controller to keep toggling between the Host mode and the Device mode. Bit Bash register testing is not recommended.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>For host configurations</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>For device configurations</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CORESOFTRESET</name>
              <description>Core soft reset.
Clears the interrupts and all the CSRs except the following registers:
- GCTL
- GUCTL
- GSTS
- GSNPSID
- GUID
- GUSB2PHYCFG0
- DCFG
- DCTL
- DEVTEN
- DSTS
Note: This bit is for debug purposes only. Use USBCMD.HCRESET bit in xHCI Mode and the DCTL[SOFTRESET] bit in Device mode for soft reset.
Programming this bit field with random data will reset the internal logic of the host controller. Due to this side effect Bit Bash register testing is not recommended.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No soft reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Soft reset to controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SOFITPSYNC</name>
              <description>Reserved.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMCLKSEL</name>
              <description>RAM clock (RAM_CLK) select.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>AHB bus clock (BUS_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>In Host mode, the controller switches RAM_CLK between MAC2_CLK and BUS_CLK based on the status of the USB ports.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>In Device mode, selects MAC2_CLK as RAM_CLK. In Host mode, controller switches RAM_CLK between MAC2_CLK and BUS_CLK based on the status of the USB ports.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCALEDOWN</name>
              <description>Scale-Down mode.
Keep at 0x0.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISSCRAMBLE</name>
              <description>Disable scrambling.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GBLHIBERNATIONEN</name>
              <description>Hibernation enable status at the global level. 
If hibernation is not enabled through this bit, the PMU immediately accepts the D0 -&gt; D3 and D3 -&gt; D0 power state change requests, but does not save or restore any controller state.
In addition, the PMUs never drive the PHY interfaces and let the controller continue to drive the PHY interfaces.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSBLCLKGTNG</name>
              <description>Disable clock gating.
This bit is set to 0x1 and the controller is in Low-Power mode, internal clock gating is disabled.
This bit can be set to 0x1 after power-on reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GSTS</name>
          <description>Global Status Register</description>
          <addressOffset>0xC118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7E800000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBELT</name>
              <description>Current BELT value.
In Host mode, this bit field indicates the minimum value of all received device BELT values and the BELT value that is set by the Set Latency Tolerance Value command.</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SSIC_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OTG_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BC_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADP_IP</name>
              <description>This bit is not used.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_IP</name>
              <description>Host interrupt pending.
This field indicates that there is a pending interrupt pertaining to xHC in the Host event queue.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVICE_IP</name>
              <description>Device interrupt pending.
This field indicates that there is a pending interrupt pertaining to peripheral (device) operation in the Device event queue.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CSRTIMEOUT</name>
              <description>CSR timeout.
When this bit is set to 0x1, it indicates that the software performed a write or read to a controller register that could not be completed within predefined bus clock cycles (default: 0x1FFFF).
Write 0x1 to clear.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSERRADDRVLD</name>
              <description>Bus error address valid.
Indicates that the Global SoC Bus Error Address register (GBUSERRADDRLO or GBUSERRADDRHI) is valid and reports the first bus address that encounters a bus error. 
Write 0x1 to clear.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CURMOD</name>
              <description>Indicates the current mode of operation.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Device mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GUCTL1</name>
          <description>Global User Control Register 1</description>
          <addressOffset>0xC11C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0004198A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEV_DECOUPLE_L1L2_EVT</name>
              <description>Device decoupled L1/L2 event.
This bit is applicable for Device mode only. If this feature is enabled, L1 suspend and wake events have individual controls to enable/mask them.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in device events L1/L2 events are not decoupled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, L1 and L2 events are separated. Separate event enable bits for L1 suspend and wake events.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTER_SE0_FSLS_EOP</name>
              <description>Filter SE0 detection in FS/LS or EOP.
This bit is applicable for FS/LS operation. If this feature is enabled, then SE0 on the LineState is validated for two consecutive UTMI clock edges for EOP detection. This feature is applicable only in FS in Device mode and FS/LS mode of operation in Host mode.
- Device mode: FS-If this bit is set, then for device LPM handshake, the controller will ignore single SE0 glitch on the LineState during transmit. Only two or more SE0 is considered as a valid EOP on FS.
- Host mode: FS/LS-If FILTER_SE0_FSLS_EOP is set, then the controller will ignore single SE0 glitch on the LineState during transmit. Only two or more SE0 is considered as a valid EOP on FS/LS port.
Enable this feature if the LineState has SE0 glitches during transmission. This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in LineState check for SE0 detection in FS/LS.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, FS/LS SE0 is filtered for two clocks for detecting EOP.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_IPGAP_LINECHECK_DIS</name>
              <description>Disable TX IPGAP LineState check.
This bit is applicable for HS operation of MAC. If this feature is enabled, then the MAC operating in HS ignores the UTMI/ULPI LineState during the transmit of a token (during token-to-token and token-to-data IPGAP). When enabled, the controller implements a fixed 40-bit TXENDDELAY after the packet is given on UTMI and ignores the LineState during this time:
- Device mode: If this bit is set, then for device LPM handshake, the controller will ignore the LineState after TX and wait for fixed clocks (40 bit times equivalent) after transmitting ACK on UTMI.
- Host mode: If this bit is set, then the IPGAP between (token-to-token/token-to-data) is added by 40 bit times of TXENDDELAY, and LineState is ignored during this 40 bit times delay.
Enable this bit if the LineState will not reflect the expected line state (J) during transmission. This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in LineState check.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, 2.0 MAC disables LineState check during HS transmit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_TRB_OUT_SPR_IND</name>
              <description>OUT in TRB status short packet indication.
This bit is applicable for Device mode only. If the device application (software/hardware) wants to know if a short packet was received for an OUT in the TRB status itself, then this feature can be enabled, so that a bit is set in the TRB writeback in the BUF_SIZE DWORD. The HCSPARAMS2[SPR] bit of the {trbstatus, RSVD, SPR, PCM1, bufsize} DWORD will be set during an OUT transfer TRB write back if this is the last TRB used for that transfer descriptor. This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in TRB status DWORD</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, OUT TRB status indicates Short Packet</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_L1_EXIT_BY_HW</name>
              <description>Device in L1 hardware exit.
When control transfers are in progress, the LPM is rejected (NYET response). Only after control transfers are completed (either with ACK/STALL), LPM is accepted.
This bit is applicable for Device mode only. This field enables device controller sending remote wakeup for L1 if the device becomes ready for sending/accepting data when in L1 state. If the host expects the device to send remote wakeup signaling to resume after going into L1 in flow controlled state, then this bit can be set to send the remote wake signal automatically when the device controller becomes ready. This hardware remote wake feature is applicable only to bulk and interrupt transfers, and not for isochronous/control.
For isochronous transfers, the host needs to do the wake-up and start the transfer. Device controller will not do remote-wakeup when isochronous endpoints get ready. The device software needs to keep the GUSB2PHYCFG0[ENBLSLPM] bit reset in order to keep the PHY clock to be running for keeping track of SOF intervals.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, disables device L1 hardware exit logic.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IP_GAP_ADD_ON</name>
              <description>Inter packet gap add on.
This bit field is used to add on to the default inter packet gap setting in the USB 2.0 MAC. This should be programmed to a non-zero value only in case where it is need to increase the default inter packet delay calculations in the USB 2.0 MAC</description>
              <bitRange>[23:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_LSP_TAIL_LOCK_DIS</name>
              <description>Disable device LSP lock logic for tail TRB.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, enables device LSP lock logic for tail TRB update.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Fix is disabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NAK_PER_ENH_FS</name>
              <description>Performance enhancement for FS in NAK.
If a periodic endpoint is present, and if a bulk endpoint which is also active is being NAKed by the device, then this could result in a decrease in performance of other Full-Speed bulk endpoint which is ACKed by the device. Setting this bit to 0x1, enables the HC to schedule more transactions to the async endpoints (bulk/control) and hence improves the performance of the bulk endpoint. This control bit should be enabled only if the existing performance with the default setting is not sufficient for Full-Speed application. Setting this bit will only control, and is only required for Full-Speed transfers.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enhancement not applied.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables performance enhancement for FS async endpoints in the presence of NAKs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NAK_PER_ENH_HS</name>
              <description>Performance enhancement for HS in NAK.
If a periodic endpoint is present, and if a bulk endpoint which is also active is being NAKed by the device, then this could result in decrease in performance of other HS bulk endpoint which is ACked by the device. Setting this bit to 0x1, enables the host controller to schedule more transactions to the async endpoints (bulk/control) and hence it improves the performance of the bulk endpoint. This control bit should be enabled only if the existing performance with the default setting is not sufficient for HS application. Setting this bit only controls, and is only required for HS transfers.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enhancement not applied.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables performance enhancement for HS async endpoints in the presence of NAKs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PARKMODE_DISABLE_HS</name>
              <description>Disable park mode of HS bus instances.
This bit is used only in Host mode.
When this bit is set to 0x1, all HS bus instances park mode are disabled.
To improve performance in park mode, the xHCI scheduler queues in three requests of 4 packets each for HS asynchronous endpoints in a micro-frame. But if a device is slow and if it NAKs more than 3 times, then it is rescheduled only in the next micro-frame. This could decrease the performance of a slow device even further.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARKMODE_DISABLE_FSLS</name>
              <description>Disable park mode of FS/LS bus instances.
This bit is used only in Host mode, and is for debug purpose only.
When this bit is set to 0x1 all FS/LS bus instances in park mode disabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISUSB2REFCLKGTNG</name>
              <description>Disable REF_CLK gating for 2.0 PHY
If REF_CLK gating is disabled, then the REF_CLK input cannot be turned off to the USB 2.0 PHY and controller. This is independent of the GCTL[DSBLCLKGTNG] bit setting.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>REF_CLK gating enabled for USB 2.0 PHY</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>REF_CLK gating disabled for USB 2.0 PHY</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESUME_OPMODE_HS_HOST</name>
              <description>Opmode in HS resume in Host mode
This bit is used only in Host mode, and is for USB 2.0 opmode behavior in HS Resume.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>When this bit is set to 0x0, the UTMI/ULPI opmode changes to normal 2 us after HS terminations change after EOR. This is the default behavior.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>When this bit is set to 0x1, the UTMI opmode changes to normal along with HS terminations after EOR.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_HS_NYET_BULK_SPR</name>
              <description>HS bulk OUT short packet gets NYET in Device mode
This bit is applicable for Device mode only.
If this bit is set, the device controller sends NYET response instead of ACK response for a successfully received bulk OUT short packet. If NYET is sent after receiving short packet, then the host would PING before sending the next OUT; this improves the performance as well as clears up the buffer/cache on the host side. Internal to the device controller, short packet (HCSPARAMS2[SPR] = 0x1) processing takes some time, and during this time, the USB is flow controlled. With NYET response instead of ACK on short packet, the host does not send another OUT-DATA without pinging in HS mode.
This bit is quasi-static, that is, it must not be changed during device operation.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behavior, no change in device response.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Feature enabled, HS bulk OUT short packet gets NYET response.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>L1_SUSP_THRLD_EN_FOR_HOST</name>
              <description>L1 suspend threshold enable in Host mode.
This bit is used only in Host mode.
The host controller asserts the UTMI_L1_SUSPEND_n and UTMI_SLEEP_n output signals as follows:
The controller asserts the UTMI_L1_SUSPEND_n signal to put the PHY into deep low-power mode in L1 when both of the following are true:
a) The HIRD/BESL value used is greater than or equal to the value in the L1_SUSP_THRLD_FOR_HOST bit.
b) The L1_SUSP_THRLD_EN_FOR_HOST bit is set to 0x1.
The controller asserts UTMI_SLEEP_n on L1 when one of the following is true: 
a) The HIRD/BESL value used is less than the value in the L1_SUSP_THRLD_FOR_HOST bit.
b) This bit is set to 0x0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L1_SUSP_THRLD_FOR_HOST</name>
              <description>L1 suspend threshold in Host mode.
This bit field is effective only when the L1_SUSP_THRLD_EN_FOR_HOST bit is set to 0x1. For more details, refer to the description of the L1_SUSP_THRLD_EN_FOR_HOST bit.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HC_ERRATA_ENABLE</name>
              <description>Host Exit Latency Delta (ELD) enable.
When this bit is set to 0x1, it enables the ELD support defined in the xHCI 1.0 Errata.
This bit is used only in Host mode and should be set to 0x1.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HC_PARCHK_DISABLE</name>
              <description>Host parameter check disable.
When this bit is set to 0x0 (by default), the xHC checks that the input slot/EP context fields comply to the xHCI Specification. Upon detection of a parameter error during command execution, the xHC generates an event TRB with completion code indicating PARAMETER_ERROR.
When the bit is set to 0x1, the xHC does not perform parameter checks and does not generate PARAMETER_ERROR completion code.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVRLD_L1_SUSP_COM</name>
              <description>Overvload UTMI_L1_SUSPEND_COM.
If this bit is set, the UTMI_L1_SUSPEND_COM_n is overloaded with the UTMI_SLEEP_n signal. This bit is usually set if the PHY stops the port clock during L1 sleep condition.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOA_FILTER_EN</name>
              <description>LOA filter enable.
If this bit is set, the USB 2.0 port babble is checked at least three consecutive times before the port is disabled. This prevents false triggering of the babble condition when using low quality cables.
Note: This bit is valid only in Host mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GSNPSID</name>
          <description>Global Controller ID Register</description>
          <addressOffset>0xC120</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x5533330B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GSNPSID</name>
              <description>The GSNPSID[31-16] bit field indicates the Core Identification Number. 0x5533 is ASCII for U3.
The GSNPSID[15-0] bit field indicates the release number. Current Release is 3.30b.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUID</name>
          <description>Global User ID Register</description>
          <addressOffset>0xC128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12345678</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USERID</name>
              <description>Application-programmable ID field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUCTL</name>
          <description>Global User Control Register</description>
          <addressOffset>0xC12C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x02000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REF_CLK_PERIOD</name>
              <description>REF_CLK period.
This bit field indicates in terms of nano seconds the period of REF_CLK. The default value of this bit field is set to 0x8 (8 ns/125 MHz).
This bit field needs to be updated during power-on initialization, if the GCTL[SOFITPSYNC] or GFLADJ[GFLADJ_REFCLK_LPM_SEL] bit is set to 0x1. The programmable maximum value is 62 ns, and the minimum value is 8 ns.
The user should use a reference clock with a period that is an integer multiple, so that ITP can meet the jitter margin of 32 ns. The allowable REF_CLK frequencies whose period is not integer multiples are 16/17/19.2/24/39.7 MHz.
This bit field must not be set to 0x0 at any time. If it is not planed to use this feature, this bit field should be set to 0x8 (the default value).</description>
              <bitRange>[31:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOEXTRDL</name>
              <description>No Extra Delay Between SOF and the First Packet.
Some HS devices misbehave when the host sends a packet immediately after a SOF. However, adding an extra delay between a SOF and the first packet can reduce the USB data rate and performance.
This bit is used to control whether the host must wait for 2 us before it sends the first packet after a SOF, or not. This bit can be set to 0x1 to improve the performance if those problematic devices are not a concern in the user host environment.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host waits for 2 us after a SOF before it sends the first USB packet.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host does not wait after a SOF before it sends the first USB packet.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPRSCTRLTRANSEN</name>
              <description>Sparse control transaction enable.
Some devices are slow in responding to control transfers. Scheduling multiple transactions in one microframe/frame can cause these devices to misbehave.
If this bit is set to 0x1, the HC schedules transactions for a control transfer in different microframes/frames.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESBWHSEPS</name>
              <description>Reserving 85% bandwidth for HS periodic EPs.
By default, HC reserves 80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85% to accommodate two High-Speed, High-Bandwidth ISOC EPs.
USB 2.0 requires 80% bandwidth allocated for ISOC traffic. If two High-Bandwidth ISOC devices (HD webcams) are connected, and if each requires 1024 bytes x 3 packets per Micro-Frame, then the bandwidth required is around 82%. If this bit is set, then it is possible to connect two webcams of 1024 bytes x 3 payload per Micro-Frame each. Otherwise, it could be needed to reduce the resolution of the webcams.
Note: This bit is used in Host mode operation only. Ignore this bit in Device mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBHSTINAUTORETRYEN</name>
              <description>Host IN auto retry.
When set, this bit enables the Auto Retry feature. For IN transfers (non-isochronous) that encounter data packets with CRC errors or internal overrun scenarios, the Auto Retry feature causes the HC to reply to the device with a non-terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP != 0).
If the Auto Retry feature is disabled (default), the controller responds with a terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP = 0).
Note: When enabling Auto Retry feature, if the system latency is large enough to cause the internal PSQ full (PSQ can be full as the result of messages not being processed because of pending fetches before flushing the TxQ due to NRDY/ERDY conditions), then the HC can generate a transaction error.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Auto Retry is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Auto Retry is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXTCAPSUPPTEN</name>
              <description>External extended capability support enable.
When set, this bit enables extended capabilities to be implemented outside the controller.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSRTEXTRFSBODI</name>
              <description>Insert extra delay between FS Bulk OUT transactions.
Some FS devices are slow to receive Bulk OUT data and can get stuck when there are consecutive Bulk OUT transactions with short inter-transaction delays. This bit is used to control whether the host inserts extra delay between consecutive Bulk OUT transactions to a FS Endpoint.
Note: Setting this bit to 0x1 reduces the Bulk OUT transfer performance for most of the FS devices.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host does not insert extra delay between consecutive Bulk OUT transactions to a FS Endpoint.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Host inserts about 12 us extra delay between consecutive Bulk OUT transactions to a FS Endpoint to work around the device issue.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTCT</name>
              <description>Device timeout coarse tuning.
This field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.
The controller first checks the DTCT value. If it is 0x0, then the timeout value is defined by the DTFT. If it is non-zero, then it uses the following timeout values:
Note: When the system latency is larger than the programmed DTCT/DTFT value, if the HC is not able to accept certain transactions on the bus (because of system bus delays), the controller may not release header credits which in turn can cause the host to report a transaction error. Therefore, program this value to be larger than your system delay.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 us-use DTFT value instead</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>500 us</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>1.5 ms</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>6.5 ms</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DTFT</name>
              <description>Device timeout fine tuning.
This bit field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.
For the DTFT field to take effect, the DTCT bit filed must be set to 0x0.
The DTCT value is the number of 60 MHz clocks x 256 to count before considering a device timeout.
The minimum value of DTFT is 0x2.
Note: When the system latency is larger than the programmed DTCT/DTFT value, if the HC is not able to accept certain transactions on the bus (because of system bus delays), the controller may not release header credits which in turn can cause the host to report a transaction error. Therefore, program this value to be larger than your system delay.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GBUSERRADDRLO</name>
          <description>Global SoC Bus Error Address Register-Low</description>
          <addressOffset>0xC130</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUSERRADDR</name>
              <description>Bus address-low. 
This register contains the lower 32 bits of the first bus address that encountered a SoC bus error. It is valid when the GSTS[BUSEEEADDRVLD] bit is set to 0x1. It can only be cleared by resetting the controller.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GBUSERRADDRHI</name>
          <description>Global SoC Bus Error Address Register-High</description>
          <addressOffset>0xC134</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUSERRADDR</name>
              <description>Bus address-high.
This register contains the higher 32 bits of the first bus address that encountered a SoC bus error. It is valid when the GSTS[BUSERRADDRVLD] bit is set to 0x1. It can only be cleared by resetting the controller.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS0</name>
          <description>Global Hardware Parameters Register 0</description>
          <addressOffset>0xC140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x2020400A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS0_31_24</name>
              <description>Master/Slave Address Bus Width (num bits).</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_23_16</name>
              <description>Slave Bus (Register Access Bus) Data Bus Width (num bits).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_15_8</name>
              <description>Master Bus (DMA Bus) Data Bus Width (num bits).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_7_6</name>
              <description>Slave Bus (Register Access Bus) Interface Type (0x0 = AHB).</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_5_3</name>
              <description>Master Bus (DMA Bus) Interface Type (0x1 = AXI).</description>
              <bitRange>[5:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS0_2_0</name>
              <description>Mode of Operation (0x2 = Device and Host (DRD)).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS1</name>
          <description>Global Hardware Parameters Register 1</description>
          <addressOffset>0xC144</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x01A0C93B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS1_31</name>
              <description>xHCI debug capability.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_30</name>
              <description>RM_OPT_FEATURES</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_29</name>
              <description>Reserved.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_28</name>
              <description>RAM_BUS_CLKS_SYNC</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_27</name>
              <description>MAC_RAM_CLKS_SYNC</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_26</name>
              <description>MAC_PHY_CLKS_SYNC</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_25_24</name>
              <description>Power Optimization Mode (0x1 = Clock Gating Only)</description>
              <bitRange>[25:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_23</name>
              <description>Synchronous Static RAM Type (0x1 = Single-Port RAM (SPRAM))</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_22_21</name>
              <description>Number of RAMs</description>
              <bitRange>[22:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_20_15</name>
              <description>Number of Device Mode Event Buffers</description>
              <bitRange>[20:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_14_12</name>
              <description>ASPACEWIDTH</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_11_9</name>
              <description>REQINFOWIDTH</description>
              <bitRange>[11:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_8_6</name>
              <description>DATAINFOWIDTH</description>
              <bitRange>[8:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_5_3</name>
              <description>BURSTWIDTH - 1</description>
              <bitRange>[5:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS1_2_0</name>
              <description>IDWIDTH - 1</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS2</name>
          <description>Global Hardware Parameters Register 2</description>
          <addressOffset>0xC148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x12345678</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS2_31_0</name>
              <description>User ID</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS3</name>
          <description>Global Hardware Parameters Register 3</description>
          <addressOffset>0xC14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x04108084</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS3_31</name>
              <description>Reserved.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_30_23</name>
              <description>CACHE_TOTAL_XFER_RESOURCES</description>
              <bitRange>[30:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_22_18</name>
              <description>Number of Device Mode Active IN Endpoints</description>
              <bitRange>[22:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_17_12</name>
              <description>Number of Device Mode Endpoints</description>
              <bitRange>[17:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_11</name>
              <description>ULPI_CARKIT</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_10</name>
              <description>UTMI PHY Vendor Control Interface</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_9_8</name>
              <description>Reserved.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_7_6</name>
              <description>HSPHY_DWIDTH</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_5_4</name>
              <description>FSPHY_INTERFACE</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_3_2</name>
              <description>HSPHY_INTERFACE (0x1 = UTMI+)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS3_1_0</name>
              <description>SSPHY_INTERFACE</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS4</name>
          <description>Global Hardware Parameters Register 4</description>
          <addressOffset>0xC150</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x47822004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS4_31_28</name>
              <description>BMU_LSP_DEPTH</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_27_24</name>
              <description>BMU_PTL_DEPTH-1</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_23</name>
              <description>EN_ISOC_SUPT</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_22</name>
              <description>Reserved.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_21</name>
              <description>Device External Buffer Control</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_20_17</name>
              <description>NUM_SS_USB_INSTANCES</description>
              <bitRange>[20:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_16_13</name>
              <description>HIBER_SCRATCHBUFS</description>
              <bitRange>[16:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_12</name>
              <description>Reserved.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_11</name>
              <description>Reserved.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_10_9</name>
              <description>Reserved.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_8_7</name>
              <description>Reserved.</description>
              <bitRange>[8:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_6</name>
              <description>Reserved.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS4_5_0</name>
              <description>Number of cached TRBs per Transfer</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS5</name>
          <description>Global Hardware Parameters Register 5</description>
          <addressOffset>0xC154</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x04202088</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS5_31_28</name>
              <description>Reserved.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_27_22</name>
              <description>DFQ_FIFO_DEPTH</description>
              <bitRange>[27:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_21_16</name>
              <description>DWQ_FIFO_DEPTH</description>
              <bitRange>[21:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_15_10</name>
              <description>TXQ_FIFO_DEPTH</description>
              <bitRange>[15:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_9_4</name>
              <description>RXQ_FIFO_DEPTH</description>
              <bitRange>[9:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS5_3_0</name>
              <description>BMU_BUSGM_DEPTH</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS6</name>
          <description>Global Hardware Parameters Register 6</description>
          <addressOffset>0xC158</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x07490020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS6_31_16</name>
              <description>Total RAM0 Depth</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSFLTRSSUPPORT</name>
              <description>Filter for VBUS- and ID-related control inputs from the PHY</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BCSUPPORT</name>
              <description>Battery Charging Capability</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OTG_SS_SUPPORT</name>
              <description>Reserved.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADPSUPPORT</name>
              <description>ADP support</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HNPSUPPORT</name>
              <description>Reserved.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRPSUPPORT</name>
              <description>Reserved.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_9_8</name>
              <description>Reserved.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_7</name>
              <description>Reserved.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_6</name>
              <description>Reserved.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS6_5_0</name>
              <description>PSQ_FIFO_DEPTH</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS7</name>
          <description>Global Hardware Parameters Register 7</description>
          <addressOffset>0xC15C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS7_31_16</name>
              <description>RAM2_DEPTH</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GHWPARAMS7_15_0</name>
              <description>RAM1_DEPTH</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_HSLO</name>
          <description>Global High-Speed Port to Bus Instance Mapping (Low)</description>
          <addressOffset>0xC180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM8</name>
              <description>HS USB instance number for port 8.
Application-programmable ID field.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM7</name>
              <description>HS USB instance number for port 7.
Application-programmable ID field.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM6</name>
              <description>HS USB instance number for port 6.
Application-programmable ID field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM5</name>
              <description>HS USB instance number for port 5.
Application-programmable ID field.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM4</name>
              <description>HS USB instance number for port 4.
Application-programmable ID field.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM3</name>
              <description>HS USB instance number for port 3.
Application-programmable ID field.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM2</name>
              <description>HS USB instance number for port 2.
Application-programmable ID field.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM1</name>
              <description>HS USB instance number for port 1.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_HSHI</name>
          <description>Global High-Speed Port to Bus Instance Mapping (High)</description>
          <addressOffset>0xC184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM15</name>
              <description>HS USB instance number for port 15.
Application-programmable ID field.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM14</name>
              <description>HS USB instance number for port 14. 
Application-programmable ID field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM13</name>
              <description>HS USB instance number for port 13.
Application-programmable ID field.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM12</name>
              <description>HS USB instance number for port 12.
SApplication-programmable ID field.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM11</name>
              <description>HS USB instance number for port 11.
Application-programmable ID field.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM10</name>
              <description>HS USB instance number for port 10.
Application-programmable ID field.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM9</name>
              <description>HS USB instance number for port 9.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_FSLO</name>
          <description>Global Full-Speed Port to Bus Instance Mapping (Low)</description>
          <addressOffset>0xC188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM8</name>
              <description>FS USB instance number for port 8.
Application-programmable ID field.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM7</name>
              <description>FS USB instance number for port 7.
Application-programmable ID field.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM6</name>
              <description>FS USB instance number for port 6.
Application-programmable ID field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM5</name>
              <description>FS USB instance number for port 5.
Application-programmable ID field.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM4</name>
              <description>FS USB instance number for port 4.
Application-programmable ID field.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM3</name>
              <description>FS USB instance number for port 3.
Application-programmable ID field.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM2</name>
              <description>FS USB instance number for port 2.
Application-programmable ID field.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM1</name>
              <description>FS USB instance number for port 1.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPRTBIMAP_FSHI</name>
          <description>Global Full-Speed Port to Bus Instance Mapping (High)</description>
          <addressOffset>0xC18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINUM15</name>
              <description>FS USB instance number for port 15.
Application-programmable ID field</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM14</name>
              <description>FS USB instance number for port 14.
Application-programmable ID field</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM13</name>
              <description>FS USB instance number for port 13.
Application-programmable ID field</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM12</name>
              <description>FS USB instance number for port 12.
Application-programmable ID field</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM11</name>
              <description>FS USB instance number for port 11.
Application-programmable ID field</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM10</name>
              <description>FS USB instance number for port 10.
Application-programmable ID field</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BINUM9</name>
              <description>FS USB instance number for port 9.
Application-programmable ID field.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUCTL2</name>
          <description>Global User Control Register 2</description>
          <addressOffset>0xC19C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0198040D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN_HP_PM_TIMER</name>
              <description>This register field is used to set new HP and PM timers.
To enable PM timer, set the GUCTL2[19] bit as 0x1.
To enable HP timer, set the GUCTL2[20] bit as 0x1. Default value of HP timer is 4 us when HP PM timer is not enabled; when new HP timer is enabled default value is 12 us.</description>
              <bitRange>[25:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RST_ACTBITLATER</name>
              <description>Enable clearing of the command active bit for the ENDXFER command after the command execution is completed.
This bit is valid in Device mode only.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLEEPCACHEEVICT</name>
              <description>Enable evicting endpoint cache after flow control for bulk endpoints.
A performance enhancement was done to keep the non-stream capable bulk IN endpoint in cache after flow control. Setting this bit will disable this enhancement. This should be set only for debug purpose.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLECFC</name>
              <description>Disable xHCI Errata feature contiguous frame ID capability.
This field controls the xHCI Errata feature Contiguous FrameID capability. When set, the HCCPARAMS1[CFC] bit will be set to 0x0 indicating that CFC is not supported. Disable this feature only if the application cannot tolerate Misssed Service Error events for ISOC transfers, and the system latencies are large to cause Missed Service errors even if the software is following the Isochronous Thresholding rules.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUSB2PHYCFG0</name>
          <description>Global USB2 PHY Configuration Register</description>
          <addressOffset>0xC200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40102400</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHYSOFTRST</name>
              <description>UTMI PHY soft reset.
Causes the USB2PHY_RESET signal to be asserted to reset a UTMI PHY.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>U2_FREECLK_EXISTS</name>
              <description>U2 Free Clock Exists.
This bit specifies whether USB 2.0 PHY provides a free-running PHY clock, which is active when the clock control input is active.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>USB 2.0 free clock does not exist</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>USB 2.0 free clock exists</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ULPI_LPM_WITH_OPMODE_CHK</name>
              <description>Reserved. Keep at 0x0.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSIC_CON_WIDTH_ADJ</name>
              <description>Reserved.</description>
              <bitRange>[28:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INV_SEL_HSIC</name>
              <description>Reserved.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVRD_FSLS_DISC_TIME</name>
              <description>Overriding the FS/LS disconnect time to 32 us.
If this value is 0x0, the FS/LS disconnect time is set to 2.5 us as per the USB specification.
If this value is non-zero, the disconnect detection time is set to 32 us.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LSTRD</name>
              <description>LS turnaround time.
This bit field indicates the value of the Rx-to-Tx packet gap for LS devices. The encoding is as follows:
Note: This field is applicable only in Host mode.
For normal operation (to work with most LS devices), set the default value of this bit field to 0x0 (2 bit times).
The programmable LS device inter-packet gap and turnaround delays are provided to support some legacy LS devices that might require different delays than the default/fixed ones.
Include PHY delays when programming the LSIPD/LSTRD values. For example, if PHY's TXENDDELAY in LS mode is 30 UTMI CLKs, then subtract this delay (~1 LS bit time) from the device delay requirement.</description>
              <bitRange>[24:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 bit times</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2.5 bit times</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bit times</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>3.5 bit times</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>4 bit times</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>4.5 bit times</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>5 bit times</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>5.5 bit times</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LSIPD</name>
              <description>LS inter-packet time.
This field indicates the value of Tx-to-Tx packet gap for LS devices. The encoding is as follows:
Note: This field is applicable only in Host mode.
For normal operation (to work with most LS devices), set the default value of this field to 0x2 (3 bit times).
The programmable LS device inter-packet gap and turnaround delays are provided to support some legacy LS devices that might require different delays than the default/fixed ones.
Include PHY delays when programming the LSIPD/LSTRD values.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 bit times</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2.5 bit times</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bit times</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>3.5 bit times</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>4 bit times</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>4.5 bit times</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>5 bit times</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>5.5 bit times</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USBTRDTIM</name>
              <description>USB 2.0 turnaround time.
This bit field sets the turnaround time in PHY clocks.
Specifies the response time for a MAC request to the Packet FIFO Controller (PFC) to fetch data from the DFIFO (SPRAM).
The following are the required values for the minimum SoC bus frequency of 60 MHz. USB turnaround time is a critical certification criteria when using long cables and five hub levels.
The required values for this field:
Note: This field is valid only in Device mode.</description>
              <bitRange>[13:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>When the MAC interface is 16-bit UTMI+.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>When the MAC interface is 8-bit UTMI+/ULPI.</description>
                  <value>0x9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XCVRDLY</name>
              <description>Transceiver Delay.
Enables a delay between the assertion of the UTMI Transceiver Select signal (for HS) and the assertion of the TxValid signal during a HS Chirp.
When this bit is set to 0x1, a delay (of approximately 2.5 us) is introduced from the time when the Transceiver Select is set to 0x0 (HS) to the time the TxValid is driven to 0 for sending the chirp-K. 
This bit is valid only in device mode.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENBLSLPM</name>
              <description>Enable UTMI_SLEEP_n and UTMI_L1_SUSPEND_n.
The application uses this bit to control UTMI_SLEEP_n and UTMI_L1_SUSPEND_n assertion to the PHY in the L1 state.
Note: This bit must be set to 0x1.
Note: In Device mode, before issuing any device endpoint command, disable this bit and enable it after the command completes. Without disabling this bit, if a command is issued when the device is in L1 state and if MAC2_CLK (UTMI_CLK) is gated off, the command will not get completed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UTMI_SLEEP_n and UTMI_L1_SUSPEND_n assertion from the controller is not transferred to the PHY.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UTMI_SLEEP_n and UTMI_L1_SUSPEND_n assertion from the controller is transferred to the PHY.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYSEL</name>
              <description>USB 2.0 High-Speed PHY or USB 1.1 Full-Speed serial transceiver select.
Note: USB 1.1 full-serial transceiver is not supported. This bit always reads as 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SUSPENDUSB20</name>
              <description>Suspend USB2.0 HS/FS/LS PHY.
When this bit is set, USB2.0 PHY enters Suspend mode if Suspend conditions are valid.
 Application needs to set it to 0x1 after the controller initialization completes.
Note: In Host mode, on reset, this bit is set to 0x1. Software can override this bit after reset.
In Device mode, before issuing any device endpoint command, disable this bit and enable it after the command completes. If the user issues a command without disabling this bit when the device is in L2 state and if MAC2_CLK (UTMI_CLK/ULPI_CLK) is gated off, the command will not get completed.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FSINTF</name>
              <description>Full-Speed serial interface select.
Note: USB 1.1 full-speed serial interface is not supported. This bit always reads as 0x0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ULPI_UTMI_SEL</name>
              <description>ULPI or UTMI+ selection.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UTMI+ interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ULPI interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHYIF</name>
              <description>PHY interface.
If UTMI+ is selected, the application uses this bit to configure the controller to support a UTMI+ PHY with an 8- or 16-bit interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8 bits</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16 bits</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TOUTCAL</name>
              <description>HS/FS timeout calibration.
The number of PHY clocks, as indicated by the application in this bit field, is multiplied by a bit-time factor; this factor is added to the High-Speed/Full-Speed interpacket timeout duration in the controller to account for additional delays introduced by the PHY. This may be required, since the delay introduced by the PHY in generating the LineState condition may vary among PHYs.
The USB standard timeout value for high-speed operation is 736 to 816 (inclusive) bit times. The USB standard timeout value for Full-Speed operation is 16 to 18 (inclusive) bit times. The application must program this field based on the speed of connection. The number of bit times added per PHY clock are:
High-Speed operation:
- One 30-MHz PHY clock = 16 bit times
- One 60-MHz PHY clock = 8 bit times
Full-Speed operation:
- One 30-MHz PHY clock = 0.4 bit times
- One 60-MHz PHY clock = 0.2 bit times
- One 48-MHz PHY clock = 0.25 bit times</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>GTXFIFOSIZ[%s]</name>
          <description>Global Transmit FIFO Size Register n</description>
          <addressOffset>0xC300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0271000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFSTADDR_N</name>
              <description>Transmit FIFOn RAM start address.
This bit field contains the memory start address for TxFIFOn in MDWIDTH-bit words.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFDEP_N</name>
              <description>TxFIFO Depth.
This field contains the depth of TxFIFOn in MDWIDTH-bit words.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>GRXFIFOSIZ[%s]</name>
          <description>Global Receive FIFO Size Register n</description>
          <addressOffset>0xC380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x016C0105</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFSTADDR_N</name>
              <description>RxFIFOn RAM start address.
This bit field contains the memory start address for RxFIFO n in MDWIDTH-bit words.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFDEP_N</name>
              <description>RxFIFO depth.
This bit field contains the depth of RxFIFO n in MDWIDTH-bit words.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTADRLO0</name>
          <description>Global Event Buffer Address (Low)</description>
          <addressOffset>0xC400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTADRLO</name>
              <description>Event buffer address.
This bit field holds the lower 32 bits of start address of the external memory for the Event Buffer. During operation, hardware does not update this address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTADRHI0</name>
          <description>Global Event Buffer Address (High)</description>
          <addressOffset>0xC404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTADRHI</name>
              <description>Event buffer address.
This bit field holds the higher 32 bits of start address of the external memory for the Event Buffer. During operation, hardware does not update this address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTSIZ0</name>
          <description>Global Event Buffer Size Register</description>
          <addressOffset>0xC408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTINTRPTMASK</name>
              <description>Event interrupt mask.
When this bit is set to 0x1, this prevents the interrupt from being generated. However, even when the mask is set, the events are queued.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENTSIZ</name>
              <description>Event buffer size in bytes.
This bit field holds the size of the Event Buffer in bytes; must be a multiple of four. This is programmed by software once during initialization. The minimum size of the event buffer is 32 bytes.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GEVNTCOUNT0</name>
          <description>Global Event Buffer Count Register</description>
          <addressOffset>0xC40C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNT_HANDLER_BUSY</name>
              <description>Event handler busy.
Device software event handler busy indication. The controller sets this bit when the interrupt line is asserted due to pending events. Software clears this bit (with 0x1) when it has finished processing the events (along with updating the EVNTCOUNT bit field in this register). The controller does not raise the interrupt line for a new event unless this bit is cleared.
Note: When interrupt moderation is disabled (that is, the DEV_IMOD0[DEVICE_IMODI] = 0x0), this bit is ignored.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EVNTCOUNT</name>
              <description>Event count.
When read, returns the number of valid events in the Event Buffer (in bytes).
When written, hardware decrements the count by the value written.
When interrupt moderation is enabled (that is, the DEV_IMOD0[DEVICE_IMODI] != 0x0), the interrupt line gets de-asserted when the first write happens on this register to decrement the count. When interrupt moderation is disabled (that is, the DEV_IMOD0[DEVICE_IMODI] = 0x0), the interrupt line continues to get asserted until the event count becomes zero (no-moderation behavior).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GHWPARAMS8</name>
          <description>Global Hardware Parameters Register 8</description>
          <addressOffset>0xC600</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000043C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GHWPARAMS8_32_0</name>
              <description>Default RAM0 cache depth.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GTXFIFOPRIDEV</name>
          <description>Global Device TX FIFO DMA Priority Register</description>
          <addressOffset>0xC610</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GTXFIFOPRIDEV</name>
              <description>Device TxFIFO priority.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GTXFIFOPRIHST</name>
          <description>Global Host TX FIFO DMA Priority Register</description>
          <addressOffset>0xC618</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GTXFIFOPRIHST</name>
              <description>Host TxFIFO priority.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GRXFIFOPRIHST</name>
          <description>Global Host RX FIFO DMA Priority Register</description>
          <addressOffset>0xC61C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GRXFIFOPRIHST</name>
              <description>Host RxFIFO priority.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GFLADJ</name>
          <description>Global Frame Length Adjustment Register</description>
          <addressOffset>0xC630</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GFLADJ_REFCLK_240MHZDECR_PLS1</name>
              <description>This bit indicates that the decrement value that the controller applies for each REF_CLK must be GFLADJ_REFCLK_240MHZ_DECR and GFLADJ_REFCLK_240MHZ_DECR + 1 alternatively on each REF_CLK.
Set this bit to a 0x1 only if the GFLADJ_REFCLK_LPM_SEL bit is set to 0x0 and the fractional component of 240/REF_CLK_FREQUENCY is greater than or equal to 0.5.
Examples:
If the REF_CLK is 19.2 MHz then:
- GUCTL[REF_CLK_PERIOD] = 52
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = (240/19.2) = 12.5
- GFLADJ[GFLADJ_REFCLK_240MHZDECR_PLS1] = 1
- GUCTL[REF_CLK_PERIOD] = 41
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = (240/24) = 10
- GFLADJ[GFLADJ_REFCLK_240MHZDECR_PLS1] = 0</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_REFCLK_240MHZ_DECR</name>
              <description>This bit field indicates the decrement value that the controller applies for each REF_CLK in order to derive a frame timer in terms of a 240-MHz clock.
This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set to 0x1.
The value is derived as follows:
GFLADJ_REFCLK_240MHZ_DECR = 240/REF_CLK_FREQUENCY
Examples:
If the REF_CLK is 24 MHz then:
- GUCTL[REF_CLK_PERIOD] = 41
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = 240/24 = 10
- GUCTL[REF_CLK_PERIOD] = 20
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = 240/48 = 5
- GUCTL[REF_CLK_PERIOD] = 58
- GFLADJ[GFLADJ_REFCLK_240MHZ_DECR] = 240/17 = 14</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_REFCLK_LPM_SEL</name>
              <description>This bit enables the functionality of running SOF/ITP counters on the REF_CLK.
In Device mode, setting this bit to 0x1 enables SOF tracking using REF_CLK.
Note that the REF_CLK frequencies supported in this mode are 16/17/19.2/20/24/39.7/40 MHz.
Note: If this bit is set to 0x1, the GUSB2PHYCFG0[U2_FREECLK_EXISTS] bit must be set to 0x0.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_REFCLK_FLADJ</name>
              <description>This bit field indicates the frame length adjustment to be applied when SOF/ITP counter is running on the REF_CLK.
The GFLADJ_REFCLK_FLADJ value is used to adjust the ITP interval when the GCTL[SOFITPSYNC] bit is set to 0x1; SOF and ITP interval when the GFLADJ_REFCLK_LPM_SEL bit is set to 0x1.
This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL bit is set to 0x1.
The value is derived as follows:
FLADJ_REF_CLK_FLADJ = ((125000/REF_CLK_PERIOD_INTEGER) - (125000/REF_CLK_PERIOD)) x REF_CLK_PERIOD, where:
1) The REF_CLK_PERIOD_INTEGER is the integer value of the REF_CLK period got by truncating the decimal (fractional) value that is programmed in the GUCTL[REF_CLK_PERIOD] bit field.
2) The REF_CLK_PERIOD is the REF_CLK period including the fractional value.
- GUCTL[REF_CLK_PERIOD] = 41
- GFLADJ[GLADJ_REFCLK_FLADJ] = ((125000/41) - (125000/41.6666)) x 41.6666 = 2032 (ignoring the fractional value)
- GUCTL[REF_CLK_PERIOD] = 20
- GFLADJ[GLADJ_REFCLK_FLADJ] = ((125000/20) - (125000/20.8333)) x 20.8333 = 5208 (ignoring the fractional value)</description>
              <bitRange>[21:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GFLADJ_30MHZ_SDBND_SEL</name>
              <description>This field selects whether to use the FLADJ_30MHZ_REG input signal or the GFLADJ[GFLADJ_30MHZ] to adjust the frame length for the SOF/ITP. When this bit is set to:</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The controller uses the FLADJ_30MHZ_REG input signal value.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller uses the register field GFLADJ[GFLADJ_30MHZ] value.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GFLADJ_30MHZ</name>
              <description>This bit field indicates the value that is used for frame length adjustment instead of considering from the sideband input signal FLADJ_30MHZ_REG.
For details on how to set this value, refer to section , 'Frame Length Adjustment Register (FLADJ),' of the xHCI Specification.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GUSB2RHBCTL0</name>
          <description>Global USB 2.0 Root Hub Control Register</description>
          <addressOffset>0xC640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OVRD_L1TIMEOUT</name>
              <description>Overriding the driver programmed L1TIMEOUT value.
If this bit is set to 0x0, the L1 Timeout value is taken from the xHCI PORTHLPMC register. If this value is non-zero, then this will override the L1 Timeout value programmed in the xHCI PORTHLPMC register. In that case the actual L1 Timeout would be 2^(OVRD_L1TIMEOUT-1) x 8 us (1 = 8 us, 2 = 16 us, 3 = 32 us and so forth).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCFG</name>
          <description>Device Configuration Register</description>
          <addressOffset>0xC700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00080800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IGNSTRMPP</name>
              <description>Ignore Stream PP.
This bit only affects stream-capable bulk endpoints.
When this bit is set to 0x0 and the controller receives a Data Packet with the Packet Pending (PP) bit set to 0x0 for OUT endpoints, or it receives an ACK with the NUMP bit field set to 0x0 and PP set to 0x0 for IN endpoints, the controller attempts to search for another stream (CStream) to initiate to the host. However, there are two situations where this behavior is not optimal:
When the host is setting PP = 0 even though it has not finished the stream, or when the endpoint on the device is configured with one transfer resource and therefore does not have any other streams to initiate to the host.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPMCAP</name>
              <description>LPM Capable.
The application uses this bit to control the LPM capabilities of the controller. If the controller operates as a non-LPM-capable device, it cannot respond to LPM transactions.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>LPM capability is not enabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>LPM capability is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUMP</name>
              <description>Number of Receive Buffers.
This bit field indicates the number of receive buffers to be reported in the ACK TP.
For an OUT endpoint, this bit field controls the number of receive buffers reported in the NUMP bit field of the ACK TP transmitted by the controller.
Note: This bit is used in host mode when Debug Capability is enabled.</description>
              <bitRange>[21:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTRNUM</name>
              <description>Interrupt number
Indicates interrupt/EventQ number on which non-endpoint-specific device-related interrupts (see Section Event Buffer Content for Device-Specific Events (DEVT)) are generated.</description>
              <bitRange>[16:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVADDR</name>
              <description>Device Address.
The application must perform the following:
- Program this field after every SetAddress request.
- Reset this field to zero after USB reset.</description>
              <bitRange>[9:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVSPD</name>
              <description>Device Speed.
Indicates the speed at which the application requires the controller to connect, or the maximum speed the application can support.
However, the actual bus speed is determined only after the chirp sequence is completed, and is based on the speed of the USB host to which the controller is connected.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz)</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DCTL</name>
          <description>Device Control Register</description>
          <addressOffset>0xC704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00F00000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RUN_STOP</name>
              <description>Run/Stop.
The software writes 0x1 to this bit to start the device controller operation.
To stop the device controller operation, the software must remove any active transfers and write 0x0 to this bit. When the controller is stopped, it sets the DSTS[DEVCTRLHLT] bit when the controller is idle and the lower layer finishes the disconnect process.
This bit must be used in following cases as specified:
- After power-on reset and CSR initialization, the software must write 0x1 to this bit to start the device controller. The controller does not signal connect to the host until this bit is set.
- The software uses this bit to control the device controller to perform a soft disconnect. When the software writes 0x0 to this bit, the host does not see that the device is connected. The device controller stays in the disconnected state until the software writes 0x1 to this bit. The minimum duration of keeping this bit cleared is specified in the Note below. If the software attempts a connect after the soft disconnect or detects a disconnect event, it must set the ULSTCHNGREQ bit field to 0x5 before reasserting the RUN_STOP bit.
- When the USB or Link is in a lower power state and the Two Power Rails configuration is selected, software writes 0x0 to this bit to indicate that it is going to turn off the Core Power Rail. After the software turns on the Core Power Rail again and re-initializes the device controller, it must set this bit to start the device controller. For more details, see Section Low Power Operation of Controller.
Note: The following is the minimum duration for which the soft disconnect (SftDiscon) bit must be set for the USB host to detect a device disconnect.
10 ms: 
1) For high-speed, when the device state is Suspended, Idle, or not Idle/Suspended (performing transactions).
2) For full-speed/low-speed, when the device state is Suspended, Idle, or not Idle/Supended (performing transactions).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSFTRST</name>
              <description>Core Soft Reset.
Resets the all clock domains as follows:
This bit clears the interrupts and all the CSRs except the GSTS, GSNPSID, GUID, GUSB2PHYCFG0, DCFG, DCTL, DEVTEN, and DSTS registers.
All module state machines (except the SoC Bus Slave Unit) are reset to the IDLE state, and all the TxFIFOs and the RxFIFO are flushed.
Any transactions on the SoC bus Master are terminated as soon as possible, after gracefully completing the last data phase of a SoC bus transfer. Any transactions on the USB are terminated immediately.
Note: Programming this field with random data causes side effect. Bit Bash register testing is not recommended.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>HIRDTHRES</name>
              <description>HIRD Threshold (HIRD_Thres).
The controller asserts output signals utmi_l1_suspend_n and utmi_sleep_n on the basis of this signal.
The controller asserts utmi_l1_suspend_n to put the PHY into Deep Low-Power mode in L1 when both of the following are true:
- HIRD value is greater than or equal to the value of bits 3-1 in the DCTL[HIRDTHRES] bit field and the value of bit 4 in the DCTL[HIRDTHRES] is set to 0x1.
The controller asserts utmi_sleep_n on L1 when one of the following is true: 
- If the HIRD value is less than the value of bits 3-1 in the DCTL[HIRDTHRES] bit field or the value of bit 4 in the DCTL[HIRDTHRES] is set to 0x0.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_NYET_THRES</name>
              <description>LPM NYET Threshold.
When LPM Errata is enabled:
Handshake response to LPM token specified by device application. Response depends on the DCFG[LPMCAP] bit.
1) DCFG[LPMCAP] bit is 0x0: the controller always responds with Timeout (that is, no response).
2) DCFG[LPMCAP] bit is 0x1: the controller responds with an ACK on successful LPM transaction, which requires that all of the following are satisfied:
- There are no PID or CRC5 errors in both the EXT token and the LPM token (if not true, inactivity results in a timeout ERROR).
- No data is pending in the TxFIFO and RxFIFO is empty (else NYET).
- The BESL value in the LPM token is less than or equal to the LPM_NYET_THRES bit field.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEEPCONNECT</name>
              <description>Keep Connect.
Note: If Hibernation is disabled, that is, GCTL[GBLHIBERNATIONEN] = 0x0, this bit is tied to zero.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L1HIBERNATIONEN</name>
              <description>L1 Hibernation Enable.
Note: If Hibernation is disabled, that is, GCTL[GBLHIBERNATIONEN] = 0x0, this bit is tied to zero.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRS</name>
              <description>Controller Restore State (CRS).
This command is similar to the USBCMD[CRS] bit in Host mode and initiates the restore process. When software sets this bit to 0x1, the controller immediately sets the DSTS[RSS] bit to 0x1. When the controller has finished the restore process, it sets the DSTS[RSS] bit to 0x0.
Note: When read, this field always returns 0x0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSS</name>
              <description>Controller Save State (CSS).
This command is similar to the USBCMD[CSS] bit in host mode and initiates the save process. When software sets this bit to 0x3, the controller immediately sets the DSTS[SSS] bit to 0x1. When the controller has finished the save process, it sets the DSTS[SSS] bit to 0x0.
Note: When read, this field always returns 0x0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ULSTCHNGREQ</name>
              <description>USB/Link state change request.
Software writes this bit field to issue a USB/Link state change request. A change in this bit field indicates a new request to the controller.
If software wants to issue the same request back-to-back, it must write a 0x0 to this bit field between the two requests. The result of the state change request is reflected in the USB/Link State in the DSTS register. These bits are self-cleared on the MAC Layer exiting suspended state.
If software is updating other fields of the DCTL register and not intending to force any link state change, then it must write a 0x0 to this field.
If the user writes 0x2 to the USB/Link State Change field and 0x1 to RUN/STOP, the link goes to compliance mode.
Once you are in compliance, you may alternately write zero and '10' to this field to advance the compliance pattern.
ValueRequested USB state transition
8 Remote wakeup request
Others: Reserved</description>
              <bitRange>[8:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TSTCTL</name>
              <description>Test Control.
Others: Reserved</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Test mode disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Test_J mode</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Test_K mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Test_SE0_NAK mode</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Test_Packet mode</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Test_Force_Enable</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DEVTEN</name>
          <description>Device Event Enable Register</description>
          <addressOffset>0xC708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECCERREN</name>
              <description>ECC Error Enable.
If this bit is set to 0x1, the controller reports an ECC error to the software when an uncorrectable ECC occurs internally.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>L1WKUPEVTEN</name>
              <description>L1 Resume Detected Event Enable.
Note: If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, then this bit is for L1 Resume Detected Event Enable.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VENDEVTSTRCVDEN</name>
              <description>Vendor Device Test LMP Received Event</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERRTICERREVTEN</name>
              <description>Erratic Error Event Enable.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>L1SUSPEN</name>
              <description>L1 Suspend Event Enable
Note: Only if the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, this bit is for L1 Suspend Event Enable.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFTEVTEN</name>
              <description>Start of (micro)frame.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>U3L2L1SUSPEN</name>
              <description>L2 or L2L1 Suspend Event Enable.
Note:
1) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, then this bit is for L2 Suspend Event Enable.
2) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is not enabled, then this bit is for L2L1 Suspend Event Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATIONREQEVTEN</name>
              <description>This bit enables/disables the generation of the Hibernation Request Event.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WKUPEVTEN</name>
              <description>L2 or L2L1 Resume Detected Event Enable.
Note:
1) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is enabled, then this bit is for L2 Resume Detected Event Enable.
2) If the GUCTL1[DEV_DECOUPLE_L1L2_EVT] bit is not enabled, then this bit is for L2L1 Resume Detected Event Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ULSTCNGEN</name>
              <description>USB/Link State Change Event Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONNECTDONEEVTEN</name>
              <description>Connection Done Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USBRSTEVTEN</name>
              <description>USB Reset Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISSCONNEVTEN</name>
              <description>Disconnect Detected Event Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSTS</name>
          <description>Device Status Register</description>
          <addressOffset>0xC70C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00D20001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCNRD</name>
              <description>Device Controller Not Ready (not used).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRE</name>
              <description>Save Restore Error. Currently not supported.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RSS</name>
              <description>RSS Restore State Status.
This bit is similar to the USBSTS[RSS] bit in Host mode.
When the controller finishes the restore process, it completes the command by setting the RSS bit to 0x0.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SSS</name>
              <description>SSS Save State Status.
This bit is similar to the USBSTS[SSS] in host mode.
When the controller has finished the save process, it completes the command by setting the SSS bit to 0x0.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COREIDLE</name>
              <description>Core Idle.
The bit indicates that the controller finished transferring all RxFIFO data to system memory, writing out all completed descriptors, and all Event Counts are zero.
Note: While testing for Reset values, mask out the read value. This bit represents the changing state of the controller and does not hold a static value.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVCTRLHLT</name>
              <description>Device Controller Halted.
This bit is set to 0x0 when the DCTL[RUN_STOP] bit is set to 0x1.
The controller sets this bit to 0x1 when, after software sets the DCTL[RUN_STOP] bit to 0x0, the controller is idle and the lower layer finishes the disconnect process.
When this bit is set to 0x1, the controller does not generate Device events.
Note: The controller does not set this bit to 0x1 if the GEVNTCOUNT0 register has some valid value. Software needs to acknowledge the events that are generated (by writing to the GEVNTCOUNT0 register) while it is waiting for this bit to be set to 0x1.
When Interrupt Moderation is enabled, there could be delay in raising the interrupt line when the event count is non-zero. Software should read the GEVNTCOUNT0 register directly and acknowledge them.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>USBLNKST</name>
              <description>USB/Link State.
When Hibernation is enabled, the GCTL[GBLHIBERNATIONEN] = 0x1, the USBLNKST bit field is valid only when the DCTL[RUN_STOP] bit is set to 0x1 and the DCNRD = 0x0.
The Early Suspend link state is an early indication of device suspend in HS/FS. The link state changes to Early Suspend after detecting bus idle for 3 ms.
In HS operation, this is an indication that the USB bus (that is, LineState) has been in idle (SE0) for 3 ms. However, it does not confirm whether the next process is Suspend or Reset. The device checks the bus again after pull up enable delay and if the line state indicates Suspend (full speed J), then the device waits for an additional time (~3 ms) to indicate the actual Suspend state.
In FS operation, this is an indication that the USB bus (that is, LineState) has been in idle (J) for 3 ms. The device waits for an additional time (~3 ms of Idle) to indicate the actual Suspend state.</description>
              <bitRange>[21:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>On state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Sleep (L1) state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Suspend (L2) state</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Disconnected state (Default state)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Early Suspend state (valid only when Hibernation is disabled, the GCTL[GBLHIBERNATIONEN] = 0x0)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Reset (valid only when Hibernation is enabled, the GCTL[GBLHIBERNATIONEN] = 0x1)</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>Resume (valid only when Hibernation is enabled, the GCTL[GBLHIBERNATIONEN] = 0x1)</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIFOEMPTY</name>
              <description>RxFIFO Empty.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SOFFN</name>
              <description>Frame/Microframe Number of the Received SOF.
Bits 16-14 are not used. Software can ignore these 3 bits.
Bits 13-3 indicate the frame number.
Note: After power-on reset, the controller generates the microframe number internally for every 125 us if the USB host has not issued SOF/ITP yet. During P3 state, the duration of SOFFN is based on the SUSPEND_CLK frequency.</description>
              <bitRange>[16:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONNECTSPD</name>
              <description>Connected Speed.
Indicates the speed at which the USB controller has come up after speed detection through a chirp sequence.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>High-speed (PHY clock is running at 30 or 60 MHz)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Full-speed (PHY clock is running at 30 or 60 MHz)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>SuperSpeed (PHY clock is running at 125 or 250 MHz)</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DGCMDPAR</name>
          <description>Device Generic Command Parameter Register</description>
          <addressOffset>0xC710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PARAMETER</name>
              <description>PARAMETER</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DGCMD</name>
          <description>Device Generic Command Register</description>
          <addressOffset>0xC714</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMDSTATUS</name>
              <description>Command Status.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Indicates command success</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Indicates that the device controller encountered an error while processing the command.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMDACT</name>
              <description>Command Active.
The software sets this bit to 0x1 to enable the device controller to execute the generic command.
The device controller sets this bit to 0x0 after executing the command.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToSet</modifiedWriteValues>
            </field>
            <field>
              <name>CMDIOC</name>
              <description>Command Interrupt on Complete.
When this bit is set, the device controller issues a Generic Command Completion event after executing the command.
Note that this interrupt is mapped to the DCFG[INTRNUM] bit field.
Note: This field must not set to 0x0 if the DCTL[RUN_STOP] bit is set to 0x0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDTYP</name>
              <description>Generic Command Type.
Specifies the type of generic command the software driver is requesting the controller to perform.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Set Periodic Parameters</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Set Scratchpad Buffer Array Address Lo</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Set Scratchpad Buffer Array Address Hi</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Transmit Device Notification</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Selected FIFO Flush</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>All FIFO Flush</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Set Endpoint NRDY</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>Run SoC Bus LoopBack Test</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>Restart After Disconnect</description>
                  <value>0x11</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DALEPENA</name>
          <description>Device Active USB Endpoint Enable Register</description>
          <addressOffset>0xC720</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBACTEP</name>
              <description>USB Active Endpoints.
This field indicates if a USB endpoint is active in the current configuration and interface. It applies to USB IN endpoints 0.15 and OUT endpoints 0.15, with one bit for each of the 32 possible endpoints. Even numbers are for USB OUT endpoints, and odd numbers are for USB IN endpoints, as follows:
- Bit[0]: USB EP0-OUT
- Bit[1]: USB EP0-IN
- Bit[2]: USB EP1-OUT
- Bit[3]: USB EP1-IN
The entity programming this register must set bits 0x0 and 0x1 because they enable control endpoints that map to physical endpoints (resources) after USBReset. Hardware clears these bits for all endpoints (other than EP0-OUT and EP0-IN) after detecting a USB reset event. After receiving SetConfiguration and SetInterface requests, the application must program endpoint registers accordingly and set these bits.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>16</dimIncrement>
          <name>USB_ENDPNT_CMD[%s]</name>
          <addressOffset>0xC800</addressOffset>
          <register>
            <name>DEPCMDPAR2</name>
            <description>Device Physical Endpoint-n Command Parameter 2 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PARAMETER</name>
                <description>PARAMETER</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEPCMDPAR1</name>
            <description>Device Physical Endpoint-n Command Parameter 1 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PARAMETER</name>
                <description>PARAMETER</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEPCMDPAR0</name>
            <description>Device Physical Endpoint-n Command Parameter 0 Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PARAMETER</name>
                <description>PARAMETER</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEPCMD</name>
            <description>Device Physical Endpoint-n Command Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COMMANDPARAM</name>
                <description>Command Parameters or Event Parameters.
When this register is written:
1) For Start Transfer command:
- Bits [31-16]: StreamID. The USB StreamID assigned to this transfer
2) For Start Transfer command applied to an isochronous endpoint:
- Bits [31-16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies.
3) For Update Transfer, End Transfer, and Start New Configuration commands:
- Bits [22-16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDSTATUS</name>
                <description>Command Completion Status.
Additional information about the completion of this command is available in this bit field. The information is in the same format as bits 15-12 of the Endpoint Command Complete event, see Section Event Buffer Content for Device Endpoint-Specific Events (DEPEVT).</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HIPRI_FORCERM</name>
                <description>HighPriority/ForceRM
HighPriority: Only valid for Start Transfer command
ForceRM: Only valid for End Transfer command
ClearPendIN: Only valid for Clear Stall command . Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDACT</name>
                <description>Command Active.
Software sets this bit to 0x1 to enable the device endpoint controller to execute the generic command.
The device controller sets this bit to 0x0 when the CMDSTATUS bit field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDIOC</name>
                <description>Command Interrupt on Complete.
When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.
Note that this interrupt is mapped to the INTRNUM bit field.
When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the INTRNUM bit field in the current command.
Note: This field must not be set to 0x1 if the DCTL[RUN_STOP] bit is 0x0.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMDTYP</name>
                <description>Command Type.
Specifies the type of command the software driver is requesting the controller to perform.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>Set Endpoint Configuration: 64- or 96-bit Parameter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>Set Endpoint Transfer Resource Configuration: 32-bit Parameter</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>Get Endpoint State: No Parameter Needed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>Set Stall: No Parameter Needed</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>Clear Stall (see Set Stall): No Parameter Needed</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Start Transfer: 64-bit Parameter</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Update Transfer: No Parameter Needed</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>End Transfer: No Parameter Needed</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>Start New Configuration: No Parameter Needed</description>
                    <value>0x9</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DEV_IMOD0</name>
          <description>Device Interrupt Moderation Register</description>
          <addressOffset>0xCA00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEVICE_IMODC</name>
              <description>Interrupt Moderation Down Counter.
Loaded with the DEVICE_IMODI value, whenever the hardware interrupt(n) line is de-asserted from the asserted state, counts down to 0, and stops.
The interrupt is signaled whenever this counter is 0, the GEVNTCOUNT0[EVNT_HANDLER_BUSY] bit is 0x0, and there are pending events (that is, event count is non-zero).
This counter may be directly written by software at any time to alter the interrupt rate.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVICE_IMODI</name>
              <description>Moderation Interval.
This bit field holds the minimum inter-interrupt interval between events. The interval is specified in terms of 250-ns increments.
A value of 0 disables the interrupt throttling logic and interrupts are generated immediately if event count becomes non-zero.
In scaledown simulation mode, 4 RAM clocks are used to time 250 ns.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO0</name>
      <baseAddress>0x49000000</baseAddress>
      <interrupt>
        <name>GPIO0_IRQ0</name>
        <description>GPIO0 interrupt request 0</description>
        <value>179</value>
      </interrupt>
      <interrupt>
        <name>GPIO0_IRQ1</name>
        <description>GPIO0 interrupt request 1</description>
        <value>180</value>
      </interrupt>
      <interrupt>
        <name>GPIO0_IRQ2</name>
        <description>GPIO0 interrupt request 2</description>
        <value>181</value>
      </interrupt>
      <interrupt>
        <name>GPIO0_IRQ3</name>
        <description>GPIO0 interrupt request 3</description>
        <value>182</value>
      </interrupt>
      <interrupt>
        <name>GPIO0_IRQ4</name>
        <description>GPIO0 interrupt request 4</description>
        <value>183</value>
      </interrupt>
      <interrupt>
        <name>GPIO0_IRQ5</name>
        <description>GPIO0 interrupt request 5</description>
        <value>184</value>
      </interrupt>
      <interrupt>
        <name>GPIO0_IRQ6</name>
        <description>GPIO0 interrupt request 6</description>
        <value>185</value>
      </interrupt>
      <interrupt>
        <name>GPIO0_IRQ7</name>
        <description>GPIO0 interrupt request 7</description>
        <value>186</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO1</name>
      <baseAddress>0x49001000</baseAddress>
      <interrupt>
        <name>GPIO1_IRQ0</name>
        <description>GPIO1 interrupt request 0</description>
        <value>187</value>
      </interrupt>
      <interrupt>
        <name>GPIO1_IRQ1</name>
        <description>GPIO1 interrupt request 1</description>
        <value>188</value>
      </interrupt>
      <interrupt>
        <name>GPIO1_IRQ2</name>
        <description>GPIO1 interrupt request 2</description>
        <value>189</value>
      </interrupt>
      <interrupt>
        <name>GPIO1_IRQ3</name>
        <description>GPIO1 interrupt request 3</description>
        <value>190</value>
      </interrupt>
      <interrupt>
        <name>GPIO1_IRQ4</name>
        <description>GPIO1 interrupt request 4</description>
        <value>191</value>
      </interrupt>
      <interrupt>
        <name>GPIO1_IRQ5</name>
        <description>GPIO1 interrupt request 5</description>
        <value>192</value>
      </interrupt>
      <interrupt>
        <name>GPIO1_IRQ6</name>
        <description>GPIO1 interrupt request 6</description>
        <value>193</value>
      </interrupt>
      <interrupt>
        <name>GPIO1_IRQ7</name>
        <description>GPIO1 interrupt request 7</description>
        <value>194</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO2</name>
      <baseAddress>0x49002000</baseAddress>
      <interrupt>
        <name>GPIO2_IRQ0</name>
        <description>GPIO2 interrupt request 0</description>
        <value>195</value>
      </interrupt>
      <interrupt>
        <name>GPIO2_IRQ1</name>
        <description>GPIO2 interrupt request 1</description>
        <value>196</value>
      </interrupt>
      <interrupt>
        <name>GPIO2_IRQ2</name>
        <description>GPIO2 interrupt request 2</description>
        <value>197</value>
      </interrupt>
      <interrupt>
        <name>GPIO2_IRQ3</name>
        <description>GPIO2 interrupt request 3</description>
        <value>198</value>
      </interrupt>
      <interrupt>
        <name>GPIO2_IRQ4</name>
        <description>GPIO2 interrupt request 4</description>
        <value>199</value>
      </interrupt>
      <interrupt>
        <name>GPIO2_IRQ5</name>
        <description>GPIO2 interrupt request 5</description>
        <value>200</value>
      </interrupt>
      <interrupt>
        <name>GPIO2_IRQ6</name>
        <description>GPIO2 interrupt request 6</description>
        <value>201</value>
      </interrupt>
      <interrupt>
        <name>GPIO2_IRQ7</name>
        <description>GPIO2 interrupt request 7</description>
        <value>202</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO3</name>
      <baseAddress>0x49003000</baseAddress>
      <interrupt>
        <name>GPIO3_IRQ0</name>
        <description>GPIO3 interrupt request 0</description>
        <value>203</value>
      </interrupt>
      <interrupt>
        <name>GPIO3_IRQ1</name>
        <description>GPIO3 interrupt request 1</description>
        <value>204</value>
      </interrupt>
      <interrupt>
        <name>GPIO3_IRQ2</name>
        <description>GPIO3 interrupt request 2</description>
        <value>205</value>
      </interrupt>
      <interrupt>
        <name>GPIO3_IRQ3</name>
        <description>GPIO3 interrupt request 3</description>
        <value>206</value>
      </interrupt>
      <interrupt>
        <name>GPIO3_IRQ4</name>
        <description>GPIO3 interrupt request 4</description>
        <value>207</value>
      </interrupt>
      <interrupt>
        <name>GPIO3_IRQ5</name>
        <description>GPIO3 interrupt request 5</description>
        <value>208</value>
      </interrupt>
      <interrupt>
        <name>GPIO3_IRQ6</name>
        <description>GPIO3 interrupt request 6</description>
        <value>209</value>
      </interrupt>
      <interrupt>
        <name>GPIO3_IRQ7</name>
        <description>GPIO3 interrupt request 7</description>
        <value>210</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO4</name>
      <baseAddress>0x49004000</baseAddress>
      <interrupt>
        <name>GPIO4_IRQ0</name>
        <description>GPIO4 interrupt request 0</description>
        <value>211</value>
      </interrupt>
      <interrupt>
        <name>GPIO4_IRQ1</name>
        <description>GPIO4 interrupt request 1</description>
        <value>212</value>
      </interrupt>
      <interrupt>
        <name>GPIO4_IRQ2</name>
        <description>GPIO4 interrupt request 2</description>
        <value>213</value>
      </interrupt>
      <interrupt>
        <name>GPIO4_IRQ3</name>
        <description>GPIO4 interrupt request 3</description>
        <value>214</value>
      </interrupt>
      <interrupt>
        <name>GPIO4_IRQ4</name>
        <description>GPIO4 interrupt request 4</description>
        <value>215</value>
      </interrupt>
      <interrupt>
        <name>GPIO4_IRQ5</name>
        <description>GPIO4 interrupt request 5</description>
        <value>216</value>
      </interrupt>
      <interrupt>
        <name>GPIO4_IRQ6</name>
        <description>GPIO4 interrupt request 6</description>
        <value>217</value>
      </interrupt>
      <interrupt>
        <name>GPIO4_IRQ7</name>
        <description>GPIO4 interrupt request 7</description>
        <value>218</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO5</name>
      <baseAddress>0x49005000</baseAddress>
      <interrupt>
        <name>GPIO5_IRQ0</name>
        <description>GPIO5 interrupt request 0</description>
        <value>219</value>
      </interrupt>
      <interrupt>
        <name>GPIO5_IRQ1</name>
        <description>GPIO5 interrupt request 1</description>
        <value>220</value>
      </interrupt>
      <interrupt>
        <name>GPIO5_IRQ2</name>
        <description>GPIO5 interrupt request 2</description>
        <value>221</value>
      </interrupt>
      <interrupt>
        <name>GPIO5_IRQ3</name>
        <description>GPIO5 interrupt request 3</description>
        <value>222</value>
      </interrupt>
      <interrupt>
        <name>GPIO5_IRQ4</name>
        <description>GPIO5 interrupt request 4</description>
        <value>223</value>
      </interrupt>
      <interrupt>
        <name>GPIO5_IRQ5</name>
        <description>GPIO5 interrupt request 5</description>
        <value>224</value>
      </interrupt>
      <interrupt>
        <name>GPIO5_IRQ6</name>
        <description>GPIO5 interrupt request 6</description>
        <value>225</value>
      </interrupt>
      <interrupt>
        <name>GPIO5_IRQ7</name>
        <description>GPIO5 interrupt request 7</description>
        <value>226</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO6</name>
      <baseAddress>0x49006000</baseAddress>
      <interrupt>
        <name>GPIO6_IRQ0</name>
        <description>GPIO6 interrupt request 0</description>
        <value>227</value>
      </interrupt>
      <interrupt>
        <name>GPIO6_IRQ1</name>
        <description>GPIO6 interrupt request 1</description>
        <value>228</value>
      </interrupt>
      <interrupt>
        <name>GPIO6_IRQ2</name>
        <description>GPIO6 interrupt request 2</description>
        <value>229</value>
      </interrupt>
      <interrupt>
        <name>GPIO6_IRQ3</name>
        <description>GPIO6 interrupt request 3</description>
        <value>230</value>
      </interrupt>
      <interrupt>
        <name>GPIO6_IRQ4</name>
        <description>GPIO6 interrupt request 4</description>
        <value>231</value>
      </interrupt>
      <interrupt>
        <name>GPIO6_IRQ5</name>
        <description>GPIO6 interrupt request 5</description>
        <value>232</value>
      </interrupt>
      <interrupt>
        <name>GPIO6_IRQ6</name>
        <description>GPIO6 interrupt request 6</description>
        <value>233</value>
      </interrupt>
      <interrupt>
        <name>GPIO6_IRQ7</name>
        <description>GPIO6 interrupt request 7</description>
        <value>234</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO7</name>
      <baseAddress>0x49007000</baseAddress>
      <interrupt>
        <name>GPIO7_IRQ0</name>
        <description>GPIO7 interrupt request 0</description>
        <value>235</value>
      </interrupt>
      <interrupt>
        <name>GPIO7_IRQ1</name>
        <description>GPIO7 interrupt request 1</description>
        <value>236</value>
      </interrupt>
      <interrupt>
        <name>GPIO7_IRQ2</name>
        <description>GPIO7 interrupt request 2</description>
        <value>237</value>
      </interrupt>
      <interrupt>
        <name>GPIO7_IRQ3</name>
        <description>GPIO7 interrupt request 3</description>
        <value>238</value>
      </interrupt>
      <interrupt>
        <name>GPIO7_IRQ4</name>
        <description>GPIO7 interrupt request 4</description>
        <value>239</value>
      </interrupt>
      <interrupt>
        <name>GPIO7_IRQ5</name>
        <description>GPIO7 interrupt request 5</description>
        <value>240</value>
      </interrupt>
      <interrupt>
        <name>GPIO7_IRQ6</name>
        <description>GPIO7 interrupt request 6</description>
        <value>241</value>
      </interrupt>
      <interrupt>
        <name>GPIO7_IRQ7</name>
        <description>GPIO7 interrupt request 7</description>
        <value>242</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO8</name>
      <baseAddress>0x49008000</baseAddress>
      <interrupt>
        <name>GPIO8_IRQ0</name>
        <description>GPIO8 interrupt request 0</description>
        <value>243</value>
      </interrupt>
      <interrupt>
        <name>GPIO8_IRQ1</name>
        <description>GPIO8 interrupt request 1</description>
        <value>244</value>
      </interrupt>
      <interrupt>
        <name>GPIO8_IRQ2</name>
        <description>GPIO8 interrupt request 2</description>
        <value>245</value>
      </interrupt>
      <interrupt>
        <name>GPIO8_IRQ3</name>
        <description>GPIO8 interrupt request 3</description>
        <value>246</value>
      </interrupt>
      <interrupt>
        <name>GPIO8_IRQ4</name>
        <description>GPIO8 interrupt request 4</description>
        <value>247</value>
      </interrupt>
      <interrupt>
        <name>GPIO8_IRQ5</name>
        <description>GPIO8 interrupt request 5</description>
        <value>248</value>
      </interrupt>
      <interrupt>
        <name>GPIO8_IRQ6</name>
        <description>GPIO8 interrupt request 6</description>
        <value>249</value>
      </interrupt>
      <interrupt>
        <name>GPIO8_IRQ7</name>
        <description>GPIO8 interrupt request 7</description>
        <value>250</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO9</name>
      <baseAddress>0x49009000</baseAddress>
      <interrupt>
        <name>GPIO9_IRQ0</name>
        <description>GPIO9 interrupt request 0</description>
        <value>251</value>
      </interrupt>
      <interrupt>
        <name>GPIO9_IRQ1</name>
        <description>GPIO9 interrupt request 1</description>
        <value>252</value>
      </interrupt>
      <interrupt>
        <name>GPIO9_IRQ2</name>
        <description>GPIO9 interrupt request 2</description>
        <value>253</value>
      </interrupt>
      <interrupt>
        <name>GPIO9_IRQ3</name>
        <description>GPIO9 interrupt request 3</description>
        <value>254</value>
      </interrupt>
      <interrupt>
        <name>GPIO9_IRQ4</name>
        <description>GPIO9 interrupt request 4</description>
        <value>255</value>
      </interrupt>
      <interrupt>
        <name>GPIO9_IRQ5</name>
        <description>GPIO9 interrupt request 5</description>
        <value>256</value>
      </interrupt>
      <interrupt>
        <name>GPIO9_IRQ6</name>
        <description>GPIO9 interrupt request 6</description>
        <value>257</value>
      </interrupt>
      <interrupt>
        <name>GPIO9_IRQ7</name>
        <description>GPIO9 interrupt request 7</description>
        <value>258</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO10</name>
      <baseAddress>0x4900A000</baseAddress>
      <interrupt>
        <name>GPIO10_IRQ0</name>
        <description>GPIO10 interrupt request 0</description>
        <value>259</value>
      </interrupt>
      <interrupt>
        <name>GPIO10_IRQ1</name>
        <description>GPIO10 interrupt request 1</description>
        <value>260</value>
      </interrupt>
      <interrupt>
        <name>GPIO10_IRQ2</name>
        <description>GPIO10 interrupt request 2</description>
        <value>261</value>
      </interrupt>
      <interrupt>
        <name>GPIO10_IRQ3</name>
        <description>GPIO10 interrupt request 3</description>
        <value>262</value>
      </interrupt>
      <interrupt>
        <name>GPIO10_IRQ4</name>
        <description>GPIO10 interrupt request 4</description>
        <value>263</value>
      </interrupt>
      <interrupt>
        <name>GPIO10_IRQ5</name>
        <description>GPIO10 interrupt request 5</description>
        <value>264</value>
      </interrupt>
      <interrupt>
        <name>GPIO10_IRQ6</name>
        <description>GPIO10 interrupt request 6</description>
        <value>265</value>
      </interrupt>
      <interrupt>
        <name>GPIO10_IRQ7</name>
        <description>GPIO10 interrupt request 7</description>
        <value>266</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO11</name>
      <baseAddress>0x4900B000</baseAddress>
      <interrupt>
        <name>GPIO11_IRQ0</name>
        <description>GPIO11 interrupt request 0</description>
        <value>267</value>
      </interrupt>
      <interrupt>
        <name>GPIO11_IRQ1</name>
        <description>GPIO11 interrupt request 1</description>
        <value>268</value>
      </interrupt>
      <interrupt>
        <name>GPIO11_IRQ2</name>
        <description>GPIO11 interrupt request 2</description>
        <value>269</value>
      </interrupt>
      <interrupt>
        <name>GPIO11_IRQ3</name>
        <description>GPIO11 interrupt request 3</description>
        <value>270</value>
      </interrupt>
      <interrupt>
        <name>GPIO11_IRQ4</name>
        <description>GPIO11 interrupt request 4</description>
        <value>271</value>
      </interrupt>
      <interrupt>
        <name>GPIO11_IRQ5</name>
        <description>GPIO11 interrupt request 5</description>
        <value>272</value>
      </interrupt>
      <interrupt>
        <name>GPIO11_IRQ6</name>
        <description>GPIO11 interrupt request 6</description>
        <value>273</value>
      </interrupt>
      <interrupt>
        <name>GPIO11_IRQ7</name>
        <description>GPIO11 interrupt request 7</description>
        <value>274</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO12</name>
      <baseAddress>0x4900C000</baseAddress>
      <interrupt>
        <name>GPIO12_IRQ0</name>
        <description>GPIO12 interrupt request 0</description>
        <value>275</value>
      </interrupt>
      <interrupt>
        <name>GPIO12_IRQ1</name>
        <description>GPIO12 interrupt request 1</description>
        <value>276</value>
      </interrupt>
      <interrupt>
        <name>GPIO12_IRQ2</name>
        <description>GPIO12 interrupt request 2</description>
        <value>277</value>
      </interrupt>
      <interrupt>
        <name>GPIO12_IRQ3</name>
        <description>GPIO12 interrupt request 3</description>
        <value>278</value>
      </interrupt>
      <interrupt>
        <name>GPIO12_IRQ4</name>
        <description>GPIO12 interrupt request 4</description>
        <value>279</value>
      </interrupt>
      <interrupt>
        <name>GPIO12_IRQ5</name>
        <description>GPIO12 interrupt request 5</description>
        <value>280</value>
      </interrupt>
      <interrupt>
        <name>GPIO12_IRQ6</name>
        <description>GPIO12 interrupt request 6</description>
        <value>281</value>
      </interrupt>
      <interrupt>
        <name>GPIO12_IRQ7</name>
        <description>GPIO12 interrupt request 7</description>
        <value>282</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO13</name>
      <baseAddress>0x4900D000</baseAddress>
      <interrupt>
        <name>GPIO13_IRQ0</name>
        <description>GPIO13 interrupt request 0</description>
        <value>283</value>
      </interrupt>
      <interrupt>
        <name>GPIO13_IRQ1</name>
        <description>GPIO13 interrupt request 1</description>
        <value>284</value>
      </interrupt>
      <interrupt>
        <name>GPIO13_IRQ2</name>
        <description>GPIO13 interrupt request 2</description>
        <value>285</value>
      </interrupt>
      <interrupt>
        <name>GPIO13_IRQ3</name>
        <description>GPIO13 interrupt request 3</description>
        <value>286</value>
      </interrupt>
      <interrupt>
        <name>GPIO13_IRQ4</name>
        <description>GPIO13 interrupt request 4</description>
        <value>287</value>
      </interrupt>
      <interrupt>
        <name>GPIO13_IRQ5</name>
        <description>GPIO13 interrupt request 5</description>
        <value>288</value>
      </interrupt>
      <interrupt>
        <name>GPIO13_IRQ6</name>
        <description>GPIO13 interrupt request 6</description>
        <value>289</value>
      </interrupt>
      <interrupt>
        <name>GPIO13_IRQ7</name>
        <description>GPIO13 interrupt request 7</description>
        <value>290</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPGPIO">
      <name>GPIO14</name>
      <baseAddress>0x4900E000</baseAddress>
      <interrupt>
        <name>GPIO14_IRQ0</name>
        <description>GPIO14 interrupt request 0</description>
        <value>291</value>
      </interrupt>
      <interrupt>
        <name>GPIO14_IRQ1</name>
        <description>GPIO14 interrupt request 1</description>
        <value>292</value>
      </interrupt>
      <interrupt>
        <name>GPIO14_IRQ2</name>
        <description>GPIO14 interrupt request 2</description>
        <value>293</value>
      </interrupt>
      <interrupt>
        <name>GPIO14_IRQ3</name>
        <description>GPIO14 interrupt request 3</description>
        <value>294</value>
      </interrupt>
      <interrupt>
        <name>GPIO14_IRQ4</name>
        <description>GPIO14 interrupt request 4</description>
        <value>295</value>
      </interrupt>
      <interrupt>
        <name>GPIO14_IRQ5</name>
        <description>GPIO14 interrupt request 5</description>
        <value>296</value>
      </interrupt>
      <interrupt>
        <name>GPIO14_IRQ6</name>
        <description>GPIO14 interrupt request 6</description>
        <value>297</value>
      </interrupt>
      <interrupt>
        <name>GPIO14_IRQ7</name>
        <description>GPIO14 interrupt request 7</description>
        <value>298</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <groupName>I2C</groupName>
      <baseAddress>0x49010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>I2C0_IRQ</name>
        <description>I2C0 interrupt request</description>
        <value>132</value>
      </interrupt>
      <registers>
        <register>
          <name>I2C_CON</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000007D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_CLEAR_FEATURE_CTRL</name>
              <description>In Master mode:
In Slave mode this bit is not applicable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Bus Clear Feature is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Bus Clear Feature is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_DET_IF_MASTER_ACTIVE</name>
              <description>In Master mode:</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master issues the STOP_DET interrupt irrespective of whether master is active or not.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master issues the STOP_DET interrupt only when master is active.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_FIFO_FULL_HLD_CTRL</name>
              <description>This bit controls whether I2C should hold the bus when the Rx FIFO is physically full to its IC_COMP_PARAM_1[RX_BUFFER_DEPTH].</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Overflow when RX_FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Hold bus when RX_FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_EMPTY_CTRL</name>
              <description>This bit controls the generation of the TX_EMPTY interrupt, as described in the I2C_RAW_INTR_STAT[TX_EMPTY].</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Default behaviour of TX_EMPTY interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Controlled generation of TX_EMPTY interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_DET_IFADDRESSED</name>
              <description>In Slave mode:
During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 0x1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Issues the STOP_DET irrespective of whether it is addressed or not.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Issues the STOP_DET interrrupt only when it is addressed.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_SLAVE_DISABLE</name>
              <description>This bit controls whether I2C has its slave disabled.
If this bit is set, the Slave mode is disabled, and I2C functions only as a master; it does not perform any action that requires a slave.
Software should ensure that if this bit is set to 0, then bit MASTER_MODE should also be set to 0.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave mode is enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave mode is disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_RESTART_EN</name>
              <description>Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several I2C operations. When RESTART is disabled, the master is prohibited from performing the following functions:
- Sending a START BYTE
- Performing any high-speed mode operation
- Performing direction changes in combined format mode
- Performing a read operation with a 10-bit address</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master restart disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master restart enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_10BITADDR_MASTER_RD_ONLY</name>
              <description>The function of this bit is handled by I2C_TAR[IC_10BITADDR_MASTER] bit, and it is read only.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master 7-bit addressing mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master 10-bit addressing mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_10BITADDR_SLAVE</name>
              <description>When acting as a slave, this bit controls whether the I2C responds to 7-bit or 10-bit addresses.
0x0: 7-bit addressing. The I2C ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the I2C_SAR register are compared.
0x1: 10-bit addressing. The I2C responds to only 10-bit addressing transfers that match the full 10 bits of the I2C_SAR register.
0x0: Slave 7-bit addressing
0x1: Slave 10-bit addressing</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPEED</name>
              <description>These bits control at which speed the I2C operates; its setting is relevant only if the I2C operates in Master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for Slave mode also, as they are used to capture correct value of spike filter as per the speed mode.
This register should be programmed only with a value in the range of 1 to 2.</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Standard mode of operation</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Fast or Fast Plus mode of operation</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>This bit controls whether the I2C master is enabled.
NOTE:
Software should ensure that if this bit is set to 1, bit IC_SLAVE_DISABLE should also be set to 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master mode is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master mode is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TAR</name>
          <description>Target Address Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001055</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEVICE_ID</name>
              <description>If bit SPECIAL is set to 1, then this bit indicates whether a Device-ID of a particular slave mentioned in I2C_TAR[IC_TAR] is to be performed by the I2C Master.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables programming of DEVICE-ID transmission. Device-ID is not performed and checks I2C_TAR[GC_OR_START] to perform either general call or START byte command.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables programming of DEVICE-ID transmission. Device-ID transfer is performed and bytes based on the number of read commands in the Tx FIFO are received from the targeted slave and put in the Rx FIFO.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_10BITADDR_MASTER</name>
              <description>This bit controls whether the I2C starts its transfers in 7-bit or 10-bit addressing mode when acting as a master.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>7-bit addressing mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>10-bit addressing mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPECIAL</name>
              <description>This bit indicates whether software performs a DEVICE_ID or General Call or START BYTE command.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables programming of GENERAL_CALL or START_BYTE transmission. Ignore GC_OR_START bit and use I2C_TAR normally.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables programming of GENERAL_CALL or START_BYTE transmission. Perform special I2C command as specified in Device_ID or GC_OR_START bit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GC_OR_START</name>
              <description>If bit SPECIAL is set to 1 and bit DEVICE_ID is set to 0, then this bit indicates whether a General Call or START byte command is performed by the I2C.
General Call Address-after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting I2C_RAW_INTR_STAT[TX_ABRT] bit. The I2C remains in General Call mode until the SPECIAL bit value is cleared.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GENERAL_CALL byte transmission</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START BYTE transmission</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_TAR</name>
              <description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START_BYTE command, the CPU needs to write only once into these bits.
If the I2C_TAR and I2C_SAR[IC_SAR] are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master can not transmit to itself; it can transmit to only a slave.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SAR</name>
          <description>Slave Address Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000055</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SAR</name>
              <description>The I2C_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, the I2C_SAR[IC_SAR] bit field is [6-0].
This field is written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit set to 0x0. Writes at other times have no effect.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DATA_CMD</name>
          <description>Rx/Tx Data Buffer and Command Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESTART</name>
              <description>This bit controls whether a RESTART condition is issued before the byte is sent or received.</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>If I2C_CON[IC_RESTART_EN] bit is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>If I2C_CON[IC_RESTART_EN] bit is 1, a RESTART is issued before the data is sent/received (according to the value of bit CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP</name>
              <description>This bit controls whether a STOP condition is issued after the byte is sent or received.</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD</name>
              <description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C acts as a slave. It controls only the direction when it acts as a master.
When a command is entered in the Tx FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a 0 indicates that the data in I2C_DATA_CMD[DAT] bit is to be transmitted.
 When this bit is programmed attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (I2C_RAW_INTR_STAT[TX_ABRT] bit), unless the I2C_TAR[SPECIAL] bit has been cleared. If a 1 is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master write command</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master read command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAT</name>
              <description>This field contains the data to be transmitted or received on the I2C bus. 
If a write to this register is performed and a read is needed, field DAT is ignored by the I2C.
If a read is preformed, these bits return the value of data received on the I2C interface.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SS_SCL_HCNT</name>
          <description>Standard Speed SCL High Count Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000190</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SS_SCL_HCNT</name>
              <description>This field must be set before any I2C bus transaction can take place to ensure proper I/O timing. It sets the SCL clock high-period count for Standard Speed.
This field is written only when the I2C interface is disabled which corresponds to the I2C_ENABLE[ENABLE] bit is set to 0x0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
Note: This field must not be programmed to a value higher than 65525, because I2C uses a 16-bit counter to flag an I2C bus IDLE condition when this counter reaches a value of I2C_SS_SCL_HCNT + 10.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SS_SCL_LCNT</name>
          <description>Standard Speed SCL Low Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000001D6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SS_SCL_LCNT</name>
              <description>This field must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for Standard Speed. 
This field is written only when the I2C interface is disabled which corresponds to the I2C_ENABLE[ENABLE] bit is set to 0x0. Writes at other times have no effect.
The minimum valid value is 8; Hardware prevents values less than this being written, and if attempted, results in 8 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_FS_SCL_HCNT</name>
          <description>Fast Mode or Fast Mode Plus SCL High Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_FS_SCL_HCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for Fast mode or Fast mode plus. 
This register is written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit is set to 0x0. Writes at other times have no effect.
The minimum valid value is 6; Hardware prevents values less than this being written, and if attempted results in 6 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_FS_SCL_LCNT</name>
          <description>Fast Mode or Fast Mode Plus SCL Low Count Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000082</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_FS_SCL_LCNT</name>
              <description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for Fast-Speed.
This register is written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE[ENABLE] bit is set to 0x0. Writes at other times have no effect.
The minimum valid value is 8; Hardware prevents values less than this being written, and if attempted results in 8 being set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_INTR_STAT</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>R_SCL_STUCK_AT_LOW</name>
              <description>See also I2C_RAW_INTR_STAT[SCL_STUCK_AT_LOW]</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_SCL_STUCK_AT_LOW interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_SCL_STUCK_AT_LOW interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_MASTER_ON_HOLD</name>
              <description>See also I2C_RAW_INTR_STAT[MASTER_ON_HOLD]</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_MASTER_ON_HOLD interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_MASTER_ON_HOLD interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RESTART_DET</name>
              <description>See also I2C_RAW_INTR_STAT[RESTART_DET]</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RESTART_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RESTART_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_GEN_CALL</name>
              <description>See also I2C_RAW_INTR_STAT[GEN_CALL]</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_GEN_CALL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_GEN_CALL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_START_DET</name>
              <description>See also I2C_RAW_INTR_STAT[START_DET]</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_START_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_START_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_STOP_DET</name>
              <description>See also I2C_RAW_INTR_STAT[STOP_DET]</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_STOP_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_STOP_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_ACTIVITY</name>
              <description>See also I2C_RAW_INTR_STAT[ACTIVITY]</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_ACTIVITY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_ACTIVITY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_DONE</name>
              <description>See also I2C_RAW_INTR_STAT[RX_DONE]</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_DONE interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_DONE interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_TX_ABRT</name>
              <description>See also I2C_RAW_INTR_STAT[TX_ABRT]</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_TX_ABRT interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_TX_ABRT interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RD_REQ</name>
              <description>See also I2C_RAW_INTR_STAT[RD_REQ]</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RD_REQ interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RD_REQ interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_TX_EMPTY</name>
              <description>See also I2C_RAW_INTR_STAT[TX_EMPTY]</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_TX_EMPTY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_TX_EMPTY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_TX_OVER</name>
              <description>See also I2C_RAW_INTR_STAT[TX_OVER]</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_TX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_TX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_FULL</name>
              <description>See also I2C_RAW_INTR_STAT[RX_FULL]</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_FULL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_FULL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_OVER</name>
              <description>See also I2C_RAW_INTR_STAT[RX_OVER]</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>R_RX_UNDER</name>
              <description>See also I2C_RAW_INTR_STAT[RX_UNDER]</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>R_RX_UNDER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>R_RX_UNDER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_INTR_MASK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000048FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>M_SCL_STUCK_AT_LOW</name>
              <description>This bit masks the R_SCL_STUCK_AT_LOW interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SCL_STUCK_AT_LOW interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SCL_STUCK_AT_LOW interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_MASTER_ON_HOLD_READ_ONLY</name>
              <description>This bit masks the M_MASTER_ON_HOLD_READ_ONLY interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MASTER_ON_HOLD interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MASTER_ON_HOLD interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RESTART_DET_READ_ONLY</name>
              <description>This bit masks the M_RESTART_DET_READ_ONLY interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RESTART_DET interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RESTART_DET interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_GEN_CALL</name>
              <description>This bit masks the R_GEN_CALL interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GEN_CALL interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GEN_CALL interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_START_DET</name>
              <description>This bit masks the R_START_DET interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>START_DET interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START_DET interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_STOP_DET</name>
              <description>This bit masks the R_STOP_DET interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>STOP_DET interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STOP_DET interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_ACTIVITY</name>
              <description>This bit masks the R_ACTIVITY interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACTIVITY interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACTIVITY interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_DONE</name>
              <description>This bit masks the R_RX_DONE interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_DONE interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_DONE interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_TX_ABRT</name>
              <description>This bit masks the R_TX_ABRT interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_ABORT interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_ABORT interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RD_REQ</name>
              <description>This bit masks the R_RD_REQ interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RD_REQ interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RD_REQ interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_TX_EMPTY</name>
              <description>This bit masks the R_TX_EMPTY interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_EMPTY interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_EMPTY interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_TX_OVER</name>
              <description>This bit masks the R_TX_OVER interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_OVER interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_OVER interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_FULL</name>
              <description>This bit masks the R_RX_FULL interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_FULL interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_FULL interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_OVER</name>
              <description>This bit masks the R_RX_OVER interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_OVER interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_OVER interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>M_RX_UNDER</name>
              <description>This bit masks the R_RX_UNDER interrupt in I2C_INTR_STAT register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_UNDER interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_UNDER interrupt is unmasked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_RAW_INTR_STAT</name>
          <description>Raw Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCL_STUCK_AT_LOW</name>
              <description>Indicates whether the SCL Line is stuck at low for the IC_SCL_STUCK_LOW_TIMEOUT number of IC_CLK periods.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SCL_STUCK_AT_LOW interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SCL_STUCK_AT_LOW interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MASTER_ON_HOLD</name>
              <description>Indicates whether master is holding the bus and TX FIFO is empty.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>MASTER_ON_HOLD interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MASTER_ON_HOLD interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESTART_DET</name>
              <description>Indicates whether a RESTART condition has occurred on the I^2C interface when I2C is operating in Slave mode and the slave is being addressed.
During a Start Byte transfer, the RESTART comes before the address field as per the I^2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore I2C does not generate the RESTART_DET interrupt.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RESTART_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RESTART_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_CALL</name>
              <description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling I2C or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C stores the received data in the Rx buffer.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GEN_CALL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GEN_CALL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START_DET</name>
              <description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether I2C is operating in Slave or Master mode.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>START_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_DET</name>
              <description>Indicates whether a STOP condition has occurred on the I^2C interface regardless of whether I2C is operating in Slave or Master mode.
In Slave mode:
If I2C_CON[STOP_DET_IFADDRESSED] is set to 0x1 , the STOP_DET interrupt will be issued only if slave is addressed.
Note: During a general call address, this slave does not issue a STOP_DET interrupt if I2C_CON[STOP_DET_IFADDRESSED] is set to 0x1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).
If I2C_CON[STOP_DET_IFADDRESSED] is set to 0x0, the STOP_DET interrupt is issued irrespective of whether it is being addressed.
In Master mode:
If I2C_CON[STOP_DET_IF_MASTER_ACTIVE] is set to 0x1, the STOP_DET interrupt will be issued only if master is active.
If I2C_CON[STOP_DET_IF_MASTER_ACTIVE] is set to 0x0, the STOP_DET interrupt will be issued irrespective of whether master is active or not.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>STOP_DET interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STOP_DET interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVITY</name>
              <description>This bit captures I2C activity and stays set until it is cleared. There are four ways to clear it:
- Disabling the I2C
- Reading the I2C_CLR_ACTIVITY register
- Reading the I2C_CLR_INTR register
- System reset</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RAW_INTR_ACTIVITY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RAW_INTR_ACTIVITY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_DONE</name>
              <description>When the I2C is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_DONE interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_DONE interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_ABRT</name>
              <description>This bit indicates if I2C, as an I2C transmitter, is unable to complete the intended actions on the contents of theTx FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a transmit abort. When this bit is set to 0x1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
The I2C flushes/resets/empties only the TX_FIFO whenever there is a transmit abort caused by any of the events tracked by the I2C_TX_ABRT_SOURCE register. The Tx FIFO remains in this flushed state until the I2C_CLR_TX_ABRT register is read. Once this read is performed, theTx FIFO is then ready to accept more data bytes from the APB interface.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_ABRT interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_ABRT interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RD_REQ</name>
              <description>This bit is set to 0x1 when I2C is acting as a slave and another I2C master is attempting to read data from I2C. The I2C holds the I2C bus in a wait state until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write there quested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RD_REQ interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RD_REQ interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>The behavior of the TX_EMPTY interrupt status differs based on the selection in the I2C_CON[TX_EMPTY_CTRL] bit.
When TX_EMPTY_CTRL is set to 0x0:
This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register.
When TX_EMPTY_CTRL is set to 0x1:
This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_EMPTY interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_EMPTY interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_OVER</name>
              <description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the I2C_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into IDLE, and when I2C_ENABLE[ENABLE] goes to 0x0, this interrupt is cleared.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>TX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[ENABLE] is set to 0x0), the Rx FIFO is flushed and held in reset; therefore the Rx FIFO is not full. So, this bit is cleared once the I2C_ENABLE[ENABLE] bit is set to 0x0, regardless of the activity that continues.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_FULL interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_FULL interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_OVER</name>
              <description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The I2C acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[ENABLE] is set ot 0x0), this bit keeps its level until the master or slave state machines go into IDLE, and when I2C_ENABLE[ENABLE] is set ot 0x0, this interrupt is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_OVER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_OVER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_UNDER</name>
              <description>Set if the processor attempts to read the receive buffer when it is empty by reading from the I2C_DATA_CMD register. If the module is disabled(I2C_ENABLE[ENABLE] is set ot 0x0), this bit keeps its level until the master or slave state machines go into IDLE, and when I2C_ENABLE[ENABLE] is set ot 0x0, this interrupt is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RX_UNDER interrupt is inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RX_UNDER interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_RX_TL</name>
          <description>Receive FIFO Threshold Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_TL</name>
              <description>Controls the level of entries (or above) that triggers the RX_FULL interrupt (I2C_RAW_INTR_STAT[RX_FULL] bit). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TX_TL</name>
          <description>Transmit FIFO Threshold Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_TL</name>
              <description>Controls the level of entries (or below) that triggers the TX_EMPTY interrupt (I2C_RAW_INTR_STAT[TX_EMPTY] bit). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_INTR</name>
          <description>Clear Combined and Individual Interrupt Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_INTR</name>
              <description>Read this bit to:
 - Clear the combined interrupt;
- Clear all individual interrupts;
- Clear the I2C_TX_ABRT_SOURCE register;
This bit does not clear hardware clearable interrupts. Refer to the I2C_TX_ABRT_SOURCE[ABRT_SBYTE_NORSTRT] bit for an exception to clearing it.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RX_UNDER</name>
          <description>Clear RX_UNDER Interrupt Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RX_UNDER</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RX_UNDER] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RX_OVER</name>
          <description>Clear RX_OVER Interrupt Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RX_OVER</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RX_OVER] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_TX_OVER</name>
          <description>Clear TX_OVER Interrupt Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_TX_OVER</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[TX_OVER] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RD_REQ</name>
          <description>Clear RD_REQ Interrupt Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RD_REQ</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RD_REQ] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_TX_ABRT</name>
          <description>Clear TX_ABRT Interrupt Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_TX_ABRT</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[TX_ABRT] bit, and the I2C_TX_ABRT_SOURCE register. This also releases the Tx FIFO from the flushed/reset state, allowing more writes to the Tx FIFO. Refer to I2C_TX_ABRT_SOURCE[ABRT_SBYTE_NORSTRT] bit for an exception to clearing it.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_RX_DONE</name>
          <description>Clear RX_DONE Interrupt Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_RX_DONE</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[RX_DONE] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_ACTIVITY</name>
          <description>Clear ACTIVITY Interrupt Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_ACTIVITY</name>
              <description>Reading this bit clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this bit give status of the I2C_RAW_INTR_STAT[ACTIVITY] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_STOP_DET</name>
          <description>Clear STOP_DET Interrupt Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_STOP_DET</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[STOP_DET] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_START_DET</name>
          <description>Clear START_DET Interrupt Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_START_DET</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[START_DET] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_GEN_CALL</name>
          <description>Clear GEN_CALL Interrupt Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_GEN_CALL</name>
              <description>Read this bit to clear the I2C_RAW_INTR_STAT[GEN_CALL] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ENABLE</name>
          <description>Enable Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_STUCK_RECOVERY_ENABLE</name>
              <description>If SDA is stuck at low indicated through the TX_ABORT interrupt(I2C_TX_ABRT_SOURCE[TX_ABORT] bit), then this bit is used as a control knob to initiate the SDA recovery mechanism (that is, send at most 9 SCL clocks and STOP to release the SDA line) and then this bit gets auto clear.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master disables the SDA stuck at low recovery mechanism</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master initates the SDA stuck at low recovery mechanism</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_CMD_BLOCK</name>
              <description>In Master mode:
To block the execution of master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (I2C_STATUS[TFE] set to 0x1) and master is in IDLE state (I2C_STATUS[MST_ACTIVITY] is set to 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx Command execution not blocked. The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx Command execution blocked. Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABORT</name>
              <description>When set, the controller initiates the transfer abort.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ABORT operation not in progress</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ABORT operation in progress</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Controls whether the I2C is enabled.
When I2C is disabled, the following occurs:
- The Tx FIFO and Rx FIFO get flushed.
- Status bits in the I2C_INTR_STAT register are still active until I2C goes into IDLE state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables I2C (Tx and Rx FIFOs are held in an erased state)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables I2C</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_STUCK_NOT_RECOVERED</name>
              <description>This bit indicates that SDA stuck at low is not recovered after the recovery mechanism. In Slave mode, this register bit is not applicable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SDA Stuck at low is not recovered after recovery mechanism</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SDA Stuck at low is recovered after recovery mechanism</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLV_ACTIVITY</name>
              <description>Slave Finite State Machine (FSM) Activity Status. 
When the Slave is not in the IDLE state, this bit is set.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave FSM is in IDLE state-the slave part of I2C is not Active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave FSM is not in IDLE state-the slave part of I2C is Active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MST_ACTIVITY</name>
              <description>Master FSM Activity Status. 
When the Master is not in the IDLE state, this bit is set.
Note: I2C_STATUS[ACTIVITY] bit is an OR of SLV_ACTIVITY and MST_ACTIVITY bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master FSM is in IDLE state-the master part of I2C is not Active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master FSM is not in IDLE state-the master part of I2C is Active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Completely Full. 
When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO is full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Receive FIFO Not Empty.
This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO not empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Completely Empty. 
When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit iscleared. This bit does not request an interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO not empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO is empty</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Transmit FIFO Not Full. 
Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO is full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO not full</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVITY</name>
              <description>I2C Activity Status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2C is IDLE</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2C is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TXFLR</name>
          <description>Transmit FIFO Level Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFLR</name>
              <description>Tx FIFO Level
Contains the number of valid data entries in the Tx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_RXFLR</name>
          <description>Receive FIFO Level Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFLR</name>
              <description>Rx FIFO Level.
Contains the number of valid data entries in the Rx FIFO.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SDA_HOLD</name>
          <description>SDA Hold Time Length Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SDA_RX_HOLD</name>
              <description>Sets the required SDA hold time in units of IC_CLK period, when I2C acts as a receiver.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IC_SDA_TX_HOLD</name>
              <description>Sets the required SDA hold time in units of IC_CLK period, when I2C acts as a transmitter.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_TX_ABRT_SOURCE</name>
          <description>Transmit Abort Source Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_FLUSH_CNT</name>
              <description>This field indicates the number of Tx FIFO data commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled.
Role of I2C: Master-Transmitter or Slave-Transmitter</description>
              <bitRange>[31:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRT_DEVICE_WRITE</name>
              <description>This is a master-mode-only bit. Master is initiating the DEVICE_ID transfer and the Tx FIFO consists of write commands.
Role of I2C: Master</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>This abort is generated because of NOACK for slave address</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_DEVICE_SLVADDR_NOACK</name>
              <description>This is a master-mode-only bit. Master is initiating the DEVICE_ID transfer and the slave address sent was not acknowledged by any slave.
Role of I2C: Master</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>This abort is generated because of NOACK for slave address</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_DEVICE_NOACK</name>
              <description>This is a master-mode-only bit. Master is initiating the DEVICE_ID transfer and the device id sent was not acknowledged by any slave.
Role of I2C: Master</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>This abort is generated because of NOACK for DEVICE-ID</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SDA_STUCK_AT_LOW</name>
              <description>This is a master-mode-only bit. Master detects the SDA stuck at low for the IC_CLK.
Role of I2C: Master</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>This abort is generated because of SDA stuck at low for the IC_CLK</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_USER_ABRT</name>
              <description>This is a master-mode-only bit. Master has detected the transfer abort (I2C_ENABLE[ABORT] bit).
Role of I2C: Master-Transmitter</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transfer abort detected by master-scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transfer abort detected by master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SLVRD_INTX</name>
              <description>When the processor side responds to a Slave mode request for data to be transmitted to a remote master and I2C_DATA_CMD[CMD] bit is set to 0x1.
Role of I2C: Slave-Transmitter</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave trying to transmit to remote master in read mode- scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave trying to transmit to remote master in read mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SLV_ARBLOST</name>
              <description>This field indicates that a slave has lost the bus while transmitting data to a remote master. The I2C_TX_ABRT_SOURCE[ARB_LOST] is set at the same time.
Even though the slave never owns the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then I2C no longer own the bus.
Role of I2C: Slave-Transmitter</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave lost arbitration to remote master- scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave lost arbitration to remote master</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SLVFLUSH_TXFIFO</name>
              <description>This field specifies that the slave has received a read command and some data exists in the Tx FIFO, so the slave issues a TX_ABRT interrupt to flush old data in Tx FIFO.
Role of I2C: Slave-Transmitter</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave flushes existing data in Tx FIFO upon getting read command- scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave flushes existing data in Tx FIFO upon getting read command</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ARB_LOST</name>
              <description>This field specifies that the master has lost arbitration, or if I2C_TX_ABRT_SOURCE[ABRT_SLV_ARBLOST] is also set, then the slave transmitter has lost arbitration.
Role of I2C: Master-Transmitter or Slave-Transmitter</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master or Slave-Transmitter lost arbitration- scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master or Slave-Transmitter lost arbitration</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_MASTER_DIS</name>
              <description>This field indicates the master operation with the Master mode disabled.
Role of I2C: Master-Transmitter or Master-Receiver</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Initiate master operation when Master disabled- scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Intitate master operation when Master disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_10B_RD_NORSTRT</name>
              <description>This field indicates that the restart is disabled (I2C_CON[IC_RESTART_EN] bit set to 0x0) and the master sends a read command in 10-bit addressing mode.
Role of I2C: Master-Receiver</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master not read in 10-bit addressing mode when RESTART disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master read in 10-bit addressing mode when RESTART disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SBYTE_NORSTRT</name>
              <description>To clear the ABRT_SBYTE_NORSTRT must be fixed first;
- Restart must be enabled (I2C_CON[IC_RESTART_EN] is set to 0x1);
- I2C_TAR[SPECIAL] bit must be cleared;
- I2C_TAR[GC_OR_START] bit must be cleared;
Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit is cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, it clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (I2C_CON[IC_RESTART_EN] bit is set to 0x0) and then send a START Byte.
Role of I2C: Master</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Send START byte when RESTART disabled- scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Send START byte when RESTART disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_SBYTE_ACKDET</name>
              <description>This field indicates that the master has sent a START byte and the START byte was acknowledged (wrong behavior).
Role of I2C: Master</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK detected for START byte- scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACK detected for START byte</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_GCALL_READ</name>
              <description>This field indicates that I2C in the Master mode has sent a General Call but following programmed byte the General Call to be a read from the bus (I2C_DATA_CMD[CMD] is set to 0x1).
Role of I2C: Master-Transmitter</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GCALL is followed by read from bus-scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GCALL is followed by read from bus</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_GCALL_NOACK</name>
              <description>This field indicates that I2C in Master mode has sent a General Call and no slave on the bus acknowledged the General Call.
Role of I2C: Master-Transmitter</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GCALL not acknowledged by any slave-scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GCALL not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_TXDATA_NOACK</name>
              <description>This field indicates the master-mode-only bit. 
When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
Role of I2C: Master-Transmitter</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmitted data not acknowledged by addressed slave-scenario not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmitted data not acknowledged by addressed slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_10ADDR2_NOACK</name>
              <description>This field indicates that the master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave.
Role of I2C: Master-Transmitter or Master-Receiver</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 2 of 10-bit address not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_10ADDR1_NOACK</name>
              <description>This field indicates that the master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
Role of I2C: Master-Transmitter or Master-Receiver</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Byte 1 of 10-bit address not acknowledged by any slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ABRT_7B_ADDR_NOACK</name>
              <description>This field indicates that the master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
Role of I2C: Master-Transmitter or Master-Receiver</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>This abort is not generated</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>This abort is generated because of NOACK for 7-bit address</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DMA_CR</name>
          <description>DMA Control Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDMAE</name>
              <description>Transmit DMA Enable. 
This bit enables/disables the Tx FIFO DMA channel.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Tx FIFO DMA channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Tx FIFO DMA channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDMAE</name>
              <description>Receive DMA Enable.
This bit enables/disables the Rx FIFO DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Rx FIFO DMA channel disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Rx FIFO DMA channel enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DMA_TDLR</name>
          <description>DMA Transmit Data Level Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMATDL</name>
              <description>Transmit Data Level.
This field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the I2C_DMA_TX signal is generated when the number of valid data entries in the Tx FIFO is equal to or below this field value, and I2C_DMA_CR[TDMAE] is set to 0x1.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DMA_RDLR</name>
          <description>DMA Transmit Data Level Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMARDL</name>
              <description>Receive Data Level. 
This field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL + 1; that is, I2C_DMA_RX is generated when the numberof valid data entries in the Rx FIFO is equal to or more than this field value + 1, and I2C_DMA_CR[RDMAE] is set to 0x1. For instance, when IC_DMA_RDLR[DMARDL] is set to 0x0, then I2C_DMA_RX is asserted when 1 or more data entries are present in the Rx FIFO.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SDA_SETUP</name>
          <description>SDA Setup Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000064</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_SETUP</name>
              <description>SDA Setup
It is recommended that if the required delay is 1000 ns, then for an IC_CLK frequency of 10 MHz, I2C_SDA_SETUP should be programmed to a value of 11. I2C_SDA_SETUP must be programmed with a minimum value of 2.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ACK_GENERAL_CALL</name>
          <description>ACK General Call Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACK_GEN_CALL</name>
              <description>ACK General Call
When set to 1, I2C responds with a ACK when it receives a General Call. Otherwise, I2C responds with a NACK.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Generates NACK for General Call</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Generates ACK for a General Call</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_ENABLE_STATUS</name>
          <description>Enable Status Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLV_RX_DATA_LOST</name>
              <description>Slave Received Data Lost. 
This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting I2C_ENABLE[ENABLE] bit from 0x1 to 0x0. When read as 0x1, I2C is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.
If the remote I2C master terminates the transfer with a STOP condition before the I2C has a chance to NACK transfer, and I2C_ENABLE[ENABLE] has been set to 0, then this bit is also set to 0x1.
When read as 0x0, I2C is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
The CPU can safely read this bit when IC_EN is read as 0x0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave RX data is not lost</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave RX data is lost</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLV_DISABLED_WHILE_BUSY</name>
              <description>Slave Disabled While Busy (Transmit, Receive). 
This bit indicates if a potential or active slave operation has been aborted due to the setting I2C_ENABLE[ENABLE] bit from 0x1 to 0x0. This bit is set when the CPU writes a 0x0 to the I2C_ENABLE register while:
- I2C is receiving the address byte of the Slave-Transmitter operation from a remote master;
- Address and data bytes of the Slave-Receiver operation from a remote master;
When read as 0x1, I2C is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C (I2C_SAR register) OR if the transfer is completed before I2C_ENABLE is set to 0x0 but has not taken effect.
If the remote I2C master terminates the transfer with a STOP condition before the I2C has a chance to NACK a transfer, and I2C_ENABLE[ENABLE] has been set to 0x0, then this bit will also be set to 0x1.
When read as 0x0, I2C is deemed to have been disabled when there is master activity, or when the I2C bus is IDLE.
The CPU can safely read this bit when IC_EN bit is read as 0x0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave is disabled when it is IDLE</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave is disabled when it is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IC_EN</name>
              <description>The CPU can safely read this bit anytime.
When this bit is read as 0x0, the CPU can safely read SLV_RX_DATA_LOST bit and SLV_DISABLED_WHILE_BUSY bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2C is deemed completely inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2C is deemed to be in an enabled state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_FS_SPKLEN</name>
          <description>SS, FS or FM+ Spike Suppression Limit Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_FS_SPKLEN</name>
              <description>This field must be set before any I2C bus transaction can take place to ensure stable operation. 
This register sets the duration, measured in IC_CLK cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. 
This register is written only when the I2C interface is disabled which corresponds to the I2C_ENABLE[ENABLE] register being set to 0x0. 
Writes at other times have no effect. The minimum valid value is 0x1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SCL_STUCK_AT_LOW_TIMEOUT</name>
          <description>SCL Stuck at Low Timeout Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SCL_STUCK_LOW_TIMEOUT</name>
              <description>I2C generates the interrupt to indicate SCL stuck at low (I2C_RAW_INTR_STAT[SCL_STUCK_AT_LOW]) if it detects the SCL stuck at low for the IC_SCL_STUCK_LOW_TIMEOUT in units of IC_CLK period. This field is written only when the I2C interface is disabled which corresponds to the I2C_ENABLE[ENABLE] register being set to 0x0. Writes at other timeshave no effect.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_SDA_STUCK_AT_LOW_TIMEOUT</name>
          <description>SDA Stuck at Low Timeout Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_SDA_STUCK_LOW_TIMEOUT</name>
              <description>I2C initiates the recovery of SDA line through enabling the I2C_ENABLE[SDA_STUCK_RECOVERY_EN] bit, if it detects the SDA stuck at low for the IC_SDA_STUCK_LOW_TIMEOUT in units of IC_CLK period.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CLR_SCL_STUCK_DET</name>
          <description>Clear SCL Stuck at Low Detect Interrupt Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLR_SCL_STUCK_DET</name>
              <description>Read this register to clear the I2C_RAW_INTR_STAT[SCL_STUCK_AT_LOW] bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_DEVICE_ID</name>
          <description>Device-ID Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEVICE_ID</name>
              <description>Contains the Device-ID</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_REG_TIMEOUT_RST</name>
          <description>Timeout Counter Reset Value Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_TIMEOUT_RST_RW</name>
              <description>This field holds reset value of REG_TIMEOUT counter register.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_COMP_PARAM_1</name>
          <description>Module Configuration Register 1</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x001F1FEA</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_BUFFER_DEPTH</name>
              <description>The value of this field defines the TX buffer depth.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_BUFFER_DEPTH</name>
              <description>The value of this field defines the RX buffer depth.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADD_ENCODED_PARAMS</name>
              <description>The value of this bit defines the Encoded parameters. Reading 1 in this bit means that the capabilityof reading these encoded parameters via software has beenincluded.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables capability of reading encoded parameters</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HAS_DMA</name>
              <description>The value of this bit defines the DMA handshaking.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA handshaking signals are enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTR_IO</name>
              <description>The value of this bit defines the interrupt outputs type.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Combined interrupt outputs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HC_COUNT_VALUES</name>
              <description>The value of this bit defines the count values.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Programmable count values for each mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MAX_SPEED_MODE</name>
              <description>The value of this field defines the maximum speed mode.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Fast</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>APB_DATA_WIDTH</name>
              <description>The value of this field defines the APB data bus width.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>APB data bus width is 32 bits</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_COMP_VERSION</name>
          <description>Component Version Register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3230322A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_COMP_VERSION</name>
              <description>Module component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_COMP_TYPE</name>
          <description>Component Type Register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x44570140</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IC_COMP_TYPE</name>
              <description>Component type</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C1</name>
      <baseAddress>0x49011000</baseAddress>
      <interrupt>
        <name>I2C1_IRQ</name>
        <description>I2C1 interrupt request</description>
        <value>133</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C2</name>
      <baseAddress>0x49012000</baseAddress>
      <interrupt>
        <name>I2C2_IRQ</name>
        <description>I2C2 interrupt request</description>
        <value>134</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C3</name>
      <baseAddress>0x49013000</baseAddress>
      <interrupt>
        <name>I2C3_IRQ</name>
        <description>I2C3 interrupt request</description>
        <value>135</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S0</name>
      <baseAddress>0x49014000</baseAddress>
      <interrupt>
        <name>I2S0_IRQ</name>
        <description>I2S0 interrupt request</description>
        <value>141</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S1</name>
      <baseAddress>0x49015000</baseAddress>
      <interrupt>
        <name>I2S1_IRQ</name>
        <description>I2S1 interrupt request</description>
        <value>142</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S2</name>
      <baseAddress>0x49016000</baseAddress>
      <interrupt>
        <name>I2S2_IRQ</name>
        <description>I2S2 interrupt request</description>
        <value>143</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPI2S">
      <name>I2S3</name>
      <baseAddress>0x49017000</baseAddress>
      <interrupt>
        <name>I2S3_IRQ</name>
        <description>I2S3 interrupt request</description>
        <value>144</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART0</name>
      <baseAddress>0x49018000</baseAddress>
      <interrupt>
        <name>UART0_IRQ</name>
        <description>UART0 interrupt request</description>
        <value>124</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART1</name>
      <baseAddress>0x49019000</baseAddress>
      <interrupt>
        <name>UART1_IRQ</name>
        <description>UART1 interrupt request</description>
        <value>125</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART2</name>
      <baseAddress>0x4901A000</baseAddress>
      <interrupt>
        <name>UART2_IRQ</name>
        <description>UART2 interrupt request</description>
        <value>126</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART3</name>
      <baseAddress>0x4901B000</baseAddress>
      <interrupt>
        <name>UART3_IRQ</name>
        <description>UART3 interrupt request</description>
        <value>127</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART4</name>
      <baseAddress>0x4901C000</baseAddress>
      <interrupt>
        <name>UART4_IRQ</name>
        <description>UART4 interrupt request</description>
        <value>128</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART5</name>
      <baseAddress>0x4901D000</baseAddress>
      <interrupt>
        <name>UART5_IRQ</name>
        <description>UART5 interrupt request</description>
        <value>129</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART6</name>
      <baseAddress>0x4901E000</baseAddress>
      <interrupt>
        <name>UART6_IRQ</name>
        <description>UART6 interrupt request</description>
        <value>130</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="LPUART">
      <name>UART7</name>
      <baseAddress>0x4901F000</baseAddress>
      <interrupt>
        <name>UART7_IRQ</name>
        <description>UART7 interrupt request</description>
        <value>131</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>ADC120</name>
      <groupName>ADC12</groupName>
      <baseAddress>0x49020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>116</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ADC120_CMPA_IRQ</name>
        <description>Comparator A interrupt</description>
        <value>157</value>
      </interrupt>
      <interrupt>
        <name>ADC120_CMPB_IRQ</name>
        <description>Comparator B interrupt</description>
        <value>160</value>
      </interrupt>
      <interrupt>
        <name>ADC120_DONE0_IRQ</name>
        <description>Averaged sample ready</description>
        <value>151</value>
      </interrupt>
      <interrupt>
        <name>ADC120_DONE1_IRQ</name>
        <description>All samples taken</description>
        <value>154</value>
      </interrupt>
      <registers>
        <register>
          <name>ADC_START_SRC</name>
          <description>ADC Start-of-Conversion Source Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENA</name>
              <description>When this bit is set to 1, the ADC_CONTROL register is enabled to start the processing.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>When this bit is set to 1, the ADC starts/continues its operation. This is used to enable functions by software, without using the event inputs.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START_SRC</name>
              <description>This bit field enables the corresponding event input to the ADC to start (and continue, if active) the ADC. Once the number samples programmed in ADC_AVG_NUM is reached, if one of the enabled event inputs is active, the ADC functionality continues. If not, it stops.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_COMP_THRESH_A</name>
          <description>ADC Comparator Threshold A Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_THRESHOLD_A</name>
              <description>Comparison threshold A value. Used for interrupt generation.
The programmed value should be equal to the desired threshold multiplied by the number of samples set in ADC_AVG_NUM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_COMP_THRESH_B</name>
          <description>ADC Comparator Threshold B Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_THRESHOLD_B</name>
              <description>Comparison threshold B value. Used for interrupt generation.
The programmed value should be equal to the desired threshold multiplied by the number of samples set in ADC_AVG_NUM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CLK_DIVISOR</name>
          <description>ADC Clock Divider Value Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Clock divider applied to input clock:
Others: Reserved</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Divide by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Divide by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>Divide by 16</description>
                  <value>0x10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_INTERRUPT</name>
          <description>ADC Interrupt Status and Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>AVG_CALC_THRESH_1</name>
              <description>Status and clear for CMPB interrupt.
Read 1: A threshold passed depending on ADC_CONTROL[INT_CTRL] register field. 
Write 1 to clear.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>AVG_CALC_THRESH_0</name>
              <description>Status and clear for CMPA interrupt.
Read 1: A threshold passed depending on ADC_CONTROL[INT_CTRL] register field. 
Write 1 to clear.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ALL_SAMPLES_TAKEN</name>
              <description>Status and clear for DONE1 interrupt.
Read 1: Data collection has now stopped with the final loading of a ADC_SAMPLE_REG_n register, due to either turning off ADC_START_SRC[START] for continuous operation, or ADC_CONTROL[START] one-time run has finished.
Write 1 to clear.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>AVG_SAMPLE_RDY</name>
              <description>Status and clear for DONE0 interrupt.
Read 1: Analog logic has delivered the number of samples set in the ADC_AVG_NUM register, indicating that the current ADC_SAMPLE_REG_n has been loaded.
Write 1 to clear.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_INTERRUPT_MASK</name>
          <description>ADC Interrupt Mask Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>AVG_CALC_THRESH_1</name>
              <description>Mask for CMPB interrupt.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_CALC_THRESH_0</name>
              <description>Mask for CMPA interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALL_SAMPLES_TAKEN</name>
              <description>Mask for DONE1 interrupt.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SAMPLE_RDY</name>
              <description>Mask for DONE0 interrupt.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SAMPLE_WIDTH</name>
          <description>ADC Sampling Signal Duration Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_HOLD</name>
              <description>Used in ADC24. If 1, the Sample signal is continuously active while gathering data.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_WIDTH</name>
              <description>Duration of the Sample signal to ADC analog frond-end in PCLK clocks. Valid values are 2 to 32.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_AVG_NUM</name>
          <description>ADC Number of Samples for Averaging Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AVG_NUM</name>
              <description>Program up to 256 number of samples to collect. The result is loaded into the sample registers (ADC_SAMPLE_REG_n). The programmed value must be a power of 2.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SHIFT_CONTROL</name>
          <description>ADC Data Shift Select Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHIFT_DIR</name>
              <description>Shift averaged value before loading into the sample registers (ADC_SAMPLE_REG_n):</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Shift averaged value left</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Shift averaged value right</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SHIFT_CONTROL</name>
              <description>Shift these bits before loading value into the sample registers (ADC_SAMPLE_REG_n). To calculate the sample average, program this bit field with the number of bits to shift right based upon the number of samples taken:
1 sample: no shift
2 samples: shift right 1 bit
4 samples: shift right 2 bits
256 samples: shift right 8 bits
If any additional shift left or right is desired it should be added to or subtracted from the averaging shift above, and the resulting value programmed into this register.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CONTROL</name>
          <description>ADC Single-shot Conversion Start and Comparator Threshold Mode Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_CTRL</name>
              <description>This field specifies the threshold windows for CMPA and CMPB interrupt generation. </description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>CMPA = Above threshold A value; CMPB = Above threshold B value.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CMPA = Below threshold A value; CMPB = Below threshold B value.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CMPA = Between threshold A and B values; CMPB = Outside threshold A and B values.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>If 1, indicates ADC is processing data.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>START</name>
              <description>Write 1: Starts the ADC process. This is one-time start control. If the number of programmed samples is reached, processing stops, unless another event causes it to continue. For START bit to be operational the ADC_START_SRC[ENA] must be 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SEQUENCER_CTRL</name>
          <description>ADC Sequencer Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>Sequencer mode:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Sequencer loops over all 9 analog inputs, while skipping masked inputs (set in the MASKED bit field). For ADC24, it loops over the lower 4 inputs.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sequencer is fixed at SEQUENCER_INIT field value.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEQUENCER_INIT</name>
              <description>Initial value (analog input index) of sequencer to use when started. This must be set to an unmasked input.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKED</name>
              <description>Masked analog inputs are skipped when advancing the sequencer. Each bit corresponds to an analog input. Set a bit to 1'b1 to mask the corresponding input.For ADC24, only the lower 4 inputs are used; the upper 5 inputs are automatically masked.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_REG1</name>
          <description>ADC Analog Control Register for ADC12 Modules</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AMUX_CONT</name>
              <description>Analog test mux control (external to ADC12). 
Bit 31 is a master enable (set to 1 to enable AMUX).
Upper 4 bits determine mux section [30:27].
Lower 3 bits select mux input [26:24]. 
 Default = 0x0</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC3_VCM_RDIV_EN</name>
              <description>Enable ADC122 resistive divider:</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The resistive divider is off, common mode is not well defined</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> The resistive divider is on, common mode is VDD/2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_COMPARATOR_BIAS</name>
              <description>ADC122 comparator biasing:</description>
              <bitRange>[16:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0.5 MS/s </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 MS/s</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2.5 MS/s </description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>5 MS/s</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_COMPARATOR_EN</name>
              <description>Enable ADC122 comparator:</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Comparator is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Comparator is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_DIFFERENTIAL_EN</name>
              <description>Enable ADC122 differential mode: </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IN0, IN1, IN2, IN3, IN4, and IN5 are single-ended inputs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IN0/IN1, IN2/IN3, and IN4/IN5 make 3 differential inputs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC3_TEST_EN</name>
              <description>Enable ADC122 test signal to go to the test MUX:</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_VCM_RDIV_EN</name>
              <description>Enable ADC121 resistive divider:</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The resistive divider is off, common mode is not well defined</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> The resistive divider is on, common mode is VDD/2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_COMPARATOR_BIAS</name>
              <description>ADC121 comparator biasing:</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0.5 MS/s </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 MS/s</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2.5 MS/s </description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>5 MS/s</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_COMPARATOR_EN</name>
              <description>Enable ADC121 comparator:</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Comparator is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Comparator is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_DIFFERENTIAL_EN</name>
              <description>Enable ADC121 differential mode: </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IN0, IN1, IN2, IN3, IN4, and IN5 are single-ended inputs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IN0/IN1, IN2/IN3, and IN4/IN5 make 3 differential inputs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_TEST_EN</name>
              <description>Enable ADC121 test signal to go to the test MUX:</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_VCM_RDIV_EN</name>
              <description>Enable ADC120 resistive divider:</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The resistive divider is off, common mode is not well defined</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> The resistive divider is on, common mode is VDD/2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_COMPARATOR_BIAS</name>
              <description>ADC120 comparator biasing:</description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0.5 MS/s </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1 MS/s</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2.5 MS/s </description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>5 MS/s</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_COMPARATOR_EN</name>
              <description>Enable ADC120 comparator:</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Comparator is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Comparator is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_DIFFERENTIAL_EN</name>
              <description>Enable ADC120 differential mode: </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IN0, IN1, IN2, IN3, IN4, and IN5 are single-ended inputs</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IN0/IN1, IN2/IN3, and IN4/IN5 make 3 differential inputs</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_TEST_EN</name>
              <description>Enable ADC120 test signal to go to the test MUX:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SEL</name>
          <description>ADC Sample Register Selected (read-only value of n)</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_REG_NUM</name>
              <description>Indicates the current ADC_SAMPLE_REG_n number to be loaded with an ADC result.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>9</dim>
          <dimIncrement>4</dimIncrement>
          <name>ADC_SAMPLE_REG_[%s]</name>
          <description>ADC Sampled Value From Input n Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Result of ADC operation on input n.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="ADC120">
      <name>ADC121</name>
      <baseAddress>0x49021000</baseAddress>
      <interrupt>
        <name>ADC121_CMPA_IRQ</name>
        <description>Comparator A interrupt</description>
        <value>158</value>
      </interrupt>
      <interrupt>
        <name>ADC121_CMPB_IRQ</name>
        <description>Comparator B interrupt</description>
        <value>161</value>
      </interrupt>
      <interrupt>
        <name>ADC121_DONE0_IRQ</name>
        <description>Averaged sample ready</description>
        <value>152</value>
      </interrupt>
      <interrupt>
        <name>ADC121_DONE1_IRQ</name>
        <description>All samples taken</description>
        <value>155</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="ADC120">
      <name>ADC122</name>
      <baseAddress>0x49022000</baseAddress>
      <interrupt>
        <name>ADC122_CMPA_IRQ</name>
        <description>Comparator A interrupt</description>
        <value>159</value>
      </interrupt>
      <interrupt>
        <name>ADC122_CMPB_IRQ</name>
        <description>Comparator B interrupt</description>
        <value>162</value>
      </interrupt>
      <interrupt>
        <name>ADC122_DONE0_IRQ</name>
        <description>Averaged sample ready</description>
        <value>153</value>
      </interrupt>
      <interrupt>
        <name>ADC122_DONE1_IRQ</name>
        <description>All samples taken</description>
        <value>156</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>CMP0</name>
      <groupName>CMP</groupName>
      <baseAddress>0x49023000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>40</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>CMP0_IRQ</name>
        <description>Comparator result changed</description>
        <value>167</value>
      </interrupt>
      <registers>
        <register>
          <name>CMP_COMP_REG1</name>
          <description>Comparator Register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMP_HS_EN</name>
              <description>Enables High-Speed comparators:
 Bit 31: CMP3 enable
 Bit 30: CMP2 enable
 Bit 29: CMP1 enable
 Bit 28: CMP0 enable</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_HS3_HYST</name>
              <description>Sets CMP3 hysteresis level. 6-mV steps</description>
              <bitRange>[27:25]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> 0 mV</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description> 45 mV</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS3_IN_M_SEL</name>
              <description>Selects input to negative terminal of CMP3:</description>
              <bitRange>[24:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> VREF_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VREF_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Internal Vref</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>DAC6</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS3_IN_P_SEL</name>
              <description>Selects input to positive terminal of CMP3:</description>
              <bitRange>[22:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> CMP3_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CMP3_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CMP3_IN2 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CMP3_IN3 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS2_HYST</name>
              <description>Sets CMP2 hysteresis level. 6-mV steps</description>
              <bitRange>[20:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 mV</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description> 45 mV</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS2_IN_M_SEL</name>
              <description>Selects input to negative terminal of CMP2:</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> VREF_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VREF_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Internal Vref</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>DAC6</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS2_IN_P_SEL</name>
              <description>Selects input to positive terminal of CMP2:</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> CMP2_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CMP2_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CMP2_IN2 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CMP2_IN3 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS1_HYST</name>
              <description>Sets CMP1 hysteresis level. 6-mV steps</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 mV</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>45 mV</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS1_IN_M_SEL</name>
              <description>Selects input to negative terminal of CMP1:</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> VREF_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VREF_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Internal Vref</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>DAC6</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS1_IN_P_SEL</name>
              <description>Selects input to positive terminal of CMP1:</description>
              <bitRange>[8:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> CMP1_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CMP1_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CMP1_IN2 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CMP1_IN3 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS0_HYST</name>
              <description>Sets CMP0 hysteresis level. 6-mV steps</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>0 mV</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>45 mV</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS0_IN_M_SEL</name>
              <description>Selects input to negative terminal of CMP0:</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> VREF_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>VREF_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Internal Vref</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>DAC6</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_HS0_IN_P_SEL</name>
              <description>Selects input to positive terminal of CMP0:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> CMP0_IN0 pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CMP0_IN1 pin</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>CMP0_IN2 pin</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>CMP0_IN3 pin</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_COMP_REG2</name>
          <description>Comparator Register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAC6_VREF_SCALE</name>
              <description>Allows you to scale the input reference to the DAC6.
Step Size = 1/16</description>
              <bitRange>[30:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1x </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description> 2x</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC6_CONT</name>
              <description>This is the output of DAC6 programmable reference voltage. DAC6 Output = (DAC6_VREF_SCALE x DAC6_CONT) / 64</description>
              <bitRange>[26:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC6_EN</name>
              <description>DAC6 Enable. DAC6 takes an input reference and generates a 6-bit programmable output voltage reference.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC12_VREF_CONT</name>
              <description>Voltage reference values for DAC12</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>0.500 V</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>0.667 V</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b010</name>
                  <description>0.667 V</description>
                  <value>0b010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b011</name>
                  <description>0.750 V</description>
                  <value>0b011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>0.750 V (Default)</description>
                  <value>0b100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b101</name>
                  <description>0.800 V</description>
                  <value>0b101</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b110</name>
                  <description>0.800 V</description>
                  <value>0b110</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b111</name>
                  <description>0.833 V</description>
                  <value>0b111</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_BUF_RDIV_EN</name>
              <description>ADC Vref divider enable</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Vref = 1.8 V</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Vref = 1.5 V</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_BUF_EN</name>
              <description>ADC Vref buffer enable</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ADC Vref is off</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ADC Vref is on</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_VREF_CONT</name>
              <description>Control for ADC Vref: 1.8 V +- 100 mV, where:
 Step size = 7 mV</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b00000</name>
                  <description>-100 mV</description>
                  <value>0b00000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b11111</name>
                  <description>100 mV</description>
                  <value>0b11111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b10000</name>
                  <description>1.8 V = Default (0x10)</description>
                  <value>0b10000</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ANA_PERIPH_LDO_CONT</name>
              <description>Analog peripheral LDO (LDO-5) output voltage (VDD_ANA):
 Step: 20 mV</description>
              <bitRange>[9:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description>1.6 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description>1.9 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1010</name>
                  <description>1.8 V = Default (0xA)</description>
                  <value>0b1010</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ANA_PERIPH_BG_CONT</name>
              <description>Calibration for analog peripherals precision bandgap:
 Step: 6 mV</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b0000</name>
                  <description> 1.140 V</description>
                  <value>0b0000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1111</name>
                  <description> 1.233 V</description>
                  <value>0b1111</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b1010</name>
                  <description>1.200 V = Default (0xA)</description>
                  <value>0b1010</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_POLARITY_CTRL</name>
          <description>CMP Polarity Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLARITY_CTRL</name>
              <description>If = 0x1, invert the value of CMP_OUT (comparison result) before processing.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_WINDOW_CTRL</name>
          <description>CMP Window Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVENTS_IN</name>
              <description>Selects which of the 4 inputs will control the processing window.
</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WINDOW_CTRL</name>
              <description>Window function control bit.
NOTE: Bits WINDOW_CTRL and WINDOW_EN must be both set to use windowing function.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Continously process comparator inputs.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use the EVENTS_IN bit field setting. Selected input will control when to look at comparator inputs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WINDOW_EN</name>
              <description>Window function enable bit.
NOTE: Bits WINDOW_CTRL and WINDOW_EN must be both set to use windowing function.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Continously process comparator inputs.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use the EVENTS_IN bit field setting. Selected input will control when to look at comparator inputs.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_FILTER_CTRL</name>
          <description>CMP Filter Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_TAPS</name>
              <description>Number of filter taps, 2-8 taps.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Filtering function enable bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_PRESCALER_CTRL</name>
          <description>CMP Prescaler Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALER_CTRL</name>
              <description>Number of clocks between updating taps with new comparator input.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_INTERRUPT_STATUS</name>
          <description>CMP Interrupt Status and Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER_EVENT</name>
              <description>FILTER_EVENT interrupt status and clear.
When read as 1: Filter event occurred for the programmed number of taps. 
Write 1 to clear.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_INTERRUPT_MASK</name>
          <description>CMP Interrupt Mask Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FILTER_EVENT</name>
              <description>Mask for the FILTER_EVENT interrupt.
Note: By default, interrupt mask is set. Mask must be cleared to allow interrupt to be driven out.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clear mask</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Set mask</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CMP0">
      <name>CMP1</name>
      <baseAddress>0x49024000</baseAddress>
      <interrupt>
        <name>CMP1_IRQ</name>
        <description>Comparator result changed</description>
        <value>168</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="CMP0">
      <name>CMP2</name>
      <baseAddress>0x49025000</baseAddress>
      <interrupt>
        <name>CMP2_IRQ</name>
        <description>Comparator result changed</description>
        <value>169</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="CMP0">
      <name>CMP3</name>
      <baseAddress>0x49026000</baseAddress>
      <interrupt>
        <name>CMP3_IRQ</name>
        <description>Comparator result changed</description>
        <value>170</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="ADC120">
      <name>ADC24</name>
      <baseAddress>0x49027000</baseAddress>
      <interrupt>
        <name>ADC24_CMPA_IRQ</name>
        <description>Comparator A interrupt</description>
        <value>165</value>
      </interrupt>
      <interrupt>
        <name>ADC24_CMPB_IRQ</name>
        <description>Comparator B interrupt</description>
        <value>166</value>
      </interrupt>
      <interrupt>
        <name>ADC24_DONE0_IRQ</name>
        <description>Averaged sample ready</description>
        <value>163</value>
      </interrupt>
      <interrupt>
        <name>ADC24_DONE1_IRQ</name>
        <description>All samples taken</description>
        <value>164</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>DAC120</name>
      <groupName>DAC12</groupName>
      <baseAddress>0x49028000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DAC_REG1</name>
          <description>REG1 DAC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08001FFD</resetValue>
          <resetMask>0xF8783FFF</resetMask>
          <fields>
            <field>
              <name>DAC_RESET_B</name>
              <description>DAC reset:</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset asserted</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Reset released</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_IBIAS</name>
              <description>Trims buffer output current (HP mode):
From 0000 = 0 uA to 1111 = 1.5 mA
 Default is 1111 for DAC120 and 0000 for DAC121
 Step size ~100 uA</description>
              <bitRange>[26:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_TWOSCOMP_EN</name>
              <description>Converts two's complement to unsigned binary data: </description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> Input data is unsigned</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Input data is two's complement signed (conversion to unsigned enable)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_HP_MODE_EN</name>
              <description>DAC high-performance mode enable.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0</name>
                  <description>Low-power (LP) mode (default for DAC121)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_1</name>
                  <description>High-performance (HP) mode (default for DAC120)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_CAP_CONT</name>
              <description>Trims HP mode capacitance compensation: 
From xx00 = 2 pF to xx11 = 8 pF
 Step size = 2 pF
Default is xx11 = 8 pF for DAC120 and xx00 for DAC121
Bits [17-16] = Don't care</description>
              <bitRange>[17:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_BYP_VAL</name>
              <description>DAC input data in bypass mode</description>
              <bitRange>[13:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_INPUT_BYP_MUX_EN</name>
              <description>Selects DAC input data source:</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DAC_IN register</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DAC_REG1[DAC_BYP_VAL] bitfield (bypass mode)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC_EN</name>
              <description>DAC enable:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DAC is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DAC is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_IN</name>
          <description>DAC Input Value Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Value used by DAC analog portion for conversion.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DAC120">
      <name>DAC121</name>
      <baseAddress>0x49029000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="LPPDM">
      <name>PDM</name>
      <baseAddress>0x4902D000</baseAddress>
      <interrupt>
        <name>PDM_AUDIO_DET_IRQ</name>
        <description>PDM Audio peak detection interrupt request</description>
        <value>147</value>
      </interrupt>
      <interrupt>
        <name>PDM_ERROR_IRQ</name>
        <description>PDM Error interrupt request</description>
        <value>146</value>
      </interrupt>
      <interrupt>
        <name>PDM_WARN_IRQ</name>
        <description>PDM Warning interrupt request</description>
        <value>145</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>HWSEM0</name>
      <groupName>HWSEM</groupName>
      <baseAddress>0x4902E000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>12</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>HWSEM_IRQ0</name>
        <description>HWSEM interrupt request 0</description>
        <value>105</value>
      </interrupt>
      <registers>
        <register>
          <name>HWSEM_REQ_REG</name>
          <description>Request register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>REQ_ACQ</name>
              <description>Request a HWSEM module by writing the processor ID into this field.
Check the status of the HWSEM request by reading this field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWSEM_REL_REG</name>
          <description>Release register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>REL_CHK</name>
              <description>Release the HWSEM by writing the processor ID into this field.
Check the current HWSEM count by reading this field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWSEM_RST_REG</name>
          <description>Reset register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RST</name>
              <description>Reset the semaphore count and current master ID.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM1</name>
      <baseAddress>0x4902E010</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ1</name>
        <description>HWSEM interrupt request 1</description>
        <value>106</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM2</name>
      <baseAddress>0x4902E020</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ2</name>
        <description>HWSEM interrupt request 2</description>
        <value>107</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM3</name>
      <baseAddress>0x4902E030</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ3</name>
        <description>HWSEM interrupt request 3</description>
        <value>108</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM4</name>
      <baseAddress>0x4902E040</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ4</name>
        <description>HWSEM interrupt request 4</description>
        <value>109</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM5</name>
      <baseAddress>0x4902E050</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ5</name>
        <description>HWSEM interrupt request 5</description>
        <value>110</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM6</name>
      <baseAddress>0x4902E060</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ6</name>
        <description>HWSEM interrupt request 6</description>
        <value>111</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM7</name>
      <baseAddress>0x4902E070</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ7</name>
        <description>HWSEM interrupt request 7</description>
        <value>112</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM8</name>
      <baseAddress>0x4902E080</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ8</name>
        <description>HWSEM interrupt request 8</description>
        <value>113</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM9</name>
      <baseAddress>0x4902E090</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ9</name>
        <description>HWSEM interrupt request 9</description>
        <value>114</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM10</name>
      <baseAddress>0x4902E0A0</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ10</name>
        <description>HWSEM interrupt request 10</description>
        <value>115</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM11</name>
      <baseAddress>0x4902E0B0</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ11</name>
        <description>HWSEM interrupt request 11</description>
        <value>116</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM12</name>
      <baseAddress>0x4902E0C0</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ12</name>
        <description>HWSEM interrupt request 12</description>
        <value>117</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM13</name>
      <baseAddress>0x4902E0D0</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ13</name>
        <description>HWSEM interrupt request 13</description>
        <value>118</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM14</name>
      <baseAddress>0x4902E0E0</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ14</name>
        <description>HWSEM interrupt request 14</description>
        <value>119</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="HWSEM0">
      <name>HWSEM15</name>
      <baseAddress>0x4902E0F0</baseAddress>
      <interrupt>
        <name>HWSEM_IRQ15</name>
        <description>HWSEM interrupt request 15</description>
        <value>120</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>CLKCTL_PER_SLV</name>
      <baseAddress>0x4902F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>188</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>EXPMST0_CTRL</name>
          <description>Clock Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xC0000310</resetMask>
          <fields>
            <field>
              <name>IPCLK_FORCE</name>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock force disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Force peripherals functional clocks on, bypass clock gating</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLK_FORCE</name>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock force disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Force APB interface clocks (PCLKs) on, bypass clock gating</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_SEL</name>
              <description>PDM functional clock source select</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PDM_CKEN</name>
              <description>Clocks enable for PDM</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clocks</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clocks</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BKRAM_CKEN</name>
              <description>Clock enable for Backup SRAM</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_SEL</name>
              <description>UART DMA select for UART[7-4].
One bit for each module. Bit 27 --&gt; UART7, bit 24 --&gt; UART4.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RS485</name>
              <description>UART[7-4] RS485 Status.
One bit for each module. Bit 23 --&gt; UART7, bit 20 --&gt; UART4.
Bits[19-16] are reserved.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>UART not in RS485 mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>UART is in RS485 mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>UART[7-0]_SCLK Select.
One bit for each module. Bit 15 --&gt; UART7, bit 8 --&gt; UART0.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>38.4 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SYST_PCLK clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKEN</name>
              <description>UART[7-0] Enable.
One bit for each module. Bit 7 --&gt; UART7, bit 0 --&gt; UART0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable UART[7-0] module</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable UART[7-0] module</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CTRL</name>
          <description>CANFD Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x001110FF</resetMask>
          <fields>
            <field>
              <name>FD_ENA</name>
              <description>CANFD FD-mode enable</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable FD-mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable FD-mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>CANFD functional clock source select</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 38.4 MHz oscillator clock (HFOSC_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 160 MHz PLL clock (160M_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKEN</name>
              <description>CANFD clocks enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKDIV</name>
              <description>CANFD functional clock divisor
n: Clock divided by n</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>I2S_CTRL[%s]</name>
          <description>I2Sn Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x001313FF</resetMask>
          <fields>
            <field>
              <name>SCLK_AON</name>
              <description>I2S clock output to external device always on</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2S clock output (I2S_SCLK) in gated mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2S clock output (I2S_SCLK) in always on mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIV_BYPASS</name>
              <description>I2S clock divider bypass</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not bypass clock divider</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bypass clock divider</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>I2S functional clock source select</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 76.8 MHz crystal-oscillator clock (76M8_CLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select external audio clock input (AUDIO_CLK)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKEN</name>
              <description>I2S clocks enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clocks</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clocks</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKDIV</name>
              <description>I2S functional clock divisor
n: Clock divided by n</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_CTRL</name>
          <description>I3C Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0103F101</resetMask>
          <fields>
            <field>
              <name>DMA_SEL</name>
              <description>DMA select</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select DMA0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select DMA2</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACT_MODE</name>
              <description>I3C slave activity mode for GETSTATUS CCC</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PEND_INT</name>
              <description>I3C pending interrupt information for GETSTATUS CCC</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_MODE</name>
              <description>I2C or I3C mode select</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEN</name>
              <description>I3C clocks enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SSI_CTRL</name>
          <description>SPI Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000F0F</resetMask>
          <fields>
            <field>
              <name>SS_IN_VAL</name>
              <description>SS_IN Value
 One bit for each SPI module:
- Bit 11: SPI3
- Bit 8: SPI0
 When SS_IN_SEL = 0x1, the programmed SS_IN_VAL is fed to SPI module.
 Note: If the corresponding SPI module is configured as a master, the associated bit in this field should be set to 0x1.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_IN_SEL</name>
              <description>SS_IN Mode Select
 One bit for each SPI module:
- Bit 3: SPI3
- Bit 0: SPI0
Note: If the corresponding SPI module is configured as a master, the associated bit in this field should be set to 0x1. 
If the corresponding SPI module is configured as a slave, and the master device is driving a slave select signal, the associated bit in this field should be set to 0x0. If the master device is not driving a slave select signal, the associated bit in this field should be set to 0x1, and the associated bit in SS_IN_VAL field should be set to 0x0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SS_IN from I/O pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SS_IN from SS_IN_VAL</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTRL</name>
          <description>ADC Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001111</resetMask>
          <fields>
            <field>
              <name>ADC24_CKEN</name>
              <description>ADC24 clock enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC24 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC24 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC2_CKEN</name>
              <description>ADC122 clock enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC122 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC122 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC1_CKEN</name>
              <description>ADC121 clock enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC121 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC121 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC0_CKEN</name>
              <description>ADC120 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable ADC120 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable ADC120 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CTRL</name>
          <description>DAC Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>DAC1_CKEN</name>
              <description>DAC121 clock enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable DAC121 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DAC121 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DAC0_CKEN</name>
              <description>DAC120 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable DAC120 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable DAC120 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP_CTRL</name>
          <description>CMP Control Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001111</resetMask>
          <fields>
            <field>
              <name>CMP3_CKEN</name>
              <description>CMP3 clock enable</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP3 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP3 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP2_CKEN</name>
              <description>CMP2 clock enable</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP2 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP2 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP1_CKEN</name>
              <description>CMP1 clock enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP1 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP1 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP0_CKEN</name>
              <description>CMP0 clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable CMP0 clock </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable CMP0 clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_CTRL0</name>
          <description>Frequency Monitor 0 Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRL</name>
              <description>Input count value of the HFXO clock to be measured or calibrated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_STAT0</name>
          <description>Frequency Monitor 0 Status Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STAT</name>
              <description>Output count value of the 400 MHz PLL calibrating clock.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_CTRL1</name>
          <description>Frequency Monitor 1 Control Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRL</name>
              <description>Input count value of the 160 MHz clock to be measured or calibrated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQ_MON_STAT1</name>
          <description>Frequency Monitor 1 Status Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STAT</name>
              <description>Output count value of the 400 MHz PLL calibrating clock.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>GPIO_CTRL[%s]</name>
          <description>GPIOn Control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x000013FF</resetMask>
          <fields>
            <field>
              <name>DB_CKEN</name>
              <description>Enable GPIOn debounce clock</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable GPIOn debounce clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable GPIOn debounce clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DB_CKDIV</name>
              <description>GPIOn debounce clock divisor
All other values: Clock divided by 1024</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock divided by 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Clock divided by 8</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Clock divided by 16</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>Clock divided by 32</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x20</name>
                  <description>Clock divided by 64</description>
                  <value>0x20</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x40</name>
                  <description>Clock divided by 128</description>
                  <value>0x40</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x80</name>
                  <description>Clock divided by 256</description>
                  <value>0x80</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x100</name>
                  <description>Clock divided by 512</description>
                  <value>0x100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x200</name>
                  <description>Clock divided by 1024</description>
                  <value>0x200</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LPCPI">
      <name>CPI</name>
      <baseAddress>0x49030000</baseAddress>
      <interrupt>
        <name>CAM_IRQ</name>
        <description>CPI interrupt</description>
        <value>345</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>CDC</name>
      <baseAddress>0x49031000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>596</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>CDC_BUS_ERROR0_IRQ</name>
        <description>CDC bus error interrupt</description>
        <value>339</value>
      </interrupt>
      <interrupt>
        <name>CDC_FIFO_UNDERRUN0_IRQ</name>
        <description>CDC layer FIFO underrun interrupt</description>
        <value>337</value>
      </interrupt>
      <interrupt>
        <name>CDC_FIFO_WARNING0_IRQ</name>
        <description>CDC FIFO underrun warning interrupt</description>
        <value>335</value>
      </interrupt>
      <interrupt>
        <name>CDC_REG_RELOAD0_IRQ</name>
        <description>CDC register reload interrupt</description>
        <value>341</value>
      </interrupt>
      <interrupt>
        <name>CDC_SCANLINE0_IRQ</name>
        <description>CDC line interrupt</description>
        <value>333</value>
      </interrupt>
      <registers>
        <register>
          <name>CDC_HW_VER</name>
          <description>HW Version Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00040000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>MAJVER</name>
              <description>Major version.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINVER</name>
              <description>Minor version.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REV</name>
              <description>Revision (bug fixes, and others).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_LCNT</name>
          <description>Layer Count Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>LNUM</name>
              <description>Number of layers.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SYNC_SIZE_CFG</name>
          <description>Sync Size Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSW</name>
              <description>Horizontal sync width - 1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VSW</name>
              <description>Vertical sync height - 1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_BP_CFG</name>
          <description>Back Porch Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AHBP</name>
              <description>Accumulated width including sync and back porch -1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVBP</name>
              <description>Accumulated height including sync and back porch -1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_ACTW_CFG</name>
          <description>Active Width Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AAW</name>
              <description>Accumulated width including sync, back porch and active width -1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AAH</name>
              <description>Accumulated height including sync, back porch and active height -1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_TOTALW_CFG</name>
          <description>Total Width Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOTALW</name>
              <description>Total width, including sync, back porch, active width and front porch -1 (in units of pixel clock period).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TOTALH</name>
              <description>Total height, including sync, back porch, active height and front porch -1 (in units of horizontal scan line).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_GLB_CTRL</name>
          <description>Global Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002220</resetValue>
          <resetMask>0xF70F7777</resetMask>
          <fields>
            <field>
              <name>HSPOL</name>
              <description>HSync polarity. 
 Signal polarity:</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSPOL</name>
              <description>VSync polarity. 
 Signal polarity:</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BLPOL</name>
              <description>Blank polarity.
 Signal polarity: </description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low </description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PCLKPOL</name>
              <description>Output pixel clock polarity.
 Signal polarity: </description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Feed-through of PIXEL_CLK input</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Inverted PIXEL_CLK input</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DITHER_EN</name>
              <description>Dithering on. 
Dithering can be enabled/disabled.
A 4x4 Bayer pattern is added to each color component.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DITHER_R</name>
              <description>Dither bits red (0-4).
Dither bits width for red color component.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DITHER_G</name>
              <description>Dither bits green (0-4).
Dither bits width for green color component.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DITHER_B</name>
              <description>Dither bits blue (0-4).
Dither bits width for blue color component.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GAMMA_EN</name>
              <description>Gamma correction enable.
When it is disabled, the RGB data bypasses the gamma correction CLUT.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CDC_EN</name>
              <description>Global enable. Mirrored to pin CDC_DE.
The display controller can be globally enabled/disabled. If the display controller is disabled, the timing generator is reset to X = total_width - 1, Y = total_height - 1, and held. Thus only blanking data is output continuously while the display controller is disabled and no new bus accesses are started. Outstanding read data is discarded and the FIFOs are flushed. The value is mirrored to pin CDC_DE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_CFG1</name>
          <description>Global Configuration 1 Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x6BE45888</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BMEN</name>
              <description>Blind mode enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CFG_RD</name>
              <description>Configuration reading mode enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STREN</name>
              <description>Status registers enabled.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DWP</name>
              <description>Dither width programmable.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPP</name>
              <description>Sync polarity programmable.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TP</name>
              <description>Timing programmable.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LINE_IRQ</name>
              <description>Line IRQ position programmable.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BBEN</name>
              <description>Background blending enabled.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BCP</name>
              <description>Background color programmable.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SHREN</name>
              <description>Shadow registers enabled.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GCT</name>
              <description>Gamma correction technique.</description>
              <bitRange>[19:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>None</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Gamma RAM</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Node interpolation</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DT</name>
              <description>Dithering technique.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Ordered, 4x4 Bayer matrix</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRBEN</name>
              <description>Precise blending enabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WRCH</name>
              <description>Width of red channel output.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WGCH</name>
              <description>Width of green channel output.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WBCH</name>
              <description>Width of blue channel output.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_CFG2</name>
          <description>Global Configuration 2 Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOEN</name>
              <description>Blending order enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRCM</name>
              <description>CRC mode available.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFMEN</name>
              <description>Single frame ability enabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SIRQEN</name>
              <description>Secondary interrupt support enabled.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ROTEN</name>
              <description>Rotation support enabled.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AXIIDEN</name>
              <description>AXI Interface ID support enabled.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>YUVEN</name>
              <description>YCbCr output color conversion ability enabled.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EDCA</name>
              <description>External display control ability enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSW</name>
              <description>Bus width (log2 of number of bytes).</description>
              <bitRange>[6:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPAEN</name>
              <description>Secondary RGB output port enabled.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DVAEN</name>
              <description>Dual-view ability enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STSAEN</name>
              <description>Slave timing synchronization ability enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EDCEN</name>
              <description>Background layer ability enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SRCTRL</name>
          <description>Shadow Reload Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>VBR</name>
              <description>Vertical blanking reload (self-clearing after reload, cannot be reset once set).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMR</name>
              <description>Immediate reload (self-clearing at once).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_GAMMA_CORR</name>
          <description>Gamma Correction Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>R_CLUT</name>
              <description>Select red CLUT to be written.</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>G_CLUT</name>
              <description>Select green CLUT to be written.</description>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>B_CLUT</name>
              <description>Select blue CLUT to be written.</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RGB_VALUE</name>
              <description>Mapped color (RGB). 
Color value to be written to the selected CLUTs.</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLUT_ADDR</name>
              <description>Addressed color. 
Address of CLUT entry to be written.</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_BACKGND_COLOR</name>
          <description>Background Color Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>BGC</name>
              <description>Background color (RGB).
Bits [23-16] define red value.
Bits [15-8] define green value.
Bits [7-0] define blue value.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_IRQ_MASK0</name>
          <description>IRQ Enable 1 Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_RELOAD_IRQ</name>
              <description>Register reload IRQ enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR0_IRQ</name>
              <description>Bus error IRQ enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERRUN_IRQ</name>
              <description>FIFO underrun warning IRQ enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCANLINE0_IRQ</name>
              <description>Line IRQ enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_IRQ_STATUS0</name>
          <description>IRQ Status 1 Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REG_RELOAD_IRQ</name>
              <description>Register reload IRQ status.
The Register reload interrupt is generated, if a vertical blanking reload was programmed and the first line after the active area is reached.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUS_ERROR0_IRQ</name>
              <description>Bus error IRQ status.
The Bus error interrupt is generated if an error occurs on the AXI bus.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_UNDERRUN_IRQ</name>
              <description>FIFO underrun warning IRQ status.
The FIFO underrun warning interrupt is generated if one of the layer FIFOs is empty and pixel data is read from the FIFO. This can occur if the color frame buffer length is not defined properly or the master bus performance is too low, such that the pixel data cannot be read in time.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SCANLINE0_IRQ</name>
              <description>Line IRQ status.
The Line interrupt is generated when a programmed line number is reached.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_IRQ_CLEAR0</name>
          <description>IRQ Clear Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>REG_RELOAD_IRQ</name>
              <description>Clear register reload IRQ.</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BUS_ERROR0_IRQ</name>
              <description>Clear bus error IRQ.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFO_UNDERRUN_IRQ</name>
              <description>Clear FIFO underrun warning IRQ.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SCANLINE0_IRQ</name>
              <description>Clear line IRQ.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_LINE_IRQ_POS</name>
          <description>Line Number IRQ Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>LIPOS</name>
              <description>Line IRQ position.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_POS_STAT</name>
          <description>Position Status Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CXPOS</name>
              <description>This field returns the current X position.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CYPOS</name>
              <description>This field returns the current Y position.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SYNC_BLANK_STAT</name>
          <description>Sync/Blank Status Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>HSYNCS</name>
              <description>HSync (horizontal synchronization) status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VSYNCS</name>
              <description>VSync (vertical synchronization) status (active high).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HBLANKS</name>
              <description>HBlank (horizontal data enable) status (active high).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VBLANKS</name>
              <description>VBlank (vertical data enable) status (active high).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Active low</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active high</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC_SLINE_IRQ_POS</name>
          <description>Secure Line IRQ Position Control Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SLIPOS</name>
              <description>Secure Line IRQ position.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CDC_LAYER_CFG[%s]</name>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>CDC_L_CFG1</name>
            <description>Layer (n) Configuration 1 Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0xFF50A075</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PIX_FORMAT</name>
                <description>Supported pixel formats (bit mask, custom)</description>
                <bitRange>[31:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLEND_FACTOR1</name>
                <description>Supported blending factors for f1:
Bit [23]: Reserved
Bit [22]: Pixel alpha x constant alpha
Bit [21]: Reserved
Bit [20]: Constant alpha
Bit [19-16]: Reserved</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLEND_FACTOR2</name>
                <description>Supported blending factors for f2:
Bit [15]: 1.0 - (pixel alpha x constant alpha)
Bit [14]: Reserved
Bit [13]: 1.0 - constant alpha
Bit [12-8]: Reserved</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CKEY_REPL_EN</name>
                <description>Color key replace ability enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CLUT_EN</name>
                <description>CLUT ability enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WINDOW_EN</name>
                <description>Windowing ability enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DEF_COLOR_EN</name>
                <description>Default color programmable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>APLANE_EN</name>
                <description>Alpha plane ability enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>COLOR_FBP_EN</name>
                <description>Color FB pitch ability enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>COLOR_FBDUP_EN</name>
                <description>Color FB duplication ability enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CKEY_EN</name>
                <description>Color key ability enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFG2</name>
            <description>Layer (n) Configuration 2 Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xC0000007</resetMask>
            <fields>
              <field>
                <name>SCALEREN</name>
                <description>Scaling ability enabled</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUVEN</name>
                <description>YCbCr ability enabled</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUV420FEN</name>
                <description>YCbCr 4:2:0 fully planar enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUV420SPEN</name>
                <description>YCbCr 4:2:0 semiplanar enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>YUV422EN</name>
                <description>YCbCr 4:2:2 interleaved enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_REL_CTRL</name>
            <description>Layer (n) Shadow Reload Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000007</resetMask>
            <fields>
              <field>
                <name>SH_MASK</name>
                <description>Shadow reload control mask global reloading.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SH_VBLANK</name>
                <description>Shadow reload control vertical blanking.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SH_IM</name>
                <description>Shadow reload control immediate.</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CTRL</name>
            <description>Layer (n) Control Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000007FF</resetMask>
            <fields>
              <field>
                <name>DFLT_CBLEND_EN</name>
                <description>Default color blending enable.
This bit enables blending with the default color for a layer, which is disabled or for pixels on a layer outside of the window. When default color blending is disabled, the color of the subjacent layer is simply passed through for such pixels.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLUT_EN</name>
                <description>CLUT lookup on.
This bit enables/disables the usage of the color look-up table. If enabled, the blue component of the frame buffer pixel after conversion to the internal pixel format is used to look up a RGB value in the table. This RGB value replaces the original RGB value of that pixel. The CLUT is located before the color keying.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LAYER_EN</name>
                <description>Layer on.
This bit enables/disables the layer. When a layer is enabled, data is fetched from the frame buffer, that is, the address, number of lines, line length and pitch settings have to be consistent. When a layer is disabled, the default color is used for all pixels.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_WIN_HPOS</name>
            <description>Layer (n) Window Horizontal Position Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STOP_POS</name>
                <description>Horizontal Stop Position.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_POS</name>
                <description>Horizontal Start Position.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_WIN_VPOS</name>
            <description>Layer (n) Window Vertical Position Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STOP_POS</name>
                <description>Vertical Stop Position.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_POS</name>
                <description>Vertical Start Position.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CKEY</name>
            <description>Layer (n) Color Key Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>TRANS_COLOR</name>
                <description>Transparency color.</description>
                <bitRange>[23:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_PIX_FORMAT</name>
            <description>Layer (n) Pixel Format Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000007</resetMask>
            <fields>
              <field>
                <name>PIXF</name>
                <description>Pixel format selection.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>ARGB8888, 32-bit ARGB</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>RGB888, 24-bit RGB (A = 255)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>RGB565, 16-bit RGB (A = 255)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>RGBA8888, 32-bit RGBA</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>AL44, 8-bit alpha + luminance (lower channel on R, G, and B)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>A/L8, 8-bit single channel (value on A, R, G, and B)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>ARGB1555, 16-bit ARGB with 1 bit alpha</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>ARGB4444, 16-bit ARGB with 4 bits alpha</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CONST_ALPHA</name>
            <description>Layer (n) Constant Alpha Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x000000FF</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>CONSTA</name>
                <description>Constant alpha.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_DFLT_COLOR</name>
            <description>Layer (n) Default Color Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DFLTCOL</name>
                <description>Default color (ARGB).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_BLEND_CFG</name>
            <description>Layer (n) Blending Factors Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000607</resetValue>
            <resetMask>0x00000707</resetMask>
            <fields>
              <field>
                <name>F1_SEL</name>
                <description>Selection of blending factor f1.
Other values: Reserved</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description> Constant alpha</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>Pixel alpha x Constant alpha</description>
                    <value>0x6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>F2_SEL</name>
                <description>Selection of blending factor f2.
Other values: Reserved</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>1 - Constant alpha</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>Pixel alpha x Constant alpha</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_FB_BCTRL</name>
            <description>Layer (n) FB Bus Control Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>WNUM</name>
                <description>Number of words per burst when reading the frame buffers.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>Val_0x0</name>
                    <description>Maximum burst length (16 words).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x1</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x2</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x3</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x4</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x5</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x6</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x7</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x8</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0x9</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xA</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xB</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xC</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xD</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xE</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Val_0xF</name>
                    <description>1 to 15 words per burst.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFB_ADDR</name>
            <description>Layer (n) Color FB Address Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SADDR</name>
                <description>Color FB start address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFB_LENGTH</name>
            <description>Layer (n) Color FB Length Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PITCH</name>
                <description>Pitch of color FB in bytes (signed).
The pitch is the increment from the start of one line of pixels to the start of the next line in bytes. It is a signed value. Providing negative values allows a vertical flip of the frame buffer. When reading this register, the sign bit [30] is expanded until bit [31].</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LLENGTH</name>
                <description>Line length of color FB in bytes - 1 + (width of bus in bytes).
The line length is the length of one pixel line in bytes + 7. The value of 7 relates to the bus width (8 bytes in this configuration) and serves to correctly calculate the address of the last word of data for that line internally.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CFB_LINES</name>
            <description>Layer (n) Color FB Lines Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>LNUM</name>
                <description>Number of lines in the color FB.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CDC_L_CLUT_WRACC</name>
            <description>Layer (n) CLUT Write Access Register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of CLUT entry.</description>
                <bitRange>[31:24]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>RGB_VAL</name>
                <description>RGB888 value to be written.</description>
                <bitRange>[23:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>DSI</name>
      <baseAddress>0x49032000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>404</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>DSI_IRQ</name>
        <description>DSI error interrupt</description>
        <value>343</value>
      </interrupt>
      <registers>
        <register>
          <name>DSI_VERSION</name>
          <description>DSI Host Controller Version Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3134312A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <description>Module version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PWR_UP</name>
          <description>Power-up Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHUTDOWNZ</name>
              <description>This bit configures the controller either to power up or to reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Reset the controller</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power up the controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CLKMGR_CFG</name>
          <description>Clock Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TO_CLK_DIVISION</name>
              <description>This field indicates the division factor for the Timeout clock used as the timing unit in the configuration of high-speed to low-power and low-power to high-speed transition error.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ESC_CLK_DIVISION</name>
              <description>This field indicates the division factor for the TX Escape clock source (LANEBYTECLK). The values 0 and 1 stop the TXCLKESC generation.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_VCID</name>
          <description>VC ID Configuration Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_VCID</name>
              <description>This field configures the DPI Virtual Channel ID that is indexed to the Video mode packets.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_COLOR_CODING</name>
          <description>DPI Color Coding Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOOSELY18_EN</name>
              <description>When set to 1, this bit activates loosely packed variant to 18-bit configurations.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPI_COLOR_CODING</name>
              <description>This field configures the DPI color for Video mode coding as follows:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit configuration 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>18-bit configuration 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>24-bit</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_CFG_POL</name>
          <description>DPI Polarity Configuration Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLORM_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the color mode pin (DPICOLORM) as active-low.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SHUTD_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the shutdown pin (DPISHUTDN) as active-low.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSYNC_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the horizontal synchronism pin (DPIHSYNC) as active-low.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VSYNC_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the vertical synchronism pin (DPIVSYNC) as active-low.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAEN_ACTIVE_LOW</name>
              <description>When set to 1, this bit configures the data enable pin (DPIDATAEN) as active-low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_LP_CMD_TIM</name>
          <description>DPI Low-Power Mode Configuration Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It defines the size, in bytes, of the largest packet that can fit in a line during the VSA, VBP, and VFP regions.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It defines the size, in bytes, of the largest packet that can fit in a line during the VACT region.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PCKHDL_CFG</name>
          <description>Protocol Configuration Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EOTP_TX_LP_EN</name>
              <description>When set to 1, this bit enables the EoTp transmission in low-power.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_RX_EN</name>
              <description>When set to 1, this bit enables the CRC reception and error reporting.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_RX_EN</name>
              <description>When set to 1, this bit enables the ECC reception, error correction, and reporting.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BTA_EN</name>
              <description>When set to 1, this bit enables the Bus Turn-Around (BTA) request.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOTP_RX_EN</name>
              <description>When set to 1, this bit enables the EoTp reception.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOTP_TX_EN</name>
              <description>When set to 1, this bit enables the EoTp transmission in high-speed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_GEN_VCID</name>
          <description>Generic VC ID Configuration Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_VCID_TX_AUTO</name>
              <description>This field indicates the Generic interface virtual channel identification where generic packet is automatically generated and transmitted.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VCID_TEAR_AUTO</name>
              <description>This field indicates the virtual channel identification for tear effect by hardware</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VCID_RX</name>
              <description>This field indicates the Generic interface read-back virtual channel identification.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_MODE_CFG</name>
          <description>Mode Configuration Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_VIDEO_MODE</name>
              <description>This bit configures the operation mode:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Video mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Command mode. Not supported by the DSI controller in this device.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_MODE_CFG</name>
          <description>Video Mode Configuration Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VPG_ORIENTATION</name>
              <description>This field indicates the color bar orientation as follows:</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Vertical mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Horizontal mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VPG_MODE</name>
              <description>This field is to select the pattern:</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Horizontal or vertical</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Vertical only</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VPG_EN</name>
              <description>When set to 1, this bit enables the video mode pattern generator.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_EN</name>
              <description>When set to 1, this bit enables the command transmission only in low-power mode.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_BTA_ACK_EN</name>
              <description>When set to 1, this bit enables the request for an acknowledge response at the end of a frame.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_HFP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the HFP period when timing allows.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_HBP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the HBP period when timing allows.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VACT_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VACT period when timing allows.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VFP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VFP period when timing allows.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VBP_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VBP period when timing allows.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VSA_EN</name>
              <description>When set to 1, this bit enables the return to low-power inside the VSA period when timing allows.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VID_MODE_TYPE</name>
              <description>This field indicates the video mode transmission type as follows:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Non-Burst with sync pulses</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-Burst with sync events</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Burst mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Burst mode</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_PKT_SIZE</name>
          <description>Video Packet Size Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_PKT_SIZE</name>
              <description>This field configures the number of pixels in a single video packet.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NUM_CHUNKS</name>
          <description>Video Chunks Configuration Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NUM_CHUNKS</name>
              <description>This register configures the number of chunks to be transmitted during a Line period (a chunk is pair made of a video packet and a null packet). If set to 0 or 1, video line is still transmitted in a single packet. If set to 1 that packet is part of a chunk, meaning that a null packet follows it (if DSI_VID_NULL_SIZE &gt; 0). Otherwise, multiple chunks are used to transmit each video line.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NULL_SIZE</name>
          <description>Video Null Packet Configuration Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NULL_SIZE</name>
              <description>This register configures the number of bytes inside a null packet. Setting to 0 disables null packets.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HSA_TIME</name>
          <description>Video HSA Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HSA_TIME</name>
              <description>This field configures the Horizontal Synchronism Active period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HBP_TIME</name>
          <description>Video HBP Configuration Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HBP_TIME</name>
              <description>This field configures the HBP period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HLINE_TIME</name>
          <description>Video Line Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HLINE_TIME</name>
              <description>This field configures the size of the total line time (HSA + HBP + HACT + HFP) counted in LANEBYTECLK cycles.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VSA_LINES</name>
          <description>Video VSA Configuration Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VSA_LINES</name>
              <description>This field configures the VSA period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VBP_LINES</name>
          <description>Video VBP Configuration Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VBP_LINES</name>
              <description>This field configures the VBP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VFP_LINES</name>
          <description>Video VFP Configuration Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VFP_LINES</name>
              <description>This field configures the VFP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VACTIVE_LINES</name>
          <description>Video VA Configuration Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>V_ACTIVE_LINES</name>
              <description>This field configures the VA period measured in number of horizontal lines.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CMD_MODE_CFG</name>
          <description>Generic Packet Command Configuration Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_RD_PKT_SIZE</name>
              <description>This bit configures the maximum read packet size command transmission type:</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_LW_TX</name>
              <description>This bit configures the Generic long write packet command transmission type:</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SR_2P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SR_1P_TX</name>
              <description>This bit configures the Generic short read packet with one parameter command transmission type:</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SR_0P_TX</name>
              <description>This bit configures the Generic short read packet with zero parameter command transmission type:</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SW_2P_TX</name>
              <description>This bit configures the Generic short write packet with two parameters command transmission type:</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SW_1P_TX</name>
              <description>This bit configures the Generic short write packet with one parameter command transmission type:</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GEN_SW_0P_TX</name>
              <description>This bit configures the Generic short write packet with zero parameter command transmission type:</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transition type is high-speed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transition type is low-power</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACK_RQST_EN</name>
              <description>When set to 1, this bit enables the acknowledge request after each packet transmission.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_GEN_HDR</name>
          <description>Generic Header Configuration Register</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_WC_MSBYTE</name>
              <description>This field configures the most significant byte of the header packet's word count for long packets or data 1 for short packets.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_WC_LSBYTE</name>
              <description>This field configures the least significant byte of the header packet's Word count for long packets or data 0 for short packets.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VC</name>
              <description>This field configures the Virtual Channel ID of the header packet.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_DT</name>
              <description>This field configures the packet Data Type of the header packet.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_GEN_PLD_DATA</name>
          <description>Generic Payload Data Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_PLD_B4</name>
              <description>This field indicates byte 4 of the packet payload.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B3</name>
              <description>This field indicates byte 3 of the packet payload.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B2</name>
              <description>This field indicates byte 2 of the packet payload.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B1</name>
              <description>This field indicates byte 1 of the packet payload.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CMD_PKT_STATUS</name>
          <description>Generic Packet Status Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00050015</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_BUFF_PLD_FULL</name>
              <description>This bit indicates the full status of the generic payload internal buffer.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_PLD_EMPTY</name>
              <description>This bit indicates the empty status of the generic payload internal buffer.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_CMD_FULL</name>
              <description>This bit indicates the full status of the generic command internal buffer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_CMD_EMPTY</name>
              <description>This bit indicates the empty status of the generic command internal buffer.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_RD_CMD_BUSY</name>
              <description>This bit is set when a read command is issued and cleared when the entire response is stored in the FIFO for Generic interface.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_R_FULL</name>
              <description>This bit indicates the full status of the generic read payload FIFO.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_R_EMPTY</name>
              <description>This bit indicates the empty status of the generic read payload FIFO.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_W_FULL</name>
              <description>This bit indicates the full status of the generic write payload FIFO.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_W_EMPTY</name>
              <description>This bit indicates the empty status of the generic write payload FIFO.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_FULL</name>
              <description>This bit indicates the full status of the generic command FIFO.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_EMPTY</name>
              <description>This bit indicates the empty status of the generic command FIFO.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_TO_CNT_CFG</name>
          <description>Timeout Counter Configuration Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSTX_TO_CNT</name>
              <description>This field configures the timeout counter that triggers a high-speed transmission timeout contention detection (measured in DSI_CLKMGR_CFG[TO_CLK_DIVISION] cycles).
If using non-burst mode and there is not sufficient time to switch from high-speed to low-power and back in the period which is from one line data finishing to the next line sync start, the DSI link returns low-power state once per frame, then the DSI_CLKMGR_CFG[TO_CLK_DIVISION] and HSTX_TO_CNT fields should be configured to satisfy the following formula: 
HSTX_TO_CNT x LANEBYTECLK_period x TO_CLK_DIVISION &gt;= the time of one FRAME data transmission x (1 + 10%) 
In burst mode, RGB pixel packets are time-compressed, leaving more time during a scan line. So if in burst mode and there is sufficient time to switch from high-speed to low-power and back in the period of time from one line data finishing to the next line sync start, the DSI link can return low-power mode and back in this time interval to save power. If this case, the DSI_CLKMGR_CFG[TO_CLK_DIVISION] and HSTX_TO_CNT fields should be configured to satisfy the following formula: 
HSTX_TO_CNT x LANEBYTECLK_period x TO_CLK_DIVISION &gt;= the time of one LINE data transmission x (1 + 10%)</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPRX_TO_CNT</name>
              <description>This field configures the timeout counter that triggers a low-power reception timeout contention detection (measured in DSI_CLKMGR_CFG[TO_CLK_DIVISION] cycles).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_HS_RD_TO_CNT</name>
          <description>HS Read Timeout Configuration Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HS_RD_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a high-speed Read operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_LP_RD_TO_CNT</name>
          <description>LP Read Timeout Configuration Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LP_RD_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a low-power Read operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_HS_WR_TO_CNT</name>
          <description>HS Write Timeout Configuration Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HS_WR_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a high-speed Write operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_LP_WR_TO_CNT</name>
          <description>LP Write Timeout Configuration Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LP_WR_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after sending a low-power Write operation. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_BTA_TO_CNT</name>
          <description>BTA Timeout Configuration Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BTA_TO_CNT</name>
              <description>This field sets a period for which DSI controller keeps the link still, after completing a BTA. This period is measured in cycles of LANEBYTECLK, starts to count when the D-PHY enters Stop state and causes no interrupts.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_SDF_3D</name>
          <description>3D Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEND_3D_CFG</name>
              <description>When set, causes the next VSS packet to include 3D control payload in every VSS packet.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT_FIRST</name>
              <description>This bit defines the left/right order:</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Left eye is sent first, then right eye</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Right eye data is sent first, then left eye</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECOND_VSYNC</name>
              <description>This field defines whether there is a second VSYNC pulse between Left and Right Images, when 3D Image Format is Frame-based:</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No sync pulses between left and right data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sync pulse HSYNC, VSYNC, blanking between left and right data</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORMAT_3D</name>
              <description>This field defines 3D Image Format:</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Alternating lines of left and right data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Alternating frames of left and right data</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Alternating pixels of left and right data</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE_3D</name>
              <description>This field defines 3D Mode On/Off and Display Orientation:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3D Mode Off , 2D Mode On</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3D Mode On, Portrait Orientation</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3D Mode On, Landscape Orientation</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_LPCLK_CTRL</name>
          <description>Clock Lane Power Control Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUTO_CLKLANE_CTRL</name>
              <description>This bit enables the automatic mechanism to stop providing clock in the clock lane when time allows.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQUESTCLKHS</name>
              <description>This bit controls the D-PHY PPI TXREQUESTCLKHS signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TMR_LPCLK_CFG</name>
          <description>Clock Lane Timer Configuration Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_CLKHS2LP_TIME</name>
              <description>This field configures the maximum time that the D-PHY clock lane takes to go from high-speed to low-power transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_CLKLP2HS_TIME</name>
              <description>This field configures the maximum time that the D-PHY clock lane takes to go from low-power to high-speed transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TMR_CFG</name>
          <description>Data Lane Timer Configuration Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_HS2LP_TIME</name>
              <description>This field configures the maximum time that the D-PHY data lanes take to go from high-speed to low-power transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_LP2HS_TIME</name>
              <description>This field configures the maximum time that the D-PHY data lanes take to go from low-power to high-speed transmission measured in LANEBYTECLK cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_RSTZ</name>
          <description>PHY Control Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_FORCEPLL</name>
              <description>When the D-PHY is in ULPS, this bit enables the D-PHY PLL.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_ENABLECLK</name>
              <description>When set to 1, this bit enables the D-PHY Clock Lane module.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_RSTZ</name>
              <description>When set to 0, this bit places the digital section of the D-PHY in the reset state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_SHUTDOWNZ</name>
              <description>When set to 0, this bit places the all D-PHY sub-blocks in power-down state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_IF_CFG</name>
          <description>PHY Configuration Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_STOP_WAIT_TIME</name>
              <description>This field configures the minimum time PHY needs to stay in Stop state before requesting an high-speed transmission.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>N_LANES</name>
              <description>This field configures the number of active data lanes:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Data lane 0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data lanes 0 and 1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_ULPS_CTRL</name>
          <description>PHY ULPS Control Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TXEXITULPSLAN</name>
              <description>ULPS mode Exit on all active data lanes.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQULPSLAN</name>
              <description>ULPS mode Request on all active data lanes.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXEXITULPSCLK</name>
              <description>ULPS mode Exit on clock lane.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQULPSCLK</name>
              <description>ULPS mode Request on clock lane.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TX_TRIGGERS</name>
          <description>PHY TX Trigger Configuration Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TX_TRIGGERS</name>
              <description>This field controls the trigger transmissions.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_STATUS</name>
          <description>PHY Status Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000140</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_ULPSACTIVENOT1LANE</name>
              <description>This bit indicates the status of ULPSACTIVENOT1LANE D-PHY signal.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE1LANE</name>
              <description>This bit indicates the status of PHYSTOPSTATE1LANE D-PHY signal.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC0LANE</name>
              <description>This bit indicates the status of RXULPSESC0LANE D-PHY signal.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOT0LANE</name>
              <description>This bit indicates the status of ULPSACTIVENOT0LANE D-PHY signal.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE0LANE</name>
              <description>This bit indicates the status of PHYSTOPSTATE0LANE D-PHY signal.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOTCLK</name>
              <description>This bit indicates the status of PHYULPSACTIVENOTCLK D-PHY signal.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATECLKLANE</name>
              <description>This bit indicates the status of PHYSTOPSTATECLKLANE D-PHY signal.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_DIRECTION</name>
              <description>This bit indicates the status of PHYDIRECTION D-PHY signal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_LOCK</name>
              <description>This bit indicates the status of PHYLOCK D-PHY signal.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TST_CTRL0</name>
          <description>PHY Test Interface Control Register 0</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTCLK</name>
              <description>This bit is used to clock the TESTDIN bus into the D-PHY.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTCLR</name>
              <description>PHY test interface clear (active-high).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TST_CTRL1</name>
          <description>PHY Test Interface Control Register 1</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTEN</name>
              <description>PHY test interface operation selector:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The data write operation is set on the rising edge of the TESTCLK signal.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The address write operation is set on the falling edge of the TESTCLK signal.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PHT_TESTDOUT</name>
              <description>PHY output 8-bit data bus for read-back and internal probing functionalities.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_TESTDIN</name>
              <description>PHY test interface input 8-bit data bus for internal register programming and test functionalities access.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_ST0</name>
          <description>Interrupt Status Register 0</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPHY_ERRORS_4</name>
              <description>This bit indicates LP1 contention error ErrContentionLP1 from Lane 0.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_3</name>
              <description>This bit indicates LP0 contention error ErrContentionLP0 from Lane 0.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_2</name>
              <description>This bit indicates control error ErrControl from Lane 0.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_1</name>
              <description>This bit indicates ErrSyncEsc low-power data transmission synchronization error from Lane 0.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_0</name>
              <description>This bit indicates ErrEsc escape entry error from Lane 0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_15</name>
              <description>This bit retrieves the DSI protocol violation from the Acknowledge error report.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_14</name>
              <description>This bit retrieves the reserved (specific to device) from the Acknowledge error report.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_13</name>
              <description>This bit retrieves the invalid transmission length from the Acknowledge error report.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_12</name>
              <description>This bit retrieves the DSI VC ID Invalid from the Acknowledge error report.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_11</name>
              <description>This bit retrieves the not recognized DSI data type from the Acknowledge error report.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_10</name>
              <description>This bit retrieves the checksum error (long packet only) from the Acknowledge error report.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_9</name>
              <description>This bit retrieves the ECC error, multi-bit (detected, not corrected) from the Acknowledge error report.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_8</name>
              <description>This bit retrieves the ECC error, single-bit (detected and corrected) from the Acknowledge error report.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_7</name>
              <description>This bit retrieves the reserved (specific to device) from the acknowledge error report.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_6</name>
              <description>This bit retrieves the False Control error from the Acknowledge error report.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_5</name>
              <description>This bit retrieves the Peripheral Timeout error from the Acknowledge error report.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_4</name>
              <description>This bit retrieves the low-power Transmit Sync error from the Acknowledge error report.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_3</name>
              <description>This bit retrieves the Escape Mode Entry Command error from the Acknowledge error report.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_2</name>
              <description>This bit retrieves the EoT Sync error from the Acknowledge error report.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_1</name>
              <description>This bit retrieves the SoT Sync error from the Acknowledge error report.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_0</name>
              <description>This bit retrieves the SoT error from the Acknowledge error report.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_ST1</name>
          <description>Interrupt Status Register 1</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_BUFF_PLD_UNDER</name>
              <description>This bit indicates that an underflow has occurred when reading payload to build DSI packet for video mode.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_RECEV_ERR</name>
              <description>This bit indicates that during a generic interface packet read back, the payload FIFO becomes full and the received data is corrupted.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_RD_ERR</name>
              <description>This bit indicates that during a DCS read data, the payload FIFO becomes empty and the data sent to the interface is corrupted.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_SEND_ERR</name>
              <description>This bit indicates that during a Generic interface packet build, the payload FIFO becomes empty and corrupt data is sent.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_WR_ERR</name>
              <description>This bit indicates that the system tried to write a payload data through the Generic interface and the FIFO is full. Therefore, the payload is not written.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_WR_ERR</name>
              <description>This bit indicates that the system tried to write a command through the Generic interface and the FIFO is full. Therefore, the command is not written.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_WR_ERR</name>
              <description>This bit indicates that during a DPI pixel line storage, the payload FIFO becomes full and the data stored is corrupted.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EOPT_ERR</name>
              <description>This bit indicates that the EoTp packet has not been received at the end of the incoming peripheral transmission.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PKT_SIZE_ERR</name>
              <description>This bit indicates that the packet size error has been detected during the packet reception.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRC_ERR</name>
              <description>This bit indicates that the CRC error has been detected in the received packet payload.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_MILTI_ERR</name>
              <description>This bit indicates that the ECC multiple error has been detected in a received packet.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_SINGLE_ERR</name>
              <description>This bit indicates that the ECC single error has been detected and corrected in a received packet.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TO_LP_RX</name>
              <description>This bit indicates that the low-power reception timeout counter reached the end and contention has been detected.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TO_HS_TX</name>
              <description>This bit indicates that the high-speed transmission timeout counter reached the end and contention has been detected.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_MSK0</name>
          <description>Interrupt Mask Register 0</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_DPHY_ERRORS_4</name>
              <description>Mask for DPHY_ERRORS_4.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_3</name>
              <description>Mask for DPHY_ERRORS_3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_2</name>
              <description>Mask for DPHY_ERRORS_2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_1</name>
              <description>Mask for DPHY_ERRORS_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_0</name>
              <description>Mask for DPHY_ERRORS_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_15</name>
              <description>Mask for ACK_WITH_ERR_15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_14</name>
              <description>Mask for ACK_WITH_ERR_14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_13</name>
              <description>Mask for ACK_WITH_ERR_13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_12</name>
              <description>Mask for ACK_WITH_ERR_12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_11</name>
              <description>Mask for ACK_WITH_ERR_11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_10</name>
              <description>Mask for ACK_WITH_ERR_10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_9</name>
              <description>Mask for ACK_WITH_ERR_9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_8</name>
              <description>Mask for ACK_WITH_ERR_8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_7</name>
              <description>Mask for ACK_WITH_ERR_7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_6</name>
              <description>Mask for ACK_WITH_ERR_6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_5</name>
              <description>Mask for ACK_WITH_ERR_5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_4</name>
              <description>Mask for ACK_WITH_ERR_4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_3</name>
              <description>Mask for ACK_WITH_ERR_3</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_2</name>
              <description>Mask for ACK_WITH_ERR_2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_1</name>
              <description>Mask for ACK_WITH_ERR_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_0</name>
              <description>Mask for ACK_WITH_ERR_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_MSK1</name>
          <description>Interrupt Mask Register 1</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_DPI_BUFF_PLD_UNDER</name>
              <description>Mask for DPI_BUFF_PLD_UNDER.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_RECEV_ERR</name>
              <description>Mask for GEN_PLD_RECEV_ERR.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_RD_ERR</name>
              <description>Mask for GEN_PLD_RD_ERR.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_SEND_ERR</name>
              <description>Mask for GEN_PLD_SEND_ERR.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_WR_ERR</name>
              <description>Mask for GEN_PLD_WR_ERR.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_CMD_WR_ERR</name>
              <description>Mask for GEN_CMD_WR_ERR.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPI_PLD_WR_ERR</name>
              <description>Mask for DPI_PLD_WR_ERR.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_EOPT_ERR</name>
              <description>Mask for EOPT_ERR.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PKT_SIZE_ERR</name>
              <description>Mask for PKT_SIZE_ERR.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_CRC_ERR</name>
              <description>Mask for CRC_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ECC_MILTI_ERR</name>
              <description>Mask for ECC_MILTI_ERR.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ECC_SINGLE_ERR</name>
              <description>Mask for ECC_SINGLE_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_TO_LP_RX</name>
              <description>Mask for TO_LP_RX.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_TO_HS_TX</name>
              <description>Mask for TO_HS_TX.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_CAL</name>
          <description>PHY skew calibration control</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXSKEWCALHS</name>
              <description>High-speed skew calibration is started when this field is set high (assuming that PHY is in Stop state).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_FORCE0</name>
          <description>Force Interrupt Register 0</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_DPHY_ERRORS_4</name>
              <description>Force DPHY_ERRORS_4.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_3</name>
              <description>Force DPHY_ERRORS_3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_2</name>
              <description>Force DPHY_ERRORS_2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_1</name>
              <description>Force DPHY_ERRORS_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_0</name>
              <description>Force DPHY_ERRORS_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_15</name>
              <description>Force ACK_WITH_ERR_15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_14</name>
              <description>Force ACK_WITH_ERR_14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_13</name>
              <description>Force ACK_WITH_ERR_13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_12</name>
              <description>Force ACK_WITH_ERR_12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_11</name>
              <description>Force ACK_WITH_ERR_11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_10</name>
              <description>Force ACK_WITH_ERR_10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_9</name>
              <description>Force ACK_WITH_ERR_9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_8</name>
              <description>Force ACK_WITH_ERR_8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_7</name>
              <description>Force ACK_WITH_ERR_7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_6</name>
              <description>Force ACK_WITH_ERR_6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_5</name>
              <description>Force ACK_WITH_ERR_5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_4</name>
              <description>Force ACK_WITH_ERR_4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_3</name>
              <description>Force ACK_WITH_ERR_3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_2</name>
              <description>Force ACK_WITH_ERR_2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_1</name>
              <description>Force ACK_WITH_ERR_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_0</name>
              <description>Force ACK_WITH_ERR_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_INT_FORCE1</name>
          <description>Force Interrupt Register 1</description>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_DPI_BUFF_PLD_UNDER</name>
              <description>Force for DPI_BUFF_PLD_UNDER.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_RECEV_ERR</name>
              <description>Force GEN_PLD_RECEV_ERR.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_RD_ERR</name>
              <description>Force GEN_PLD_RD_ERR.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_SEND_ERR</name>
              <description>Force GEN_PLD_SEND_ERR.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_WR_ERR</name>
              <description>Force GEN_PLD_WR_ERR.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_CMD_WR_ERR</name>
              <description>Force GEN_CMD_WR_ERR.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPI_PLD_WR_ERR</name>
              <description>Force DPI_PLD_WR_ERR.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_EOPT_ERR</name>
              <description>Force EOPT_ERR.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PKT_SIZE_ERR</name>
              <description>Force PKT_SIZE_ERR.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_CRC_ERR</name>
              <description>Force CRC_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ECC_MILTI_ERR</name>
              <description>Force ECC_MILTI_ERR.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ECC_SINGLE_ERR</name>
              <description>Force ECC_SINGLE_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_TO_LP_RX</name>
              <description>Force TO_LP_RX.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_TO_HS_TX</name>
              <description>Force TO_HS_TX.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_PHY_TMR_RD_CFG</name>
          <description>Data Lane Timer Read Configuration Register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_RD_TIME</name>
              <description>This field configures the maximum time required to perform a read command in LANEBYTECLK cycles. This register can only be modified when no read command is in progress.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_SHADOW_CTRL</name>
          <description>Video Shadow Control Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_SHADOW_REQ</name>
              <description>When set to 1, this bit requests that the DPI registers are copied to the auxiliary registers. When the request is completed this bit is auto cleared.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VID_SHADOW_EN</name>
              <description>When set to 1, DPI receives the active configuration from the auxiliary registers. When the feature is set at the same time than VID_SHADOW_REQ the auxiliary registers are automatically updated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_VCID_ACT</name>
          <description>Current VC ID Register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_VCID</name>
              <description>This field specifies the DPI Virtual Channel ID that is indexed to the Video mode packets.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_COLOR_CODING_ACT</name>
          <description>Current Color Coding Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOOSELY18_EN</name>
              <description>When 1, this bit activates loosely packed variant to 18-bit configurations.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_COLOR_CODING</name>
              <description>This field configures the DPI color for Video Mode/eDPI Command Mode coding as follows:</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit configuration 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>18-bit configuration 2</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>24-bit</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_DPI_LP_CMD_TIM_ACT</name>
          <description>Low-Power Mode Current Configuration Register</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It specifies the size, in bytes, of the largest packet that can fit in a line during the VSA, VBP, and VFP regions.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INVACT_LPCMD_TIME</name>
              <description>This field is used for the transmission of commands in low-power mode. It specifies the size, in bytes, of the largest packet that can fit in a line during the VACT region.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_MODE_CFG_ACT</name>
          <description>Video Mode Current Configuration Register</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LP_CMD_EN</name>
              <description>When 1, this bit enables the command transmission only in low-power mode.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_BTA_ACK_EN</name>
              <description>When 1, this bit enables the request for an acknowledge response at the end of a frame.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_HFP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the HFP period when timing allows.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_HBP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the HBP period when timing allows.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VACT_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VACT period when timing allows.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VFP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VFP period when timing allows.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VBP_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VBP period when timing allows.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VSA_EN</name>
              <description>When 1, this bit enables the return to low-power inside the VSA period when timing allows.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VID_MODE_TYPE</name>
              <description>This field specifies the Video mode transmission type as follows:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Non-Burst with sync pulses</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Non-Burst with sync events</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Burst mode</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Burst mode</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_PKT_SIZE_ACT</name>
          <description>Video Packet Size Current Configuration Register</description>
          <addressOffset>0x13C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_PKT_SIZE</name>
              <description>This field specifies the number of pixels in a single video packet.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NUM_CHUNKS_ACT</name>
          <description>Video Chunks Current Configuration Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NUM_CHUNKS</name>
              <description>This register specifies the number of chunks to be transmitted during a Line period (a chunk is pair made of a video packet and a null packet). If set to 0 or 1, video line is still transmitted in a single packet. If set to 1 that packet is part of a chunk, meaning that a null packet follows it (if DSI_VID_NULL_SIZE &gt; 0). Otherwise, multiple chunks are used to transmit each video line.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_NULL_SIZE_ACT</name>
          <description>Video Null Packet Size Current Configuration Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_NULL_SIZE</name>
              <description>This register specifies the number of bytes inside a null packet. Setting to 0 disables null packets.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HSA_TIME_ACT</name>
          <description>Video HSA Current Configuration Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HSA_TIME</name>
              <description>This field specifies the HSA period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HBP_TIME_ACT</name>
          <description>Video HBP Current Configuration Register</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HBP_TIME</name>
              <description>This field specifies the HBP period in LANEBYTECLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_HLINE_TIME_ACT</name>
          <description>Video Line Current Configuration Register</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VID_HLINE_TIME</name>
              <description>This field specifies the size of the total line time (HSA + HBP + HACT + HFP) counted in LANEBYTECLK cycles.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VSA_LINES_ACT</name>
          <description>Video VSA Current Configuration Register</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VSA_LINES</name>
              <description>This field specifies the VSA period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VBP_LINES_ACT</name>
          <description>Video VBP Current Configuration Register</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VBP_LINES</name>
              <description>This field specifies the VBP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VFP_LINES_ACT</name>
          <description>Video VFP Current Configuration Register</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VFP_LINES</name>
              <description>This field specifies the VFP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_VACTIVE_LINES_ACT</name>
          <description>Video VA Current Configuration Register</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>V_ACTIVE_LINES</name>
              <description>This field specifies the VA period measured in number of horizontal lines.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_VID_PKT_STATUS</name>
          <description>Video Packet Status Register</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00010005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPI_BUFF_PLD_FULL</name>
              <description>This bit indicates the full status of the payload internal buffer for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_BUFF_PLD_EMPTY</name>
              <description>This bit indicates the empty status of the payload internal buffer for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_W_FULL</name>
              <description>This bit indicates the full status of write payload FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_W_EMPTY</name>
              <description>This bit indicates the empty status of write payload FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_CMD_W_FULL</name>
              <description>This bit indicates the full status of write command FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_CMD_W_EMPTY</name>
              <description>This bit indicates the empty status of write command FIFO for Video mode. This bit is set to 0 for Command mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_SDF_3D_ACT</name>
          <description>3D Current Configuration Register</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEND_3D_CFG</name>
              <description>When set, causes the next VSS packet to include 3D control payload in every VSS packet.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RIGHT_FIRST</name>
              <description>This bit specifies the left/right order:</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Left eye is sent first, then right eye</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Right eye data is sent first, then left eye</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SECOND_VSYNC</name>
              <description>This field specifies whether there is a second VSYNC pulse between Left and Right Images, when 3D Image Format is Frame-based:</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No sync pulses between left and right data.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Sync pulse (HSYNC, VSYNC, blanking) between left and right data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FORMAT_3D</name>
              <description>This field specifies 3D Image Format:</description>
              <bitRange>[3:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Alternating lines of left and right data</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Alternating frames of left and right data</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Alternating pixels of left and right data</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE_3D</name>
              <description>This field specifies 3D Mode On/Off and Display Orientation:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3D Mode Off, 2D Mode On</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>3D Mode On, Portrait Orientation</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3D Mode On, Landscape Orientation</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CSI</name>
      <baseAddress>0x49033000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>780</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>CSI_IRQ</name>
        <description>CSI interrupt</description>
        <value>344</value>
      </interrupt>
      <registers>
        <register>
          <name>CSI_VERSION</name>
          <description>Module Version Code Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3134302A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <description>Module version code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_N_LANES</name>
          <description>Lane Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>N_LANES</name>
              <description>This can only be updated when the PHY lane is in Stop state.
Number of active data lanes:</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 Data Lane</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 Data Lanes</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_CSI2_RESETN</name>
          <description>CSI Controller Reset Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSI2_RESETN</name>
              <description>CSI controller reset output. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_MAIN</name>
          <description>Main Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS_INT_IPI_FATAL</name>
              <description>Status of INT_ST_IPI_FATAL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_LINE</name>
              <description>Status of INT_ST_LINE.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_PHY</name>
              <description>Status of INT_ST_PHY.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_ECC_CORRECTED</name>
              <description>Status of STATUS_INT_ECC_CORRECTED.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_DATA_ID</name>
              <description>Status of STATUS_INT_DATA_ID.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_PLD_CRC_FATAL</name>
              <description>Status of STATUS_INT_PLD_CRC_FATAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_CRC_FRAME_FATAL</name>
              <description>Status of STATUS_INT_CRC_FRAME_FATAL.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_SEQ_FRAME_FATAL</name>
              <description>Status of STATUS_INT_SEQ_FRAME_FATAL.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_BNDRY_FRAME_FATAL</name>
              <description>Status of INT_ST_BNDRY_FRAME_FATAL.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_PKT_FATAL</name>
              <description>Status of INT_ST_PKT_FATAL.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>STATUS_INT_PHY_FATAL</name>
              <description>Status of INT_ST_PHY_FATAL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_DATA_IDS_1</name>
          <description>DT Data ID Monitors Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DI3_DT</name>
              <description>Data type for programmed Data ID 3.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI2_DT</name>
              <description>Data type for programmed Data ID 2.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_DT</name>
              <description>Data type for programmed Data ID 1.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_DT</name>
              <description>Data type for programmed data ID 0.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_DATA_IDS_VC_1</name>
          <description>VC Data ID Monitors Configuration Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DI3_VCX_0_1</name>
              <description>Virtual channel extension for programmed Data ID 3.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI3_VC</name>
              <description>Virtual channel for programmed Data ID 3.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI2_VCX_0_1</name>
              <description>Virtual channel extension for programmed Data ID 2.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI2_VC</name>
              <description>Virtual channel for programmed Data ID 2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_VCX_0_1</name>
              <description>Virtual channel extension for programmed Data ID 1.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_VC</name>
              <description>Virtual channel for programmed Data ID 1.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_VCX_0_1</name>
              <description>Virtual channel extension for programmed data ID 0.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_VC</name>
              <description>Virtual channel for programmed Data ID 0.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_SHUTDOWNZ</name>
          <description>PHY Shutdown Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_SHUTDOWNZ</name>
              <description>Shutdown input. This line is used to place the complete PHY module in power down. All analog blocks are in power down mode and digital logic is cleared. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_DPHY_RSTZ</name>
          <description>PHY Reset Control Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPHY_RSTZ</name>
              <description>PHY reset output. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_RX</name>
          <description>PHY RX Signals Status Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_RXCLKACTIVEHS</name>
              <description>Indicates that D-PHY clock lane is actively receiving a DDR clock.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSCLKNOT</name>
              <description>Active low. This signal indicates that D-PHY Clock Lane module has entered the Ultra Low Power State.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC_1</name>
              <description>Lane module 1 has entered the Ultra Low Power mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC_0</name>
              <description>Lane module 0 has entered the Ultra Low Power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_STOPSTATE</name>
          <description>PHY STOPSTATE Signal Status Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_STOPSTATECLK</name>
              <description>D-PHY Clock lane in Stop state.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATEDATA_1</name>
              <description>Data lane 1 in Stop state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATEDATA_0</name>
              <description>Data lane 0 in Stop state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_TEST_CTRL0</name>
          <description>PHY Test Control 0 Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTCLK</name>
              <description>Clock to capture TESTDIN bus contents into the PHY module, with TESTEN signal controlling the operation selection.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTCLR</name>
              <description>When active, performs test interface initialization. Active high.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_TEST_CTRL1</name>
          <description>PHY Test Control 1 Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTEN</name>
              <description>When asserted high, it configures an address write operation on the falling edge of TESTCLK. When asserted low, it configures a data write operation on the rising edge of TESTCLK.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTDOUT</name>
              <description>Test interface 8-bit data output for reading data and other probing functionalities.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_TESTDIN</name>
              <description>Test interface 8-bit data input for programming internal registers and accessing test functionalities.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_MODE</name>
          <description>IPI Mode Selection Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_ENABLE</name>
              <description>This register enables the interface.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_CUT_THROUGH</name>
              <description>This field indicates Cut-Through mode state:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Cut-Through mode inactive</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Cut-Through mode active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPI_COLOR_COM</name>
              <description>This field indicates if color mode components are delivered as follows:</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>48-bit interface</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>16-bit interface</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPI_MODE</name>
              <description>This field indicates the video mode transmission type as follows:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Camera timing</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Controller timing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VCID</name>
          <description>IPI VC Selection Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VCX_0_1</name>
              <description>Virtual channel extension of data to be processed by pixel interface.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IP_VCID</name>
              <description>Virtual channel of data to be processed by pixel interface.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_DATA_TYPE</name>
          <description>IPI DT Selection Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMBEDDED_DATA</name>
              <description>This bit enables embedded data processing on IPI interface.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_DATA_TYPE</name>
              <description>Data type of data to be processed by pixel interface.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_MEM_FLUSH</name>
          <description>IPI Memory Flush Control Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_AUTO_FLUSH</name>
              <description>Memory is automatically flushed at each Vsync.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_FLUSH</name>
              <description>Flush IPI memory. This bit is auto cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HSA_TIME</name>
          <description>IPI HSA Configuration Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HSA_TIME</name>
              <description>This field configures the HSA period in PIXCLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HBP_TIME</name>
          <description>IPI HBP Configuration Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HBP_TIME</name>
              <description>This field configures the HBP period in PIXCLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HSD_TIME</name>
          <description>IPI HSD Configuration Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HSD_TIME</name>
              <description>This field configures the HSP delay period in PIXCLK cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_HLINE_TIME</name>
          <description>IPI HLINE Configuration Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_HLINE_TIME</name>
              <description>This field configures the size of the line time counted in PIXCLK cycles.</description>
              <bitRange>[14:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_SOFTRSTN</name>
          <description>IPI Reset Control Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_SOFTRSTN</name>
              <description>This field resets IPI. Active low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_ADV_FEATURES</name>
          <description>IPI Advanced Features Configuration Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_SYNC_EVENT_MODE</name>
              <description>For Camera Mode:</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Frame Start do not trigger any sync event.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Legacy mode. Frame Start triggers a sync event.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN_EMBEDDED</name>
              <description>This field allows the use of embedded packets for IPI synchronization events.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_BLANKING</name>
              <description>This field allows the use of blanking packets for IPI synchronization events.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_NULL</name>
              <description>This field allows the use of null packets for IPI synchronization events.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_LINE_START</name>
              <description>This field allows the use of line start packets for IPI synchronization events.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_VIDEO</name>
              <description>This field allows the use of video packets for IPI synchronization events.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINE_EVENT_SELECTION</name>
              <description>For Camera Mode, this field allows manual selection of the Packet for line delimiter as follows:</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Controller selects it automatically.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select packets from list programmed in bits [21-17] of this register.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IPI_DT</name>
              <description>Data type to overwrite.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_DT_OVERWRITE</name>
              <description>Ignore Data type of the header using the programmed Data type for decoding.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VSA_LINES</name>
          <description>IPI VSA Configuration Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VSA_LINES</name>
              <description>This field configures the VSA period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VBP_LINES</name>
          <description>IPI VBP Configuration Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VBP_LINES</name>
              <description>This field configures the VBP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VFP_LINES</name>
          <description>IPI VFP Configuration Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VFP_LINES</name>
              <description>This field configures the VFP period measured in number of horizontal lines.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_IPI_VACTIVE_LINES</name>
          <description>IPI VACTIVE Configuration Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPI_VACTIVE_LINES</name>
              <description>This field configures the Vertical Active period measured in number of horizontal lines.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_VC_EXTENSION</name>
          <description>VC Extension Configuration Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VCX</name>
              <description>This field indicates status of virtual channel extension:</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Virtual channel extension is enabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Legacy mode. Virtual channel extension is disabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PHY_CAL</name>
          <description>PHY CALIBRATION Signal Status Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXSKEWCALHS</name>
              <description>A low-to-high transition on RXSKEWCALHS signal means that the PHY has initiated the deskew calibration.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PHY_FATAL</name>
          <description>PHY Packet Discarded Interrupt Status Register</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_ERRSOTSYNCHS_1</name>
              <description>Start of transmission error on data lane 1 (no synchronization achieved).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRSOTSYNCHS_0</name>
              <description>Start of transmission error on data lane 0 (no synchronization achieved).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PHY_FATAL</name>
          <description>PHY Packet Discarded Interrupt Mask Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_PHY_ERRSOTSYNCHS_1</name>
              <description>Mask for PHY_ERRSOTSYNCHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTSYNCHS_0</name>
              <description>Mask for PHY_ERRSOTSYNCHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PHY_FATAL</name>
          <description>PHY Packet Discarded Interrupt Force Register</description>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_PHY_ERRSOTSYNCHS_1</name>
              <description>Force PHY_ERRSOTSYNCHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTSYNCHS_0</name>
              <description>Force PHY_ERRSOTSYNCHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PKT_FATAL</name>
          <description>PHY Packet Construction Interrupt Status Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_DOUBLE</name>
              <description>D-PHY mode: Header ECC contains at least 2 errors, unrecoverable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PKT_FATAL</name>
          <description>PHY Packet Construction Interrupt Mask Register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_ERR_ECC_DOUBLE</name>
              <description>Mask for ERR_ECC_DOUBLE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PKT_FATAL</name>
          <description>PHY Packet Construction Interrupt Force Register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_ECC_DOUBLE</name>
              <description>Force ERR_ECC_DOUBLE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PHY</name>
          <description>PHY Interrupt Status Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PHY_ERRESC_1</name>
              <description>Start of Transmission Error on data lane 1 (no synchronization achieved).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRESC_0</name>
              <description>Start of Transmission Error on data lane 0 (no synchronization achieved).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRSOTHS_1</name>
              <description>Start of transmission error on data lane 1 (synchronization can still be achieved).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PHY_ERRSOTHS_0</name>
              <description>Start of transmission error on data lane 0 (synchronization can still be achieved).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PHY</name>
          <description>PHY Interrupt Mask Register</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_PHY_ERRESC_1</name>
              <description>Mask for PHY_ERRESC_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRESC_0</name>
              <description>Mask for PHY_ERRESC_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTHS_1</name>
              <description>Mask for PHY_ERRSOTHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTHS_0</name>
              <description>Mask for PHY_ERRSOTHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PHY</name>
          <description>PHY Interrupt Force Register</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_PHY_ERRESC_1</name>
              <description>Force PHY_ERRESC_1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRESC_0</name>
              <description>Force PHY_ERRESC_0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTHS_1</name>
              <description>Force PHY_ERRSOTHS_1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTHS_0</name>
              <description>Force PHY_ERRSOTHS_0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_LINE</name>
          <description>PHY Line Construction Interrupt Status Register</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_L_SEQ_DI3</name>
              <description>Error in the sequence of lines for VC3 and DT3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_SEQ_DI2</name>
              <description>Error in the sequence of lines for VC2 and DT2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_SEQ_DI1</name>
              <description>Error in the sequence of lines for VC1 and DT1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_SEQ_DI0</name>
              <description>Error in the sequence of lines for VC0 and DT0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI3</name>
              <description>Error matching line start with line end for VC3 and DT3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI2</name>
              <description>Error matching line start with line end for VC2 and DT2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI1</name>
              <description>Error matching line start with line end for VC1 and DT1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_L_BNDRY_MATCH_DI0</name>
              <description>Error matching line start with line end for VC0 and DT0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_LINE</name>
          <description>PHY Line Construction Interrupt Mask Register</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_ERR_L_SEQ_DI3</name>
              <description>Mask for ERR_L_SEQ_DI3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_SEQ_DI2</name>
              <description>Mask for ERR_L_SEQ_DI2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_SEQ_DI1</name>
              <description>Mask for ERR_L_SEQ_DI1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_SEQ_DI0</name>
              <description>Mask for ERR_L_SEQ_DI0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI3</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI2</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI1</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ERR_L_BNDRY_MATCH_DI0</name>
              <description>Mask for ERR_L_BNDRY_MATCH_DI0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_LINE</name>
          <description>PHY Line Construction Interrupt Force Register</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_L_SEQ_DI3</name>
              <description>Force ERR_L_SEQ_DI3.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_SEQ_DI2</name>
              <description>Force ERR_L_SEQ_DI2.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_SEQ_DI1</name>
              <description>Force ERR_L_SEQ_DI1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_SEQ_DI0</name>
              <description>Force ERR_L_SEQ_DI0.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI3</name>
              <description>Force ERR_L_BNDRY_MATCH_DI3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI2</name>
              <description>Force ERR_L_BNDRY_MATCH_DI2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI1</name>
              <description>Force ERR_L_BNDRY_MATCH_DI1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_L_BNDRY_MATCH_DI0</name>
              <description>Force ERR_L_BNDRY_MATCH_DI0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_IPI_FATAL</name>
          <description>IPI Interface Interrupt Status Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_EVENT_FIFO_OVERFLOW</name>
              <description>Reporting internal FIFO overflow.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_HLINE_ERR</name>
              <description>Horizontal line time error (only available in Controller timing mode).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>Controller timing mode: The FIFO of pixel interface is not empty at the start of a new frame. If this is expected this interrupt should be masked.
Camera timing mode: The FIFO of pixel interface is not empty at the start of a new frame. There are some scenarios where synchronization events of new frame can be lost on IPI interface.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FRAME_SYNC_ERR</name>
              <description>Whenever in Controller timing mode, notifies if a new frame is received but previous has not been completed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_OVERFLOW</name>
              <description>The FIFO of pixel interface has lost information because some data arrived and FIFO is already full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>The FIFO has become empty before the expected number of pixels (calculated from the packet header) could be extracted to the pixel interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_IPI_FATAL</name>
          <description>IPI Interface Interrupt Mask Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSK_INT_EVENT_FIFO_OVERFLOW</name>
              <description>Mask for INT_EVENT_FIFO_OVERFLOW.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_HLINE_ERR</name>
              <description>Mask for PIXEL_IF_HLINE_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>Mask for PIXEL_IF_FIFO_NEMPTY_FS.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_FRAME_SYNC_ERR</name>
              <description>Mask for PIXEL_IF_FRAME_SYNC_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_OVERFLOW</name>
              <description>Mask for PIXEL_IF_FIFO_OVERFLOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>Mask for PIXEL_IF_FIFO_UNDERFLOW.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_IPI_FATAL</name>
          <description>IPI Interface Interrupt Force Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_INT_EVENT_FIFO_OVERFLOW</name>
              <description>Force for INT_EVENT_FIFO_OVERFLOW.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_HLINE_ERR</name>
              <description>Force for PIXEL_IF_HLINE_ERR.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>Force for PIXEL_IF_FIFO_NEMPTY_FS.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_FRAME_SYNC_ERR</name>
              <description>Force for FRAME_SYNC_ERR.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_OVERFLOW</name>
              <description>Force for PIXEL_IF_FIFO_OVERFLOW.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>Force for PIXEL_IF_FIFO_UNDERFLOW.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_BNDRY_FRAME_FATAL</name>
          <description>Frame Boundary Error Interrupt Status Register</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC15</name>
              <description>Error matching Frame Start with Frame End for VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC14</name>
              <description>Error matching Frame Start with Frame End for VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC13</name>
              <description>Error matching Frame Start with Frame End for VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC12</name>
              <description>Error matching Frame Start with Frame End for VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC11</name>
              <description>Error matching Frame Start with Frame End for VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC10</name>
              <description>Error matching Frame Start with Frame End for VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC9</name>
              <description>Error matching Frame Start with Frame End for VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC8</name>
              <description>Error matching Frame Start with Frame End for VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC7</name>
              <description>Error matching Frame Start with Frame End for VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC6</name>
              <description>Error matching Frame Start with Frame End for VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC5</name>
              <description>Error matching Frame Start with Frame End for VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC4</name>
              <description>Error matching Frame Start with Frame End for VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC3</name>
              <description>Error matching Frame Start with Frame End for VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC2</name>
              <description>Error matching Frame Start with Frame End for VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC1</name>
              <description>Error matching Frame Start with Frame End for VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC0</name>
              <description>Error matching Frame Start with Frame End for VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_BNDRY_FRAME_FATAL</name>
          <description>Frame Boundary Error Interrupt Mask Register</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC15</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC14</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC13</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC12</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC11</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC10</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC9</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC8</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC7</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC6</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC5</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC4</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC3</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC2</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC1</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC0</name>
              <description>Mask for ERR_F_BNDRY_MATCH_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_BNDRY_FRAME_FATAL</name>
          <description>Frame Boundary Error Interrupt Force Register</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC15</name>
              <description>Force ERR_F_BNDRY_MATCH_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC14</name>
              <description>Force ERR_F_BNDRY_MATCH_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC13</name>
              <description>Force ERR_F_BNDRY_MATCH_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC12</name>
              <description>Force ERR_F_BNDRY_MATCH_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC11</name>
              <description>Force ERR_F_BNDRY_MATCH_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC10</name>
              <description>Force ERR_F_BNDRY_MATCH_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC9</name>
              <description>Force ERR_F_BNDRY_MATCH_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC8</name>
              <description>Force ERR_F_BNDRY_MATCH_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC7</name>
              <description>Force ERR_F_BNDRY_MATCH_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC6</name>
              <description>Force ERR_F_BNDRY_MATCH_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC5</name>
              <description>Force ERR_F_BNDRY_MATCH_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC4</name>
              <description>Force ERR_F_BNDRY_MATCH_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC3</name>
              <description>Force ERR_F_BNDRY_MATCH_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC2</name>
              <description>Force ERR_F_BNDRY_MATCH_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC1</name>
              <description>Force ERR_F_BNDRY_MATCH_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC0</name>
              <description>Force ERR_F_BNDRY_MATCH_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_SEQ_FRAME_FATAL</name>
          <description>Frame Sequence Error Interrupt Status Register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_SEQ_VC15</name>
              <description>Incorrect Frame sequence detected in VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC14</name>
              <description>Incorrect Frame sequence detected in VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC13</name>
              <description>Incorrect Frame sequence detected in VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC12</name>
              <description>Incorrect Frame sequence detected in VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC11</name>
              <description>Incorrect Frame sequence detected in VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC10</name>
              <description>Incorrect Frame sequence detected in VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC9</name>
              <description>Incorrect Frame sequence detected in VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC8</name>
              <description>Incorrect Frame sequence detected in VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC7</name>
              <description>Incorrect Frame sequence detected in VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC6</name>
              <description>Incorrect Frame sequence detected in VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC5</name>
              <description>Incorrect Frame sequence detected in VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC4</name>
              <description>Incorrect Frame sequence detected in VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC3</name>
              <description>Incorrect Frame sequence detected in VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC2</name>
              <description>Incorrect Frame sequence detected in VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC1</name>
              <description>Incorrect Frame sequence detected in VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC0</name>
              <description>Incorrect Frame sequence detected in VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_SEQ_FRAME_FATAL</name>
          <description>Frame Sequence Error Interrupt Mask Register</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_SEQ_VC15</name>
              <description>Mask for ERR_F_SEQ_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC14</name>
              <description>Mask for ERR_F_SEQ_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC13</name>
              <description>Mask for ERR_F_SEQ_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC12</name>
              <description>Mask for ERR_F_SEQ_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC11</name>
              <description>Mask for ERR_F_SEQ_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC10</name>
              <description>Mask for ERR_F_SEQ_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC9</name>
              <description>Mask for ERR_F_SEQ_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC8</name>
              <description>Mask for ERR_F_SEQ_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC7</name>
              <description>Mask for ERR_F_SEQ_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC6</name>
              <description>Mask for ERR_F_SEQ_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC5</name>
              <description>Mask for ERR_F_SEQ_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC4</name>
              <description>Mask for ERR_F_SEQ_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC3</name>
              <description>Mask for ERR_F_SEQ_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC2</name>
              <description>Mask for ERR_F_SEQ_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC1</name>
              <description>Mask for ERR_F_SEQ_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC0</name>
              <description>Mask for ERR_F_SEQ_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_SEQ_FRAME_FATAL</name>
          <description>Frame Sequence Error Interrupt Force Register</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_SEQ_VC15</name>
              <description>Force ERR_F_SEQ_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC14</name>
              <description>Force ERR_F_SEQ_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC13</name>
              <description>Force ERR_F_SEQ_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC12</name>
              <description>Force ERR_F_SEQ_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC11</name>
              <description>Force ERR_F_SEQ_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC10</name>
              <description>Force ERR_F_SEQ_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC9</name>
              <description>Force ERR_F_SEQ_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC8</name>
              <description>Force ERR_F_SEQ_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC7</name>
              <description>Force ERR_F_SEQ_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC6</name>
              <description>Force ERR_F_SEQ_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC5</name>
              <description>Force ERR_F_SEQ_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC4</name>
              <description>Force ERR_F_SEQ_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC3</name>
              <description>Force ERR_F_SEQ_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC2</name>
              <description>Force ERR_F_SEQ_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC1</name>
              <description>Force ERR_F_SEQ_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_F_SEQ_VC0</name>
              <description>Force ERR_F_SEQ_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_CRC_FRAME_FATAL</name>
          <description>Frame CRC Error Interrupt Status Register</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_FRAME_DATA_VC15</name>
              <description>Last received Frame in VC15, had at least one CRC error.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC14</name>
              <description>Last received Frame in VC14, had at least one CRC error.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC13</name>
              <description>Last received Frame in VC13, had at least one CRC error.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC12</name>
              <description>Last received Frame in VC12, had at least one CRC error.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC11</name>
              <description>Last received Frame in VC11, had at least one CRC error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC10</name>
              <description>Last received Frame in VC10, had at least one CRC error.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC9</name>
              <description>Last received Frame in VC9, had at least one CRC error.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC8</name>
              <description>Last received Frame in VC8, had at least one CRC error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC7</name>
              <description>Last received Frame in VC7, had at least one CRC error.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC6</name>
              <description>Last received Frame in VC6, had at least one CRC error.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC5</name>
              <description>Last received Frame in VC5, had at least one CRC error.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC4</name>
              <description>Last received Frame in VC4, had at least one CRC error.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC3</name>
              <description>Last received Frame in VC3, had at least one CRC error.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC2</name>
              <description>Last received Frame in VC2, had at least one CRC error.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC1</name>
              <description>Last received Frame in VC1, had at least one CRC error.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC0</name>
              <description>Last received Frame in VC0, had at least one CRC error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_CRC_FRAME_FATAL</name>
          <description>Frame CRC Error Interrupt Mask Register</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_FRAME_DATA_VC15</name>
              <description>Mask for ERR_FRAME_DATA_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC14</name>
              <description>Mask for ERR_FRAME_DATA_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC13</name>
              <description>Mask for ERR_FRAME_DATA_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC12</name>
              <description>Mask for ERR_FRAME_DATA_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC11</name>
              <description>Mask for ERR_FRAME_DATA_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC10</name>
              <description>Mask for ERR_FRAME_DATA_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC9</name>
              <description>Mask for ERR_FRAME_DATA_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC8</name>
              <description>Mask for ERR_FRAME_DATA_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC7</name>
              <description>Mask for ERR_FRAME_DATA_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC6</name>
              <description>Mask for ERR_FRAME_DATA_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC5</name>
              <description>Mask for ERR_FRAME_DATA_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC4</name>
              <description>Mask for ERR_FRAME_DATA_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC3</name>
              <description>Mask for ERR_FRAME_DATA_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC2</name>
              <description>Mask for ERR_FRAME_DATA_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC1</name>
              <description>Mask for ERR_FRAME_DATA_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC0</name>
              <description>Mask for ERR_FRAME_DATA_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_CRC_FRAME_FATAL</name>
          <description>Frame CRC Error Interrupt Force Register</description>
          <addressOffset>0x2A8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_FRAME_DATA_VC15</name>
              <description>Force ERR_FRAME_DATA_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC14</name>
              <description>Force ERR_FRAME_DATA_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC13</name>
              <description>Force ERR_FRAME_DATA_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC12</name>
              <description>Force ERR_FRAME_DATA_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC11</name>
              <description>Force ERR_FRAME_DATA_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC10</name>
              <description>Force ERR_FRAME_DATA_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC9</name>
              <description>Force ERR_FRAME_DATA_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC8</name>
              <description>Force ERR_FRAME_DATA_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC7</name>
              <description>Force ERR_FRAME_DATA_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC6</name>
              <description>Force ERR_FRAME_DATA_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC5</name>
              <description>Force ERR_FRAME_DATA_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC4</name>
              <description>Force ERR_FRAME_DATA_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC3</name>
              <description>Force ERR_FRAME_DATA_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC2</name>
              <description>Force ERR_FRAME_DATA_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC1</name>
              <description>Force ERR_FRAME_DATA_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_FRAME_DATA_VC0</name>
              <description>Force ERR_FRAME_DATA_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_PLD_CRC_FATAL</name>
          <description>Frame Payload Error Interrupt Status Register</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_CRC_VC15</name>
              <description>Payload Checksum error detected on VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC14</name>
              <description>Payload Checksum error detected on VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC13</name>
              <description>Payload Checksum error detected on VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC12</name>
              <description>Payload Checksum error detected on VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC11</name>
              <description>Payload Checksum error detected on VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC10</name>
              <description>Payload Checksum error detected on VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC9</name>
              <description>Payload Checksum error detected on VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC8</name>
              <description>Payload Checksum error detected on VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC7</name>
              <description>Payload Checksum error detected on VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC6</name>
              <description>Payload Checksum error detected on VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC5</name>
              <description>Payload Checksum error detected on VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC4</name>
              <description>Payload Checksum error detected on VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC3</name>
              <description>Payload Checksum error detected on VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC2</name>
              <description>Payload Checksum error detected on VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC1</name>
              <description>Payload Checksum error detected on VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC0</name>
              <description>Payload Checksum error detected on VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_PLD_CRC_FATAL</name>
          <description>Frame Payload Error Interrupt Mask Register</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_CRC_VC15</name>
              <description>Mask for ERR_CRC_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC14</name>
              <description>Mask for ERR_CRC_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC13</name>
              <description>Mask for ERR_CRC_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC12</name>
              <description>Mask for ERR_CRC_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC11</name>
              <description>Mask for ERR_CRC_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC10</name>
              <description>Mask for ERR_CRC_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC9</name>
              <description>Mask for ERR_CRC_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC8</name>
              <description>Mask for ERR_CRC_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC7</name>
              <description>Mask for ERR_CRC_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC6</name>
              <description>Mask for ERR_CRC_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC5</name>
              <description>Mask for ERR_CRC_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC4</name>
              <description>Mask for ERR_CRC_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC3</name>
              <description>Mask for ERR_CRC_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC2</name>
              <description>Mask for ERR_CRC_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC1</name>
              <description>Mask for ERR_CRC_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC0</name>
              <description>Mask for ERR_CRC_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_PLD_CRC_FATAL</name>
          <description>Frame Payload Error Interrupt Force Register</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_CRC_VC15</name>
              <description>Force ERR_CRC_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC14</name>
              <description>Force ERR_CRC_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC13</name>
              <description>Force ERR_CRC_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC12</name>
              <description>Force ERR_CRC_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC11</name>
              <description>Force ERR_CRC_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC10</name>
              <description>Force ERR_CRC_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC9</name>
              <description>Force ERR_CRC_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC8</name>
              <description>Force ERR_CRC_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC7</name>
              <description>Force ERR_CRC_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC6</name>
              <description>Force ERR_CRC_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC5</name>
              <description>Force ERR_CRC_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC4</name>
              <description>Force ERR_CRC_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC3</name>
              <description>Force ERR_CRC_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC2</name>
              <description>Force ERR_CRC_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC1</name>
              <description>Force ERR_CRC_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_CRC_VC0</name>
              <description>Force ERR_CRC_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_DATA_ID</name>
          <description>DT Error Interrupt Status Register</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ID_VC15</name>
              <description>Unrecognized or unimplemented data type detected in VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC14</name>
              <description>Unrecognized or unimplemented data type detected in VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC13</name>
              <description>Unrecognized or unimplemented data type detected in VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC12</name>
              <description>Unrecognized or unimplemented data type detected in VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC11</name>
              <description>Unrecognized or unimplemented data type detected in VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC10</name>
              <description>Unrecognized or unimplemented data type detected in VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC9</name>
              <description>Unrecognized or unimplemented data type detected in VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC8</name>
              <description>Unrecognized or unimplemented data type detected in VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC7</name>
              <description>Unrecognized or unimplemented data type detected in VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC6</name>
              <description>Unrecognized or unimplemented data type detected in VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC5</name>
              <description>Unrecognized or unimplemented data type detected in VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC4</name>
              <description>Unrecognized or unimplemented data type detected in VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC3</name>
              <description>Unrecognized or unimplemented data type detected in VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC2</name>
              <description>Unrecognized or unimplemented data type detected in VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC1</name>
              <description>Unrecognized or unimplemented data type detected in VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC0</name>
              <description>Unrecognized or unimplemented data type detected in VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_DATA_ID</name>
          <description>DT Error Interrupt Mask Register</description>
          <addressOffset>0x2C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ID_VC15</name>
              <description>Mask for ERR_ID_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC14</name>
              <description>Mask for ERR_ID_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC13</name>
              <description>Mask for ERR_ID_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC12</name>
              <description>Mask for ERR_ID_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC11</name>
              <description>Mask for ERR_ID_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC10</name>
              <description>Mask for ERR_ID_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC9</name>
              <description>Mask for ERR_ID_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC8</name>
              <description>Mask for ERR_ID_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC7</name>
              <description>Mask for ERR_ID_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC6</name>
              <description>Mask for ERR_ID_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC5</name>
              <description>Mask for ERR_ID_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC4</name>
              <description>Mask for ERR_ID_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC3</name>
              <description>Mask for ERR_ID_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC2</name>
              <description>Mask for ERR_ID_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC1</name>
              <description>Mask for ERR_ID_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC0</name>
              <description>Mask for ERR_ID_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_DATA_ID</name>
          <description>DT Error Interrupt Force Register</description>
          <addressOffset>0x2C8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ID_VC15</name>
              <description>Force ERR_ID_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC14</name>
              <description>Force ERR_ID_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC13</name>
              <description>Force ERR_ID_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC12</name>
              <description>Force ERR_ID_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC11</name>
              <description>Force ERR_ID_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC10</name>
              <description>Force ERR_ID_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC9</name>
              <description>Force ERR_ID_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC8</name>
              <description>Force ERR_ID_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC7</name>
              <description>Force ERR_ID_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC6</name>
              <description>Force ERR_ID_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC5</name>
              <description>Force ERR_ID_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC4</name>
              <description>Force ERR_ID_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC3</name>
              <description>Force ERR_ID_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC2</name>
              <description>Force ERR_ID_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC1</name>
              <description>Force ERR_ID_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ID_VC0</name>
              <description>Force ERR_ID_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_ST_ECC_CORRECT</name>
          <description>ECC Interrupt Status Register</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_CORRECTED_VC15</name>
              <description>D-PHY mode: Header error detected and corrected on VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC14</name>
              <description>D-PHY mode: Header error detected and corrected on VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC13</name>
              <description>D-PHY mode: Header error detected and corrected on VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC12</name>
              <description>D-PHY mode: Header error detected and corrected on VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC11</name>
              <description>D-PHY mode: Header error detected and corrected on VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC10</name>
              <description>D-PHY mode: Header error detected and corrected on VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC9</name>
              <description>D-PHY mode: Header error detected and corrected on VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC8</name>
              <description>D-PHY mode: Header error detected and corrected on VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC7</name>
              <description>D-PHY mode: Header error detected and corrected on VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC6</name>
              <description>D-PHY mode: Header error detected and corrected on VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC5</name>
              <description>D-PHY mode: Header error detected and corrected on VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC4</name>
              <description>D-PHY mode: Header error detected and corrected on VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC3</name>
              <description>D-PHY mode: Header error detected and corrected on VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC2</name>
              <description>D-PHY mode: Header error detected and corrected on VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC1</name>
              <description>D-PHY mode: Header error detected and corrected on VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC0</name>
              <description>D-PHY mode: Header error detected and corrected on VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_MSK_ECC_CORRECT</name>
          <description>ECC Interrupt Mask Register</description>
          <addressOffset>0x2D4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_CORRECTED_VC15</name>
              <description>Mask for ERR_ECC_CORRECTED_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC14</name>
              <description>Mask for ERR_ECC_CORRECTED_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC13</name>
              <description>Mask for ERR_ECC_CORRECTED_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC12</name>
              <description>Mask for ERR_ECC_CORRECTED_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC11</name>
              <description>Mask for ERR_ECC_CORRECTED_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC10</name>
              <description>Mask for ERR_ECC_CORRECTED_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC9</name>
              <description>Mask for ERR_ECC_CORRECTED_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC8</name>
              <description>Mask for ERR_ECC_CORRECTED_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC7</name>
              <description>Mask for ERR_ECC_CORRECTED_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC6</name>
              <description>Mask for ERR_ECC_CORRECTED_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC5</name>
              <description>Mask for ERR_ECC_CORRECTED_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC4</name>
              <description>Mask for ERR_ECC_CORRECTED_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC3</name>
              <description>Mask for ERR_ECC_CORRECTED_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC2</name>
              <description>Mask for ERR_ECC_CORRECTED_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC1</name>
              <description>Mask for ERR_ECC_CORRECTED_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC0</name>
              <description>Mask for ERR_ECC_CORRECTED_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_INT_FORCE_ECC_CORRECT</name>
          <description>ECC Interrupt Force Register</description>
          <addressOffset>0x2D8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_CORRECTED_VC15</name>
              <description>Force ERR_ECC_CORRECTED_VC15.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC14</name>
              <description>Force ERR_ECC_CORRECTED_VC14.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC13</name>
              <description>Force ERR_ECC_CORRECTED_VC13.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC12</name>
              <description>Force ERR_ECC_CORRECTED_VC12.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC11</name>
              <description>Force ERR_ECC_CORRECTED_VC11.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC10</name>
              <description>Force ERR_ECC_CORRECTED_VC10.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC9</name>
              <description>Force ERR_ECC_CORRECTED_VC9.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC8</name>
              <description>Force ERR_ECC_CORRECTED_VC8.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC7</name>
              <description>Force ERR_ECC_CORRECTED_VC7.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC6</name>
              <description>Force ERR_ECC_CORRECTED_VC6.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC5</name>
              <description>Force ERR_ECC_CORRECTED_VC5.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC4</name>
              <description>Force ERR_ECC_CORRECTED_VC4.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC3</name>
              <description>Force ERR_ECC_CORRECTED_VC3.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC2</name>
              <description>Force ERR_ECC_CORRECTED_VC2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC1</name>
              <description>Force ERR_ECC_CORRECTED_VC1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
            <field>
              <name>ERR_ECC_CORRECTED_VC0</name>
              <description>Force ERR_ECC_CORRECTED_VC0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <readAction>clear</readAction>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_SCRAMBLING</name>
          <description>Descrambling Control Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRAMBLE_ENABLE</name>
              <description>Enables data descrambling on the CSI controller side.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_SCRAMBLING_SEED1</name>
          <description>Descrambling Seed Configuration Lane 0 Register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001008</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRAMBLE_SEED_LANE1</name>
              <description>Seed used by descrambler block for lane 1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_SCRAMBLING_SEED2</name>
          <description>Descrambling Seed Configuration Lane 1 Register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001188</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRAMBLE_SEED_LANE2</name>
              <description>Seed used by descrambler block for lane 2.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I3C</name>
      <baseAddress>0x49034000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>548</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>I3C_IRQ</name>
        <description>I3C interrupt request</description>
        <value>136</value>
      </interrupt>
      <registers>
        <register>
          <name>I3C_DEVICE_CTRL</name>
          <description>Device Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Controls whether or not I3C is enabled.
In Master mode of operation, software can disable I3C while it is active. However, the controller may not get disabled immediately and it is disabled after commands in the Command queue are executed leading to a STOP condition on the bus and Master FSM is in IDLE state (as indicated by I3C_PRESENT_STATE register).
In Slave mode of operation, software can disable I3C while it is active. However, the disable happens after the ongoing transfer is completed on the I3C bus. Software can read back 0x0 from this bit once disabling of I3C is completed. After POR, the I3C slave controller is enabled by programming this bit to 0x1. However, the I3C bus interface of the controller, responds to transfer on the bus only after it observes Bus Available condition for BUS_AVAILABLE_TIME x IDLE_CNT_MULTPLIER counts of PCLK period. The successful completion of enable/disable of the controller depends on availability of SCL to the controller at the time of performing this operation, and hence may not happen instantly.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables the I3C controller</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the I3C controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESUME</name>
              <description>This bit is used to resume the controller after it goes to the HALT state.
In the Master mode of operation, the controller goes to the HALT state (as indicated in I3C_PRESENT_STATE[CM_TFR_ST_STS] field) due to any type of error in the transfer. The error type is specified in the response packet available in I3C_RESPONSE_QUEUE_PORT[RESPONSE] as per the value in ERR_STATUS field .
After the controller gones to the HALT state, the application has to write 0x1 to this bit to resume the controller. This bit is auto-cleared once the controller resumes the transfers by initiating the next command.
In the Slave mode of operation, the controller goes to the HALT state due to following conditions:
- Any type of error in the transfer
 - I3C_SLV_MAX_LEN[MRL] field updated by the master through SETMRL CCC.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>This bit is used in Master mode of operation and allows the controller to relinquish the I3C bus before completing the issued transfer.
In response to an ABORT request, the controller issues the STOP condition after the complete data byte is transferred or received.
This bit is auto-cleared once the transfer is aborted and the controller issues a I3C_INTR_STATUS[TRANSFER_ABORT_STS] bit.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_ENABLE</name>
              <description>This bit is used to enable or disable the DMA handshaking interface, and is applicable to both Master and Slave modes of operation.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The DMA handshake control has no significance.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables the DMA handshake control to interact with external DMA.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADAPTIVE_I2C_I3C</name>
              <description>This field is used in Slave mode of operation. 
Note: When I2C mode strap is driven to 0x0, the slave controller operates in Adaptive mode. Setting of this bit is NOT required to put the controller in Adaptive mode. It is only used to enable some features of the slave controller to adapt to Adaptive I2C/I3C mode of operation. This bit is cleared automatically if the controller determines the mode as I3C. 
Effect on Hot-Join: 
- If this bit is programmed to 0x1, the controller initiates a Hot-Join request only after it has switched to I3C mode of operation. 
- If this bit is not set, the controller initiates a Hot-Join without determining the bus mode assuming itself to be on I3C bus. 
- This bit should be set only if the slave application does not know to which bus the device is connected to.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_CNT_MULTPLIER</name>
              <description>This bit is used in Slave mode of operation.
 After POR, the slave controller is enabled only after it sees both SDA and SCL lines IDLE for a specified time. This IDLE time is calculated by multipliying IDLE_CNT_MULITPLIER with the I3C_BUS_FREE_AVAIL_TIMING[BUS_AVAILABLE_TIME] field.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>BUS_AVAILABLE_TIME x 1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>BUS_AVAILABLE_TIME x 2</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>BUS_AVAILABLE_TIME x 4</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>BUS_AVAILABLE_TIME x 8</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOT_JOIN_CTRL</name>
              <description>This bit is used in Master mode of operation.
This bit acts as a global control to ACK/NACK the Hot-Join request from the devices. The I3C Master ACK/NACKs the Hot-Join request from other devices connected on the I3C bus, based on programming of this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK Hot-Join requests</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>NACK and send broadcast CCC to disable Hot-Join</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2C_SLAVE_PRESENT</name>
              <description>This bit is used in Master mode of operation.
This bit indicates whether any legacy I2C devices are present in the system.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I2C Slave not present</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I2C Slave present</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBA_INCLUDE</name>
              <description>This bit is used in Master mode of operation.
This bit is used to include I3C Broadcast address (0x7E) for private transfer.
If I3C Broadcast address is not included for the private transfers, In-Band Interrupts (IBI) driven from slaves might not win address arbitration. Hence, the IBIs get delayed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I3C Broadcast address is not included for Private Transfers</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I3C Broadcast address is included for Private Transfers</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEVICE_ADDR</name>
          <description>Device Address Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DYNAMIC_ADDR_VALID</name>
              <description>This bit is used to control whether the Dynamic address is valid or not.
In I3C Main Master mode, set this bit to 0x1 as it self-assigns its Dynamic address.
In all other operation modes, the controller sets this bit to 0x1 when Main Master assigns the Dynamic address during ENTDAA or SETDASA mechanism.
In I3C Slave mode the controller sets this bit to 0x1 when Main Master assigns the Dynamic address during ENTDAA or SETDASA mechanism.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Dynamic address is invalid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dynamic address is valid</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DYNAMIC_ADDR</name>
              <description>Device Dynamic Address.
This field is used to program the device Dynamic address. The controller uses this address for I3C transfers.
In Main Master mode, the application has to program the Dynamic address through the slave interface as it self-assigns its Dynamic address.
In all other modes, the Main Master assigns this address during ENTDAA or SETDASA mechanism.</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STATIC_ADDR_VALID</name>
              <description>In Slave mode of operation this bit reflects the value of static address input port. The input port Static address is expected to be driven to 0x1 only if the device supports I2C or I3C Static address.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Static address is invalid</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Static address is valid</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STATIC_ADDR</name>
              <description>Device Static Address.
In Slave mode of operation this field reflects the value of Static address input port. The controller uses this address to respond to SETDASA CCC command to get the Dynamic address if Static address is valid.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_HW_CAPABILITY</name>
          <description>Hardware Capability Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000E00AB</resetValue>
          <resetMask>0xFFFE07FF</resetMask>
          <fields>
            <field>
              <name>SLV_IBI_CAP</name>
              <description>The value of this bit defines the slave's capability to initiate slave interrupt requests.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_HJ_CAP</name>
              <description>The value of this bit defines the slave's capability to initiate Hot-Join request.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>The value of this bit defines whether the I3C is configured to have DMA handshaking interface.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLOCK_PERIOD</name>
              <description>The value of this field defines the minimum period of CORE_CLK, that is, the maximum frequency of CORE_CLK that is intended to be fed to I3C.</description>
              <bitRange>[10:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HDR_TS_EN</name>
              <description>The value of this bit defines the I3C capability to perform HDR-TS transfers.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>HDR-TS not supported</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HDR_DDR_EN</name>
              <description>The value of this bit defines the I3C capability to perform HDR-DDR transfers.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>HDR-DDR supported</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEVICE_ROLE_CONFIG</name>
              <description>The value of field bit defines the configured role of I3C.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Secondary Master</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_COMMAND_QUEUE_PORT</name>
          <description>Command Queue Port Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COMMAND</name>
              <description>32 bit command</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_RESPONSE_QUEUE_PORT</name>
          <description>Response Queue Port Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE</name>
              <description>32 bit response</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_RX_DATA_PORT</name>
          <description>Receive Data Port Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_DATA_PORT</name>
              <description>Receive Data Port
The receive data port is mapped to the Rx data buffer.
The receive data is always packed in 4-byte aligned data words and stored in the Rx data buffer. If the command length is not aligned to the 4-bytes, then the additional data bytes have to be ignored.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_TX_DATA_PORT</name>
          <description>Transmit Data Port Register</description>
          <alternateRegister>I3C_RX_DATA_PORT</alternateRegister>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DATA_PORT</name>
              <description>The transmit data port is mapped to the Tx data buffer.
The transmit data should always be packed as 4-byte aligned data words and written to this field. If the command length is not aligned to 4-bytes, then the additional bytes are ignored.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_QUEUE_DATA</name>
          <description>In-Band Interrupt Queue Data Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_DATA</name>
              <description>In-Band Interrupt Data
This field is mapped to the IBI queue. The IBI data is always packed in 4-byte aligned and put to the IBI queue. If the incoming data is not aligned to the 4-bytes, then there are unused bytes in the end location of the IBI transfer.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_QUEUE_STATUS</name>
          <description>In-Band Interrupt Queue Status Register</description>
          <alternateRegister>I3C_IBI_QUEUE_DATA</alternateRegister>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_STS</name>
              <description>IBI Received Status
Defines the master response for IBI received.
Others: Reserved</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Responded with ACK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Responded with NACK</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBI_ID</name>
              <description>IBI Identifier
- The byte received after START which includes the address and the R/W bit.
- Device address and R/W bit in case of slave interrupt or master request.
- Hot-Join ID and R/W bit in case of Hot-Join IBI.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_LENGTH</name>
              <description>In-Band Interrupt Data Length
This field represents the length of data received along with the IBI, in bytes.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_QUEUE_THLD_CTRL</name>
          <description>Queue Threshold Control Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_STATUS_THLD</name>
              <description>In-Band Interrupt Status Threshold Value
Every IBI without payload received by I3C generates an IBI status. This field controls the number of IBI status entries in the IBI queue.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_BUF_THLD</name>
              <description>Response Buffer Threshold Value
Controls the number of entries in the response queue.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_EMPTY_BUF_THLD</name>
              <description>Command Buffer Empty Threshold Value
Controls the number of empty locations in the command queue.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DATA_BUFFER_THLD_CTRL</name>
          <description>Data Buffer Threshold Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01010101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_START_THLD</name>
              <description>Receive Start Threshold Value
In Master mode of operation when the I3C is set up to initiate a read transfer, it waits until either one of the conditions are met before it initiates the read transfer on the I^3C interface.
- Data length (as specified in the command) number of locations are empty in the Rx FIFO.
- Threshold number of locations (or more) are empty in the Rx FIFO.
In Slave mode of operation the slave I3C ACKs a write request from master only if threshold number of empty locations (or more) are available in its receive buffer.
The supported values for this field are:</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>64</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_START_THLD</name>
              <description>Transfer Start Threshold Value
In Master mode of operation when the I3C is set up to initiate a write transfer, it waits until either one of the following conditions are met before it initiates the write transfer on the I3C Interface:
- Data length (as specified in the command) number of locations are filled in the Tx FIFO
- Threshold number of entries (or more) are available in the Tx FIFO
In Slave mode of operation the slave controller ACKs a read request from master only if either one of the following conditions are met:
- Data length (as specified in the command) number of locations are filled in the Tx FIFO
- Threshold number of entries (or more) are available in the Tx FIFO
The supported values for this field are:</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>64</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_BUF_THLD</name>
              <description>Receive Buffer Threshold Value
This field controls the number of entries (or above) in the Rx FIFO.
The supported values for this field are:</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>64</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_EMPTY_BUF_THLD</name>
              <description>Transmit Buffer Threshold Value
This field controls the number of empty locations (or above) in the Tx FIFO.
The supported values for this field are:</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0b000</name>
                  <description>1</description>
                  <value>0b000</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b001</name>
                  <description>4</description>
                  <value>0b001</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b010</name>
                  <description>8</description>
                  <value>0b010</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b011</name>
                  <description>16</description>
                  <value>0b011</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b100</name>
                  <description>32</description>
                  <value>0b100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0b101</name>
                  <description>64</description>
                  <value>0b101</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_QUEUE_CTRL</name>
          <description>IBI Queue Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOTIFY_SIR_REJECTED</name>
              <description>Notify Rejected Slave Interrupt Request Control
This bit is used to suppress reporting to the application about SIR request rejected.
0x0: Suppress passing the IBI status to the IBI FIFO when a slave interrupt request is NACKed and auto-disabled based on the I3C_IBI_SIR_REQ_REJECT register.
0x1: Writes IBI status to the IBI FIFO when a slave interrupt request is NACKed and auto-disabled based on the I3C_IBI_SIR_REQ_REJECT register.
0x0: Notify SIR rejected disable
0x1: Notify SIR rejected enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOTIFY_MR_REJECTED</name>
              <description>Notify Rejected Master Request Control
This bit is used to suppress reporting to the application about master request rejected.
0x0: Suppress passing the IBI status to the IBI FIFO when a MR request is NACKed and auto-disabled based on the I3C_IBI_MR_REQ_REJECT register.
0x1: Writes IBI status to the IBI FIFO when a MR request is NACKed and auto-disabled based on the I3C_IBI_MR_REQ_REJECT register.
0x0: Notify MR rejected disable
0x1: Notify MR rejected enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOTIFY_HJ_REJECTED</name>
              <description>Notify Rejected Hot-Join Control
This bit is used to suppress reporting to the application about Hot-Join request rejected.
0x0: Suppress passing the IBI status to the IBI FIFO when a Hot-Join request is NACKed and auto-disabled based on the I3C_DEVICE_CTRL[HOT_JOIN_CTRL] bit.
0x1: Writes IBI status to the IBI FIFO when a Hot-Join request is NACKed and auto-disabled based on the I3C_DEVICE_CTRL[HOT_JOIN_CTRL] bit.
0x0: Notify Hot-Join rejected disable
0x1: Notify Hot-Join rejected enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_MR_REQ_REJECT</name>
          <description>IBI MR Request Rejection Control Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MR_REQ_REJECT</name>
              <description>The control bits of this field determines if the controller ACKs incoming master requestor NACKs and disables it.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK Master Request</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>NACK and send Directed DISEC CCC to disable the interrupting slave</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_IBI_SIR_REQ_REJECT</name>
          <description>IBI SIR Request Rejection Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIR_REQ_REJECT</name>
              <description>The application of the I3C can decide whether to send ACK or NACK for a slave interrupt request received from any I3C device.
A device-specific response control bit is provided to select the response option. Master ACKs/NACKs the SIR based on programming of control bit, corresponding to the interrupting device.
0x1 NACK and send directed auto disable CCC</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK the SIR request</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_RESET_CTRL</name>
          <description>Reset Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET</name>
              <description>Bus Reset
This bit is only used in Master mode of operation.
This bit is cleared automatically once the bus reset pattern generation is completed.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> To exercise bus reset pattern generation based on BUS_RESET_TYPE field.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUS_RESET_TYPE</name>
              <description>Bus Reset Type
Type of bus reset triggered by BUS_RESET bit.
Others: Reserved</description>
              <bitRange>[30:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Exit pattern</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SCL low reset pattern</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IBI_QUEUE_RST</name>
              <description>IBI Queue Software Reset
This bit is only used in Master mode of operation.
This bit is cleared automatically once the IBI queue reset is completed.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> To exercise IBI queue reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_FIFO_RST</name>
              <description>Receive Buffer Software Reset
This bit is cleared automatically once the Rx buffer reset is completed.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> To exercise Rx buffer reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_FIFO_RST</name>
              <description>Transmit Buffer Software Reset
This bit is cleared automatically once the Tx buffer reset is completed.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> To exercise Tx buffer reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_QUEUE_RST</name>
              <description>Response Queue Software Reset
This bit is cleared automatically once the response queue reset is complete.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> To exercise response queue reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_QUEUE_RST</name>
              <description>Command Queue Software Reset
This bit is cleared automatically once the command queue reset is complete.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> To exercise command queue reset</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SOFT_RST</name>
              <description>Core Software Reset.
This bit is cleared automatically once the core reset is complete.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> To exercise core reset. This bit resets all buffers-receive, transmit, command, and response</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_EVENT_STATUS</name>
          <description>Slave Event Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MWL_UPDATED</name>
              <description>This bit indicates a SETMWL CCC is received by the slave. The updated MWL value can be read from I3C_SLV_MAX_LEN[MWL]. This status can be cleared by writing 0x1 to this bit after reading the updated MWL.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>MRL_UPDATED</name>
              <description>This bit indicates a SETMRL CCC is received by the slave. The updated MRL value can be read from I3C_SLV_MAX_LEN[MWL]. This status can be cleared by writing 0x1 to this bit after reading the updated MRL.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ACTIVITY_STATE</name>
              <description>Activity State Status</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description> ENTAS0</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> ENTAS1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description> ENTAS2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description> ENTAS3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HJ_EN</name>
              <description>Hot-Join Interrupt Enable
This bit reflects whether the Hot-Join request interrupts are allowed on the I3C bus or not.
 The Slave can choose to disable Hot-Join capability of the slave I3C by setting this bit to 0x0 before enabling the I3C. When done so, the slave does not initiate Hot-Join and takes part in address assignment without initiating Hot-Join. 
If this field is not set to 0x0 by slave, it can be set or cleared by the I3C master through ENEC or DISEC CCC. Once disabled, CCC do not have any effect on this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MR_EN</name>
              <description>Master Request Enable
In Slave mode of operation, this bit reflects whether the I3C can initiate the master request on the I3C bus or not.
This bit is set or cleared by the I3C master through ENEC or DISEC CCC.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SIR_EN</name>
              <description>Slave Interrupt Request Enable
In Slave mode of operation, this bit reflects whether the controller can initiate the SIR on the I3C bus or not.
This bit is set or cleared by the I3C master through ENEC or DISEC CCC.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_STATUS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_STS</name>
              <description>Bus Reset Pattern Generation Done Status
This bit is used only in Master mode of operation.
 The interrupt is generated when the SCL Low Timeout Bus Reset Pattern Generation is completed.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_STS</name>
              <description>This interrupt is set when the role of the I3C changes from being a Master to Slave or the opposite.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>IBI_UPDATED_STS</name>
              <description>This bit is used only in Slave mode of operation.
It indicates that the IBI request initiated through SIR request register is addressed and status is updated.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>READ_REQ_RECV_STS</name>
              <description>This bit is used only in Slave mode of operation.
 Read request received from the current master when CMDQ is empty. 
This bit can be cleared by writing 0x1.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DEFSLV_STS</name>
              <description>Define Slave CCC Received Status
The interrupt is generated if DEFSLV CCC is received.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TRANSFER_ERR_STS</name>
              <description>Transfer Error Status
 The interrupt is generated if any error occurs during transfer. The error type is specified in the response packet associated with the command in ERR_STATUS field. The error type is specified in the response packet available in I3C_RESPONSE_QUEUE_PORT[RESPONSE] as per the value in ERR_STATUS field .
This bit can be cleared by writing 0x1.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_STS</name>
              <description>Dynamic Address Assigned Status
This bit is used only in Slave mode of operation.
 The interrupt is generated if the device Dynamic address is assigned through SETDASA or ENTDAA CCC.
This bit can be cleared by writing 0x1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>CCC_UPDATED_STS</name>
              <description>CCC Table Updated Status
This bit is used only in Slave mode of operation.
 The interrupt is generated if any of the CCC registers are updated by I3C master through CCC commands.
This interrupt can be cleared by writing 0x1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>TRANSFER_ABORT_STS</name>
              <description>Transfer Abort Status
This bit is used only in Master mode of operation.
 The interrupt is generated if transfer is aborted. 
This interrupt can be cleared by writing 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>RESP_READY_STS</name>
              <description>Response Queue Ready Status
 The interrupt is generated when number of entries in response queue is greater than or equal to threshold value specified in I3C_QUEUE_THLD_CTRL[RESP_BUF_THLD] field. 
This bit is cleared automatically when number of entries in response buffer is less than specified threshold value.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_STS</name>
              <description>Command Queue Ready
 The interrupt is generated when number of empty locations in command queue is greater than or equal to threshold value specified in I3C_QUEUE_THLD_CTRL[CMD_EMPTY_BUF_THLD] field. 
This bit is cleared automatically when number of empty locations in command buffer is less than specified threshold value.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IBI_THLD_STS</name>
              <description>IBI Buffer Threshold Status
 This bit is only used in Master mode of operation.
The interrupt is generated when number of entries in IBI buffer is greater than or equal to threshold value specified in I3C_QUEUE_THLD_CTRL[IBI_BUF_THLD] field. 
This bit is cleared automatically when number of entries in IBI buffer is less than specified threshold value.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_THLD_STS</name>
              <description>Receive Buffer Threshold Status
 The interrupt is generated when number of entries in receive buffer is greater than or equal to threshold value specified in I3C_DATA_BUFFER_THLD_CTRL[RX_BUF_THLD] field. 
This bit is cleared automatically when number of entries in receive buffer is less than specified threshold value.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_THLD_STS</name>
              <description>Transmit Buffer Threshold Status
 The interrupt is generated when the number of empty locations in transmit buffer is greater than or equal to threshold value specified in I3C_DATA_BUFFER_THLD_CTRL[TX_EMPTY_BUF_THLD] field. 
This bit is cleared automatically when number of empty locations in transmit buffer is less than specified threshold value.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_STATUS_EN</name>
          <description>Interrupt Status Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_STS_EN</name>
              <description>Bus Reset Pattern Generation Done Status Enable
This bit is used only in Master mode of operation.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_STS_EN</name>
              <description>Bus Owner Updated Status Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_UPDATED_STS_EN</name>
              <description>IBI Updated Status Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_REQ_RECV_STS_EN</name>
              <description>Read Request Received Status Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEFSLV_STS_EN</name>
              <description>Define Slave CCC Received Status Enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ERR_STS_EN</name>
              <description>Transfer Error Status Enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_STS_EN</name>
              <description>Dynamic Address Assigned Status Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCC_UPDATED_STS_EN</name>
              <description>CCC Table Updated Status Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ABORT_STS_EN</name>
              <description>Transfer Abort Status Enable
This bit is used only in Master mode of operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_READY_STS_EN</name>
              <description>Response Queue Ready Status Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_STS_EN</name>
              <description>Command Queue Ready Status Enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_THLD_STS_EN</name>
              <description>IBI Buffer Threshold Status Enable
This bit is used only in Master mode of operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THLD_STS_EN</name>
              <description>Receive Buffer Threshold Status Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THLD_STS_EN</name>
              <description>Transmit Buffer Threshold Status Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_SIGNAL_EN</name>
          <description>Interrupt Signal Enable Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_SIGNAL_EN</name>
              <description>Bus Reset Pattern Generation Done Signal Enable
This bit is used only in Master mode of operation.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_SIGNAL_EN</name>
              <description>Bus owner Updated Signal Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_UPDATED_SIGNAL_EN</name>
              <description>IBI Updated Signal Enable
This field is used in Slave mode of operation.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_REQ_RECV_SIGNAL_EN</name>
              <description>Read Request Received Signal Enable
This field is used in Slave mode of operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEFSLV_SIGNAL_EN</name>
              <description>Define Slave CCC Received Signal Enable</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ERR_SIGNAL_EN</name>
              <description>Transfer Error Signal Enable</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_SIGNAL_EN</name>
              <description>Dynamic Address Assigned Signal Enable
This field is used in Slave mode of operation.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCC_UPDATED_SIGNAL_EN</name>
              <description>CCC Table Updated Signal Enable
This field is used in Slave mode of operation.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_ABORT_SIGNAL_EN</name>
              <description>Transfer Abort Signal Enable
This field is used in Master mode of operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_READY_SIGNAL_EN</name>
              <description>Response Queue Ready Signal Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_SIGNAL_EN</name>
              <description>Command Queue Ready Signal Enable</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_THLD_SIGNAL_EN</name>
              <description>IBI Buffer Threshold Signal Enable
This field is used in Master mode of operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THLD_SIGNAL_EN</name>
              <description>Receive Buffer Threshold Signal Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THLD_SIGNAL_EN</name>
              <description>Transmit Buffer Threshold Signal Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_INTR_FORCE</name>
          <description>Interrupt Force Enable Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_RESET_DONE_FORCE_EN</name>
              <description>Bus Reset Pattern Generation Done Force Enable
This bit is used only in Master mode of operation.</description>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BUSOWNER_UPDATED_FORCE_EN</name>
              <description>Bus Owner Updated Force Enable</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>IBI_UPDATED_FORCE_EN</name>
              <description>IBI Updated Force Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>READ_REQ_FORCE_EN</name>
              <description>Read Request Received Force Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DEFSLV_FORCE_EN</name>
              <description>Define Slave CCC Received Force Enable</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TRANSFER_ERR_FORCE_EN</name>
              <description>Transfer Error Force Enable</description>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DYN_ADDR_ASSGN_FORCE_EN</name>
              <description>Dynamic Address Assigned Force Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CCC_UPDATED_FORCE_EN</name>
              <description>CCC Table Updated Force Enable
This bit is used in Slave mode of operation.</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TRANSFER_ABORT_FORCE_EN</name>
              <description>Transfer Abort Force Enable
This bit is used in Master mode of operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RESP_READY_FORCE_EN</name>
              <description>Response Queue Ready Force Enable</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CMD_QUEUE_READY_FORCE_EN</name>
              <description>Command Queue Ready Force Enable</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>IBI_THLD_FORCE_EN</name>
              <description>IBI Buffer Threshold Force Enable
This bit is used in Master mode of operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>RX_THLD_FORCE_EN</name>
              <description>Receive Buffer Threshold Force Enable</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_THLD_FORCE_EN</name>
              <description>Transmit Buffer Threshold Force Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_QUEUE_STATUS_LEVEL</name>
          <description>Queue Status Level Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_BUF_BLR</name>
              <description>IBI Buffer Level Value
This field contains the number of valid IBI status entries in the IBI buffer.
This field is used in Master mode of operation.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_BUF_BLR</name>
              <description>Response Buffer Level Value
 This field contains the number of valid data entries in the response buffer.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_QUEUE_EMPTY_LOC</name>
              <description>Command Queue Empty Locations
This field contains the number of empty locations in the command buffer.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DATA_BUFFER_STATUS_LEVEL</name>
          <description>Data Buffer Status Level Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_BUF_BLR</name>
              <description>Receive Buffer Level Value
This field contains the number of valid data entries in the receive buffer.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_BUF_EMPTY_LOC</name>
              <description>Transmit Buffer Empty Level Value
This field contains the number of empty locations in the transmit buffer.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_PRESENT_STATE</name>
          <description>Present State Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x10000003</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASTER_IDLE</name>
              <description>This bit reflects whether the I3C Master is in IDLE state or not. This bit is set when all the queues (command, response, IBI) and buffers (transmit and receive) are empty along with the Master state machine is in IDLE state.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>I3C Master is not in IDLE State</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>I3C Master is in IDLE State</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_TID</name>
              <description>This field reflects the Transaction-ID of the current executing command.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CM_TFR_ST_STS</name>
              <description>Current Master Transfer State Status
 This field indicates the state of current transfer currently being executed by the I3C. 
This is valid in Master mode only.</description>
              <bitRange>[21:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>IDLE (Controller is in IDLE state, waiting for commands)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>START generation state</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>RESTART generation state</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>STOP generation state</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>START hold generation for the slave initiated START state</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Broadcast write address header generation state</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Broadcast read address header generation state</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Dynamic address assignment state</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Slave address generation state</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>CCC byte generation state</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>HDR command generation state</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Write data transfer state</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>Read data transfer state</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>IBI (SIR) read data state</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>IBI auto disable state</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>HDR-DDR CRC data generation/receive state</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>Clock extension state</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>HALTS state</description>
                  <value>0x13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CM_TFR_STS</name>
              <description>Transfer Type Status
This field indicates the type of transfer currently executing by the I3C.
This is valid in Master mode only
0x0: IDLE (Controller is in IDLE state, waiting for commands)
0x1: Broadcast CCC write transfer
0x2: Directed CCC write transfer
0x3: Directed CCC read transfer
0x4: ENTDAA address assignment transfer
0x5: SETDASA address assignment transfer
0x6: Private I3C SDR write transfer
0x7: Private I3C SDR read transfer
0x8: Private I2C SDR write transfer
0x9: Private I2C SDR read transfer
0xC: Private HDR Double-Data Rate (DDR) write transfer
0xD: Private HDR DDR read transfer
0xE: Servicing IBI transfer
0xF: HALT state
In Slave mode of operation:
0x0: IDLE (Controller is in IDLE state)
0x1: Hot-Join transfer state
0x2: IBI transfer state
0x3: Master write transfer ongoing
0x4: Read data prefetch state
0x5: Master read transfer ongoing
0x6: HALT state</description>
              <bitRange>[13:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURRENT_MASTER</name>
              <description>This bit is used to check whether the master is current master or not. The current master is the master that owns the SCL line.
If this bit is set to 0x0, the master is not current master and requires to request the ownership before initiating any transfer on the line.
If this bit is set to 0x1, the master is the current master and can initate the transfers on the line.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SDA_LINE_SIGNAL_LEVEL</name>
              <description>This bit is used to check the SDA line level to recover from errors and for debugging. It reflects the value of synchronized SDA signal. This is valid in Master mode only.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SCL_LINE_SIGNAL_LEVEL</name>
              <description>This bit is used to check the SCL line level to recover from errors and for debugging. It reflects the value of synchronized SCL signal. This is valid in Master mode only.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_CCC_DEVICE_STATUS</name>
          <description>Device Operating Status Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame Error
This bit is set when private write request from master has frame error in HDR-DDR mode. This is cleared only after master reads the device status through GETSTATUS CCC.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUFFER_NOT_AVAIL</name>
              <description>Buffer Not Available
This bit is set when private write request from master is NACKed because of Rx buffer not having I3C_DATA_BUFFER_THLD_CTRL[RX_BUF_THLD] number of empty locations or Response buffer is full. In SDR mode of operation this is cleared when the master issues GETSTATUS CCC or upon space becoming available in the buffer and the successful completion of the next write transfer. In HDR mode of operation it is cleared only when master issues GETSTATUS CCC.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_NOT_READY</name>
              <description>Data Not Ready
This bit is set when private read request from master is NACKed because of any of the following conditions:
- Command FIFO empty
- Tx FIFO threshold is not met
- Response FIFO full</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_ERR</name>
              <description>Overflow Error
Overflow error condition detected during master write transfer. This is cleared only after master reads the device status through GETSTATUS CCC.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLAVE_BUSY</name>
              <description>Slave Busy
This bit is set if any change is made by the current master in to MRL register or occurance of any error. It is cleared after slave application resumes the slave operation by writing 0x1 in I3C_DEVICE_CTRL[RESUME] field.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW_ERR</name>
              <description>Underflow Error
This bit is set if I3C slave terminates a read transfer because of unavailability of data in the transmit buffer. This is cleared only after master reads the device status through GETSTATUS CCC.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVITY_MODE</name>
              <description>Activity Mode
This field reflects the input port signal ACT_MODE.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PROTOCOL_ERR</name>
              <description>Protocol Error
This bit is set when the slave controller encouters a Parity/CRC error during write data transfer.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PENDING_INTR</name>
              <description>Pending Interrupt
This field reflects the value driven on PENDING_INT input port.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEVICE_ADDR_TABLE_POINTER</name>
          <description>Pointer for Device Address Table Registers</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00020220</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEV_ADDR_TABLE_DEPTH</name>
              <description>Depth of Device Address Table</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>P_DEV_ADDR_TABLE_START_ADDR</name>
              <description>Start Address of Device Address Table</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE_POINTER</name>
          <description>Pointer for Device Characteristics Table Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00008200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESENT_DEV_CHAR_TABLE_INDX</name>
              <description>Current Index of Device Characteristics Table
This field returns the current location of Device Characteristics Table index. Initially, this index points to 0.
 Once the complete characteristics information of a Slave device is written into Device Characteristics Table during ENTDAA, this index increments by 1. 
The first winning device information is stored in Device Characteristics Table index 0, the second winning device information in index 1, and so on.
If required, this index is used to override the location, where characteristic information of slave devices on the I3C bus are written during ENTDAA. Hence, this bit is useful only if the device is current master. During DEFSLV CCC, the index always starts from 0.
In non-current master, this bit is always read-only.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_CHAR_TABLE_DEPTH</name>
              <description>Depth of Device Characteristics Table</description>
              <bitRange>[18:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>P_DEV_CHAR_TABLE_START_ADDR</name>
              <description>Start Address of Device Characteristics Table</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_VENDOR_SPECIFIC_REG_POINTER</name>
          <description>Pointer for Vendor Specific Registers</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x000000B0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>P_VENDOR_REG_START_ADDR</name>
              <description>Start Address of Vendor Specific Registers</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_MIPI_ID_VALUE</name>
          <description>Provisional ID Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLV_MIPI_MFG_ID</name>
              <description>Specifies the MIPI Manufacturer ID.</description>
              <bitRange>[15:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_PROV_ID_SEL</name>
              <description>Specifies the Provisional ID Type.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Vendor fixed value</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Random value</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_PID_VALUE</name>
          <description>Provisional ID Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLV_PART_ID</name>
              <description>Specifies the Part ID of I3C device.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_INST_ID</name>
              <description>This field is used to program the instance ID of the slave.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_PID_DCR</name>
              <description>Specifies the additional 12-bit ID of I3C device.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_CHAR_CTRL</name>
          <description>I3C Slave Characteristic Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00010062</resetValue>
          <resetMask>0xFFFFFFE3</resetMask>
          <fields>
            <field>
              <name>HDR_CAP</name>
              <description>I3C Device HDR Capability Field Value.
Others: Reserved</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>HDR Mode 0</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DCR</name>
              <description>I3C Device Characteristic Value.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVICE_ROLE</name>
              <description>This field is set to 0x1 by default. The field is reset to its default value upon I3C reset.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDR_CAPABLE</name>
              <description>Programming this bit to 0x0 does not disable the HDR feature itself. This bit can be modified by the application if it does not want to advertize slaves HDR capability to master. The field is Reset to its default value upon I3C reset.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IBI_REQUEST_CAPABLE</name>
              <description>IBI Request Capable field in I3C_DEV_CHAR_TABLE1_LOC3[BCR] field 1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_DATA_SPEED_LIMIT</name>
              <description>Max Data Speed Limitation 
Specifies whether or not I3C has maximum data speed limitation. 
If this bit is set to 0x0, controller NACKed the GETMXDS CCC sent by master. 
If this bit is set to 0x1, controller returns the data in I3C_MAX_DATA_SPEED and I3C_MAX_READ_TURNAROUND registers in response the GETMXDS CCC sent by master.
The field is reset to its default value upon I3C Reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_MAX_LEN</name>
          <description>I3C Max Write/Read Length Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00FF00FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MRL</name>
              <description>I3C Device Max Read Length</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MWL</name>
              <description>I3C Device Max Write Length</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_MAX_READ_TURNAROUND</name>
          <description>MXDS Maximum Read Turnaround Time Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXDS_MAX_RD_TURN</name>
              <description>Specifies the maximum read turnaround time of I3C slave.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_MAX_DATA_SPEED</name>
          <description>MXDS Maximum Data Speed Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXDS_CLK_DATA_TURN</name>
              <description>Specifies the clock to data turnaround time of I3C slave device.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>8 ns</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>9 ns</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>10 ns</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>11 ns</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>12 ns</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MXDS_MAX_RD_SPEED</name>
              <description>Specifies the Maximum Sustained Data Rate for non-CCC messages sent by I3C slave device to master device.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>12.5 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8 MHZ</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>6 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MXDS_MAX_WR_SPEED</name>
              <description>Specifies the Maximum Sustained Data Rate for non-CCC messages sent by Master Device to I3C Slave device.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>12.5 MHz</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>8 MHZ</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>6 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 MHz</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>2 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SLV_INTR_REQ</name>
          <description>Slave Interrupt Request Register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_STS</name>
              <description>IBI Completion Status
This field is common for SIR and MR</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>IBI accepted by the master (ACK response received)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>IBI not attempted</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MR</name>
              <description>Master Request
 When set, the I3C attempts to issue the MR on the I^3C bus. Once issued and when the current master accepts or if the I3C is unable to issue the MR, then the I3C clears this bit automatically and updates the IBI_STS field. If NACK response is received for the MR, the I3C reattempts the MR upon detecting the next START condition from the master or after the bus available time. 
 Once set, the application cannot clear this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIR_CTRL</name>
              <description>Slave Interrupt Request Control</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Send the assigned Dynamic address</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIR</name>
              <description>Slave Interrupt Request
When set, the I3C slave attempts to issue the SIR on the I^3C bus. Once issued and when the current master accepts (ACK) or if the I3C is unable to issue the SIR, then the I3C clears this bit automatically and updates the IBI_STS field. If the NACK response is received for the SIR, the controller reattempts the SIR upon detecting the next START condition from the master or after the bus available time. Once set, the application cannot clear this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEVICE_CTRL_EXTENDED</name>
          <description>Device Control Extended Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQMST_ACK_CTRL</name>
              <description>In Slave mode of operation, this bit serves as a control to ACK/NACK GETACCMST CCC from current master.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACK GETACCMST CCC</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>NACK GETACCMST CCC</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEV_OPERATION_MODE</name>
              <description>This field is used to select the device operation mode before the I3C is enabled. It field is written only when the I3C is disabled.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Master mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Slave mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I3C_OD_TIMING</name>
          <description>SCL I3C Open Drain Timing Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000A0010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_OD_HCNT</name>
              <description>I3C Open Drain High Count
SCL open-drain high count for I3C transfers targeted to I3C devices.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_OD_LCNT</name>
              <description>I3C Open Drain Low Count
SCL open-drain low count for I3C transfers targeted to I3C devices.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I3C_PP_TIMING</name>
          <description>SCL I3C Push Pull Timing Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000A000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_PP_HCNT</name>
              <description>I3C Push-Pull High Count
SCL push-pull high count for I3C transfers targeted to I3C devices.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_PP_LCNT</name>
              <description>I3C Push-Pull Low Count
SCL push-pull low count for I3C transfers targeted to I3C devices.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I2C_FM_TIMING</name>
          <description>SCL I2C Fast Mode Timing Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00100010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2C_FM_HCNT</name>
              <description>I2C Fast Mode High Count
The SCL open drain high count timing for I2C Fast Mode transfers.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_FM_LCNT</name>
              <description>I2C Fast Mode Low Count
The SCL open drain low count timing for I2C Fast Mode transfers.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_I2C_FMP_TIMING</name>
          <description>SCL I2C Fast Mode Plus Timing Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00100010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2C_FMP_HCNT</name>
              <description>I2C Fast Mode Plus High Count
The SCL open drain high count timing for I2C Fast Mode Plus transfers.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_FMP_LCNT</name>
              <description>I2C Fast Mode Plus Low Count
The SCL open drain low count timing for I2C Fast Mode Plus transfers.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_EXT_LCNT_TIMING</name>
          <description>SCL Extended Low Count Timing Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20202020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_EXT_LCNT_4</name>
              <description>I3C Extended Low Count Register 4
SDR4 uses this field for data transfer.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_EXT_LCNT_3</name>
              <description>I3C Extended Low Count Register 3
SDR3 uses this field for data transfer.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_EXT_LCNT_2</name>
              <description>I3C Extended Low Count Register 2
SDR2 uses this field for data transfer.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I3C_EXT_LCNT_1</name>
              <description>I3C Extended Low Count Register 1
SDR1 uses this field for data transfer.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_EXT_TERMN_LCNT_TIMING</name>
          <description>SCL Termination Bit Low Count Timing Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_EXT_TERMN_LCNT</name>
              <description>I3C Read Termination Bit Low Count.
SDR0 speed: I3C_PP_LCNT + I3C_EXT_TERMN_LCNT
SDR1 speed: I3C_EXT_LCNT_1 + I3C_EXT_TERMN_LCNT
SDR2 speed: I3C_EXT_LCNT_2 + I3C_EXT_TERMN_LCNT
SDR3 speed: I3C_EXT_LCNT_3 + I3C_EXT_TERMN_LCNT
SDR4 speed: I3C_EXT_LCNT_4 + I3C_EXT_TERMN_LCNT</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SDA_HOLD_SWITCH_DLY_TIMING</name>
          <description>SDA Hold and Mode Switch Delay Timing Register</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDA_TX_HOLD</name>
              <description>This field controls the hold time (in term of the CORE_CLK periods) of the SDA with respect to the SCL edge in FM, FM+, SDR and DDR mode of operations. 
The valid values are from 0x1 to 0x7. Others are Reserved.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_BUS_FREE_AVAIL_TIMING</name>
          <description>Bus Free Timing Register</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00200020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_AVAILABLE_TIME</name>
              <description>This field is used only in Slave mode of operation.
This field is used by the Slave/non-current Master mode to initiate an IBI after STOP condition.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_FREE_TIME</name>
              <description>This field is used only in Master mode of operation.
In pure bus system, this field represents tCAS. In Mixed Bus system, this field is expected to be programmed to tLOW of I2C timing.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_BUS_IDLE_TIMING</name>
          <description>Bus Idle Timing Register</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_IDLE_TIME</name>
              <description>Bus IDLE Count Value
This field is used by the controller in Slave or non-current Master mode to initiate Hot-Join request if the Dynamic address is not valid.</description>
              <bitRange>[19:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SCL_LOW_MST_EXT_TIMEOUT</name>
          <description>SCL Low Master Extended Timeout Register</description>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x003567E0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCL_LOW_MST_TIMEOUT_COUNT</name>
              <description>This count defines the number of CORE_CLK periods to count for generation of the SCL low bus reset pattern.</description>
              <bitRange>[25:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_VER_ID</name>
          <description>Version ID Register</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3130302A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_VER_ID</name>
              <description>Module version ID</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_VER_TYPE</name>
          <description>Version Type Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x6C633033</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I3C_VER_TYPE</name>
              <description>Version type ID</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_QUEUE_SIZE_CAPABILITY</name>
          <description>I3C Queue Size Capability Register</description>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00032355</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IBI_BUF_SIZE</name>
              <description>IBI Queue Size
This field reflects the configured IBI queue size in encoded values.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 DWORDS</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 DWORDS</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 DWORDS</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16 DWORDS</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESP_BUF_SIZE</name>
              <description>Response Queue Size
This field reflects the configured response queue size in encoded values.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 DWORDS</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 DWORDS</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 DWORDS</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16 DWORDS</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMD_BUF_SIZE</name>
              <description>Command Queue Size
This field reflects the configured command queue size in encoded values.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 DWORDS</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 DWORDS</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 DWORDS</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16 DWORDS</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_BUF_SIZE</name>
              <description>Receive Data Buffer Size
This field reflects the configured Rx buffer size in encoded values.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 DWORDS</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 DWORDS</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 DWORDS</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16 DWORDS</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32 DWORDS</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>64 DWORDS</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_BUF_SIZE</name>
              <description>Transmit Data Buffer Size
This field reflects the configured Tx buffer size in encoded values.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>2 DWORDS</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4 DWORDS</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8 DWORDS</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16 DWORDS</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>32 DWORDS</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>64 DWORDS</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC1</name>
          <description>Device Characteristic Table Location 1 Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LSB_PROVISIONAL_ID</name>
              <description>The LSB 32-bit value of Provisional-ID</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_SEC_DEV_CHAR_TABLE1</name>
          <description>Secondary Master Device Characteristic Table Location Register</description>
          <alternateRegister>I3C_DEV_CHAR_TABLE1_LOC1</alternateRegister>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATIC_ADDR</name>
              <description>The Static Address of Device</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BCR_TYPE</name>
              <description>The BCR TYPE of Device</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DCR_TYPE</name>
              <description>The DCR TYPE of Device</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYNAMIC_ADDR</name>
              <description>The Dynamic Address of Device</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC2</name>
          <description>Device Characteristic Table Location 2 Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSB_PROVISIONAL_ID</name>
              <description>The MSB 16-bit value of Provisional-ID</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC3</name>
          <description>Device Characteristic Table Location 3 Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>Bus Characteristic Value</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DCR</name>
              <description>Device Characteristic Value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_CHAR_TABLE1_LOC4</name>
          <description>Device Characteristic Table Location 4 Register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEV_DYNAMIC_ADDR</name>
              <description>Device Dynamic address assigned.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I3C_DEV_ADDR_TABLE_LOC1</name>
          <description>Device Address Table Location 1 Register</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEGACY_I2C_DEVICE</name>
              <description>Legacy I2C Device or Not.
This bit is set to 0x1 if the device is a legacy I2C device.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_NACK_RETRY_CNT</name>
              <description>Retry Model for Direct GET CCC Commands.
This field is used to set the Device NACK retry count for the particular device.
If the device NACKs for the device address, the I3C automatically retries the same device until this count expires. If the slave does not ACK for the mentioned number of retries, then I3C generates an error response and move to the HALT state.
The incoming SIR IBI matches with the slave address initated by the master.</description>
              <bitRange>[30:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_DYNAMIC_ADDR</name>
              <description>Device Dynamic Address With Parity
This field consists of Dynamic address and parity bit.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEV_STATIC_ADDR</name>
              <description>Device Static Address</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="EVTRTR1">
      <name>EVTRTR0</name>
      <baseAddress>0x49035000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CANFD</name>
      <baseAddress>0x49036000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>209</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>20</dim>
          <dimIncrement>4</dimIncrement>
          <name>CANFD_RBUF[%s]</name>
          <description>Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RBUF</name>
              <description>Receive Buffer Register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>18</dim>
          <dimIncrement>4</dimIncrement>
          <name>CANFD_TBUF[%s]</name>
          <description>Transmit Buffer Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TBUF</name>
              <description>Transmit Buffer Register</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TTS</name>
          <description>Transmission Time Stamp Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTS</name>
              <description>Transmission Time Stamp.
This bit field holds the time-stamp of the last transmitted frame for CiA 603 time stamping. Every new frame overwrites it if the TTSEN field of TBUF register is 0x1. The TTS bit field is intended to be used by the time master to acquire the time-stamp of the SYNC message.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CFG_STAT</name>
          <description>Configuration and Status Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>RESET Request Bit.
Some registers can only be modified if the RESET bit is set to 0x1.
This bit forces several components to a reset state. A detailed definition is given in Section Software Reset. It is automatically set if the node enters bus off state (refer to Section Error Handling).
Note that a CAN node will participate in CAN communication after the RESET bit is switched to 0x0 after 11 CAN bit times. This delay is required by the CAN standard (bus idle time).
If the RESET bit is set to 0x1 and immediately set to 0x0, then it takes some time until it can be read as 0x0 and becomes inactive. The reason is clock domain crossing from host to CAN clock domain. The RESET bit is held active as long as needed depending on the relation between host and CAN clock.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No local reset of the CAN controller</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The host controller performs a local reset of the CAN controller</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBME</name>
              <description>Loop Back Mode, External (refer to Section Loop Back Mode (LBMI and LBME)).
Note that this bit should not be enabled while a transmission is active.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBMI</name>
              <description>Loop Back Mode, Internal (refer to Section Loop Back Mode (LBMI and LBME)).
Note that this bit should not be enabled while a transmission is active.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPSS</name>
              <description>Transmission Primary Single Shot Mode for PTB (refer to Section Single Shot Transmission (SST)).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSS</name>
              <description>Transmission Secondary Single Shot Mode for STB (refer to Section Single Shot Transmission (SST)).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RACTIVE</name>
              <description>Reception ACTIVE (Receive Status Bit).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No receive activity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller is currently receiving a frame</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACTIVE</name>
              <description>Transmission ACTIVE (Transmit Status Bit).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmit activity</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller is currently transmitting a frame</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSOFF</name>
              <description>Bus Off (Bus Status Bit, refer to Section Error Handling).
Writing a 0x1 to this bit will reset the CANFD_TECNT and CANFD_RECNT registers. This should be done only for debugging. For more details, refer Section Error Counter Reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The controller status is bus on</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The controller status is bus off</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TCMD</name>
          <description>Command Register</description>
          <addressOffset>0xA1</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TBSEL</name>
              <description>Transmit Buffer Select.
Selects the transmit buffer to be loaded with a message. Use the TBUF registers for access. The TBSEL bit needs to be stable all the time the TBUF registers are written and when the CANFD_TCTRL[TSNEXT] bit is set.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>PTB (high-priority buffer)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOM</name>
              <description>Listen Only Mode (refer to Section Listen Only Mode (LOM)).
This bit cannot be set if the TPE, TSONE, or TSALL bit is set. No transmission can be started if it is enabled and the CANFD_CFG_STAT[LBME] bit is disabled.
The LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0 disables all transmissions.
The LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x1 disables the ACK for received frames and error frames, but enables the transmission of own frames.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STBY</name>
              <description>Transceiver Standby Mode (refer to Section Transceiver Standby Mode).
This register bit can be used to control a standby mode of a transceiver.
This bit cannot be set to 0x1 if the TPE, TSONE, or TSALL bit is set to 0x1.
If the host sets it to 0x0 then the host needs to wait for the time required by the transceiver to start up before the host requests a new transmission.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPE</name>
              <description>Transmit Primary Enable.
If this bit is set, the message from the PTB will be transmitted at the next possible transmit position. A started transmission from the STB will be completed before, but pending new messages are delayed until the PTB message has been transmitted.
The TPE bit stays set until the message has been transmitted successfully or it is aborted using the TPA bit.
The host controller can set the TPE bit to 0x1 but can not reset it to 0x0. This would only be possible using the TPA bit and aborting the message.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1, STBY = 0x1, (LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission for the PTB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission enable for the message in the high-priority PTB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPA</name>
              <description>Transmit Primary Abort.
The bit has to be set by the host controller and will be reset by the CAN controller. Setting this bit automatically de-asserts the TPE bit.
The host controller can set the TPA bit to 0x1 but can not reset it to 0x0.
During the short time while the CAN controller resets the bit, it cannot be set by the host.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1.
This bit should not be set simultaneously with the TPE bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No abort</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Aborts a transmission from PTB which has been requested by the TPE = 0x1 but not started yet (the data bytes of the message remains in the PTB)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSONE</name>
              <description>Transmit Secondary One Frame.
This bit in priority mode is difficult to handle, because it is not always clear which message will be transmitted if new messages are written to the STB meanwhile.
The controller starts the transmission as soon as the bus becomes vacant and no request of the PTB (the TPE bit) is pending.
The TSONE bit stays set until the message has been transmitted successfully or it is aborted using the TSA bit.
The host controller can set the TSONE bit to 0x1 but can not reset it to 0x0. This would only be possible using the TSA bit and aborting the message.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1, STBY = 0x1, (LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission for the STB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission enable of one in the STB. In FIFO mode this is the oldest message and in priority mode this is the one with the highest priority</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSALL</name>
              <description>Transmit Secondary All Frames.
The controller starts the transmission as soon as the bus becomes vacant and no request of the PTB (the TPE bit) is pending.
This bit stays set until all messages have been transmitted successfully or they are aborted using the TSA bit.
The host controller can set the TSALL bit to 0x1 but can not reset it to 0x0. This would only be possible using the TSA bit and aborting the messages.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1, STBY = 0x1, (LOM = 0x1 and CANFD_CFG_STAT[LBME] = 0x0).
If during a transmission the STB is loaded with a new frame then the new frame will be transmitted too. In other words: a transmission initiated by this bit is finished when the STB becomes empty.
Note: Setting both TSONE and TSALL bits is meaningless. While the TSALL bit is already set, it is impossible to set the TSONE bit and vice versa. If both TSONE and TSALL bits are set simultaneously then the TSALL bit wins and the TSONE bit is cleared by the CAN controller.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission for the STB</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission enable of all messages in the STB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSA</name>
              <description>Transmit Secondary Abort.
The bit has to be set by the host controller and will be reset by the CAN controller. Setting this bit, automatically de-asserts the TSONE or TSALL bit respectively.
The host controller can set this bit to 0x1 but can not reset it to 0x0.
The bit will be reset to the hardware reset value if the CANFD_CFG_STAT[RESET] = 0x1.
This bit should not be set simultaneously with the TSONE or TSALL bit.
For a TSONE transmission, only one frame is aborted while for a TSALL transmission, all frames are aborted.
One or all message slots will be released which updates the CANFD_TCTRL[TSSTAT] bit field.
All aborted messages are lost because they are not accessible any more.
If in priority mode a TSONE transmission is aborted, then it is not clear which frame will be aborted if new frames are written to the STB meanwhile.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No abort</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Aborts a transmission from STB which has been requested but not started yet</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TCTRL</name>
          <description>Transmit Control Register</description>
          <addressOffset>0xA2</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x84</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FD_ISO</name>
              <description>CAN FD ISO Mode.
ISO CAN FD mode has a different CRC initialization value and an additional stuff bit count. Both modes are incompatible and must not be mixed in one CAN network.
This bit has no impact to CAN 2.0B.
This bit is only writeable if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Bosch CAN FD (non-ISO) mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ISO CAN FD mode (ISO 11898-1:2015)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSNEXT</name>
              <description>Transmit Buffer Secondary Next.
After all frame bytes are written to the TBUF registers, the host controller has to set this bit to signal that this slot has been filled. Then the CAN controller connects the TBUF registers to the next slot. Once a slot is marked as filled a transmission can be started using the CANFD_TCMD[TSONE] or CANFD_TCMD[TSALL] bit.
It is possible to set the TSNEXT bit and the CANFD_TCMD[TSONE] or CANFD_TCMD[TSALL] bit together in one write access.
This bit has to be set by the host controller and is automatically reset by the CAN controller immediately after it was set.
Setting the TSNEXT bit is meaning less if the CANFD_TCMD[TBSEL] = 0x0. In this case the TSNEXT bit is ignored and automatically cleared. It does not do any harm.
If all slots of the STB are filled, this bit stays set until a slot becomes free (refer to Section Full STB).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No action</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STB slot filled, select next slot</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSMODE</name>
              <description>Transmit Buffer Secondary Operation Mode.
In FIFO mode frames are transmitted in the order in that they are written into the STB.
In priority decision mode the frame with the highest priority in the STB is automatically transmitted first. The ID of a frame is used for the priority decision. A lower ID means a higher priority of a frame. A frame in the PTB has always the highest priority regardless of the ID.
This bit shall be switched only if the STB is empty.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>FIFO mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Priority decision mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSSTAT</name>
              <description>Transmission Secondary Status Bits.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>STB is empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>STB is less than or equal to half full</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>STB is more than half full</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>STB is full</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RCTRL</name>
          <description>Receive Control Register</description>
          <addressOffset>0xA3</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SACK</name>
              <description>Self-Acknowledge.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No self-ACK</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Self-ACK when the CANFD_CFG_STAT[LBME] = 0x1</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROM</name>
              <description>Receive Buffer Overflow Mode.
In case of a full RBUF when a new message is received, then this bit selects the following:</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The oldest message will be overwritten</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> The new message will not be stored</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROV</name>
              <description>Receive Buffer Overflow.
This bit is cleared by setting the RREL = 0x1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Overflow</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description> Overflow. At least one message is lost</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RREL</name>
              <description>Receive Buffer Release.
The host controller has read the actual RB slot and releases it. Afterwards the CAN controller points to the next RB slot. The RSTAT bit field gets updated.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No release</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Release: The host has read the RB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RBALL</name>
              <description>Receive Buffer Stores All Data Frames.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RB stores correct data frames as well as data frames with error (refer to Section Reception of All Data Frames (CANFD_RCTRL[RBALL]))</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RSTAT</name>
              <description>Receive Buffer Status.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Empty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>&gt; Empty and &lt; almost full (CANFD_LIMIT[AFWL])</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Almost full (programmable threshold by the CANFD_LIMIT[AFWL] bit field) but not full and no overflow</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Full (stays set in case of overflow-for overflow signaling, see the ROV bit)</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RTIE</name>
          <description>Receive and Transmit Interrupt Enable Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0xFE</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RIE</name>
              <description>Receive Interrupt Enable.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROIE</name>
              <description>RB Overrun Interrupt Enable.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFIE</name>
              <description>RB Full Interrupt Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAFIE</name>
              <description>RB Almost Full Interrupt Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPIE</name>
              <description>Transmission Primary Interrupt Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIE</name>
              <description>Transmission Secondary Interrupt Enable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EIE</name>
              <description>Error Interrupt Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSFF</name>
              <description>Transmit Secondary Buffer Full Flag.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The STB is not filled with the maximal number of messages</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The STB is filled with the maximal number of messages</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RTIF</name>
          <description>Receive and Transmit Interrupt Flag Register</description>
          <addressOffset>0xA5</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RIF</name>
              <description>Receive Interrupt Flag.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No frame has been received</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Data or a remote frame has been received and is available in the receive buffer</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROIF</name>
              <description>RB Overrun Interrupt Flag.
In case of an overrun both ROIF and RFIF bits are set.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No RB overwritten</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>At least one received message has been overwritten in the RB</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFIF</name>
              <description>RB Full Interrupt Flag.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The RB FIFO is not full</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>All RBs are full. If no RB is released until the next valid message is received, the oldest message is lost</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAFIF</name>
              <description>RB Almost Full Interrupt Flag.
Refer to the CANFD_LIMIT[AFWL] bit field.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>number of filled RB slots &lt; AFWL_i</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>number of filled RB slots AFWL_i</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TPIF</name>
              <description>Transmission Primary Interrupt Flag.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission of the PTB has been completed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The requested transmission of the PTB has been successfully completed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSIF</name>
              <description>Transmission Secondary Interrupt Flag.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No transmission of the STB has been completed successfully</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The requested transmission of the STB has been successfully completed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EIF</name>
              <description>Error Interrupt Flag.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>There has been no change</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The border of the error warning limit has been crossed in either direction, or the CANFD_CFG_STAT[BUSOFF] bit has been changed in either direction</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIF</name>
              <description>Abort Interrupt Flag.
It is recommended to not set both CANFD_TCMD[TPA] and CANFD_TCMD[TSA] bits simultaneously because both source this bit.
This bit does not have an associated enable register.
Refer to Section Message Transmission Abort.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No abort has been executed</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>After setting the CANFD_TCMD[TPA] or CANFD_TCMD[TSA] bit the appropriated message(s) have been aborted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ERRINT</name>
          <description>Error Interrupt Enable and Flag Register</description>
          <addressOffset>0xA6</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EWARN</name>
              <description>Error Warning Limit Reached.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The values in both counters are less than the CANFD_LIMIT[EWL] bit field</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>One of the error counters (the CANFD_RECNT or CANFD_TECNT register) is equal or bigger than the CANFD_LIMIT[EWL] bit field</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EPASS</name>
              <description>Error Passive Mode Active.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not active (node is error active)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Active (node is error passive)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EPIE</name>
              <description>Error Passive Interrupt Enable.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EPIF</name>
              <description>Error Passive Interrupt Flag.
This bit will be activated if the error status changes from error active to error passive or vice versa and if this interrupt is enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>ALIE</name>
              <description>Arbitration Lost Interrupt Enable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALIF</name>
              <description>Arbitration Lost Interrupt Flag.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
            <field>
              <name>BEIE</name>
              <description>Bus Error Interrupt Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BEIF</name>
              <description>Bus Error Interrupt Flag.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <modifiedWriteValues>oneToClear</modifiedWriteValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_LIMIT</name>
          <description>Warning Limits Register</description>
          <addressOffset>0xA7</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x1B</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AFWL</name>
              <description>Almost Full Warning Limit.
The AFWL bit field defines the internal warning limit AFWL_i with nRB being the number of available RB slots.
AFWL_i is compared to the number of filled RB slots and triggers the CANFD_RTIF[RAFIF] bit if equal. The valid range of AFWL_i is [1KB nRB].
AFWL = 0 is meaningless and automatically treated as 0x1.
 Note that AFWL is meant in this rule and not AFWL_i.
 AFWL_i &gt; nRB is meaningless and automatically treated as nRB.
AFWL_i = nRB is a valid value, but note that the CANFD_RTIF[RFIF] bit also exists.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EWL</name>
              <description>Programmable Error Warning Limit = (EWL + 1) x 8.
Possible Limit values: 8, 16, ...128. The value of this bit field controls the CANFD_RTIF[EIF] bit.
The EWL bit field needs to be transferred using Clock Domain Crossing (CDC) from host to CAN clock domain. During transfer, this bit field is write-locked for the host for a few clocks until CDC is complete.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_SEG_1</name>
          <description>Slow Speed Bit Timing 1 Register (Segment 1)</description>
          <addressOffset>0xA8</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x03</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_SEG_1</name>
              <description>Bit Timing Segment 1 (Slow Speed).
The sample point will be set to tSeg_1 = (Seg_1 + 2) x TQ after start of bit time.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_SEG_2</name>
          <description>Slow Speed Bit Timing 2 Register (Segment 2)</description>
          <addressOffset>0xA9</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_SEG_2</name>
              <description>Bit Timing Segment 2 (Slow Speed).
Time tSeg_2 = (Seg_2 + 1) x TQ after the sample point.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_SJW</name>
          <description>Slow Speed Bit Timing 3 Register (Synchronization Jump Width)</description>
          <addressOffset>0xAA</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_SJW</name>
              <description>Synchronization Jump Width (Slow Speed).
The Synchronization Jump Width tSJW = (SJW + 1) x TQ is the maximum time for shortening or lengthening the Bit Time for resynchronization, where TQ is a time quanta.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_S_PRESC</name>
          <description>Slow Speed Prescaler Register</description>
          <addressOffset>0xAB</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>S_PRESC</name>
              <description>Prescaler Slow Speed.
The prescaler divides the system clock to get the time quanta clock.
Valid range for the CANFD_S_PRESC[S_PRESC] bit field is from 0x00 to 0xFF (results in divider values from 1 to 255).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_SEG_1</name>
          <description>Fast Speed Bit Timing 1 Register (Segment 1)</description>
          <addressOffset>0xAC</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x03</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_SEG_1</name>
              <description>Bit Timing Segment 1 (Fast Speed).
The sample point will be set to tSeg_1 = (Seg_1 + 2) x TQ after start of bit time.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_SEG_2</name>
          <description>Fast Speed Bit Timing 2 Register (Segment 2)</description>
          <addressOffset>0xAD</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_SEG_2</name>
              <description>Bit Timing Segment 2 (Fast Speed).
Time tSeg_2 = (Seg_2 + 1) x TQ after the sample point.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_SJW</name>
          <description>Fast Speed Bit Timing 3 Register (Synchronization Jump Width)</description>
          <addressOffset>0xAE</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_SJW</name>
              <description>Synchronization Jump Width (Fast Speed).
The Synchronization Jump Width tSJW = (SJW + 1) x TQ is the maximum time for shortening or lengthening the Bit Time for resynchronization, where TQ is a time quanta.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_F_PRESC</name>
          <description>Fast Speed Prescaler Register</description>
          <addressOffset>0xAF</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>F_PRESC</name>
              <description>Prescaler Fast Speed.
The prescaler divides the system clock to get the time quanta clock.
Valid range for the CANFD_F_PRESC[F_PRESC] bit field is from 0x00 to 0xFF (results in divider values from 1 to 255).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_EALCAP</name>
          <description>Error and Arbitration Lost Capture Register</description>
          <addressOffset>0xB0</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>KOER</name>
              <description>Kind of Error (Error Code).
(dominant bits after own error flag, received active Error Flag too long, dominant bit during Passive-Error-Flag after ACK error)
This bit field is updated with each new error. Therefore, it stays untouched when frames are successfully transmitted or received.</description>
              <bitRange>[7:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>BIT ERROR</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>FORM ERROR</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>STUFF ERROR</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>ACKNOWLEDGEMENT ERROR</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>CRC ERROR</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>OTHER ERROR</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Not used</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ALC</name>
              <description>Arbitration Lost Capture (bit position in the frame where the arbitration has been lost)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TDC</name>
          <description>Transmitter Delay Compensation Register</description>
          <addressOffset>0xB1</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TDCEN</name>
              <description>Transmitter Delay Compensation Enable.
The Transmitter Delay Compensation (TDC) will be activated during the data phase of a CAN FD frame if BRS is active and if the TDCEN = 0x1. For more details about TDC refer to Section Bit Rate Switching and Sample Point.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSPOFF</name>
              <description>Secondary Sample Point Offset.
The transmitter delay plus defines the time of the secondary sample point for TDC (the SSPOFF bit field value is given as a number of TQ).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_RECNT</name>
          <description>Receive Error Counter Register</description>
          <addressOffset>0xB2</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RECNT</name>
              <description>Receive Error Count (Number of Errors During Reception).
This bit field is incremented and decremented as defined in the CAN specification.
The CANFD_RECNT register does not overflow.
For more details about the CANFD_RECNT register and the bus off state, refer to Section Error Handling.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TECNT</name>
          <description>Transmit Error Counter Register</description>
          <addressOffset>0xB3</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TECNT</name>
              <description>Transmit Error Count (Number of Errors During Transmission).
This bit field is incremented and decremented as defined in the CAN specification.
In case of the bus off state, the TECNT bit field may overflow.
 For more details about this bit field and the bus off state, refer to Section Error Handling.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACFCTRL</name>
          <description>Acceptance Filter Control Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SELMASK</name>
              <description>Select Acceptance MASK.
The ACFADR bit field selects one specific acceptance filter.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The ACF_X registers (where X = 1 to 3) point to acceptance code</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The ACF_X registers (where X = 1 to 3) point to acceptance mask</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACFADR</name>
              <description>Acceptance Filter Address.
This bit field points to a specific acceptance filter. The selected filter is accessible using the ACF_X registers (where X = 1 to 3). The SELMASK bit selects between acceptance code and mask for the selected acceptance filter.
A value of the ACFADR bit field &gt; Number of Acceptance Filters (NAF) - 1 is meaningless and automatically treated as value NAF - 1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_TIMECFG</name>
          <description>CiA 603 Time-Stamping Register</description>
          <addressOffset>0xB5</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x02</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TIMEPOS</name>
              <description>Time-Stamping Position.
For description of the SOF and EOF bits, refer to Section Table 1-2 CAN Bit Abbreviations.
This bit can only be changed if the TIMEEN = 0x0, but it is possible to modify it with the same write access that sets the TIMEEN = 0x1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SOF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>EOF</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMEEN</name>
              <description>Time-Stamping Enable.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_EN_0</name>
          <description>Acceptance Filter Enable 0 Register</description>
          <addressOffset>0xB6</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AE_X</name>
              <description>Acceptance Filter Enable.
Each acceptance filter (AMASK/ACODE) can be individually enabled or disabled. Only filter number 0 is enabled by default after hardware reset.
Disabled filters reject a message. Only enabled filters can accept a message if the appropriate AMASK/ACODE configuration matches.
To accept all messages one filter x has to be enabled by setting AE_X = 0x1, AMASK_X = 0xFF and ACODE_X = 0x00. This is the default configuration after hardware reset for filter X = 0 while all other filters are disabled.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_EN_1</name>
          <description>Acceptance Filter Enable 1 Register</description>
          <addressOffset>0xB7</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AE_X</name>
              <description>Acceptance Filter Enable.
Each acceptance filter (AMASK/ACODE) can be individually enabled or disabled.
Disabled filters reject a message. Only enabled filters can accept a message if the appropriate AMASK/ACODE configuration matches.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_0_3_CODE</name>
          <description>Acceptance CODE Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACODE_X</name>
              <description>Acceptance CODE.
The ID bits are compared with the corresponding acceptance code bits as follows:
- ACODE_X(10-0) will be used for standard frames.
- ACODE_X(28-0) will be used for extended frames.
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
Refer to Section Software Reset.</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance code bit value to compare with ID bit of the received message is disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance code bit value to compare with ID bit of the received message is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_ACF_0_3_MASK</name>
          <description>Acceptance MASK Register</description>
          <alternateRegister>CANFD_ACF_0_3_CODE</alternateRegister>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIDEE</name>
              <description>Acceptance Mask IDE Bit Check Enable.
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter accepts both standard or extended frames</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter accepts either standard or extended as defined by this bit</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIDE</name>
              <description>Acceptance Mask IDE Bit Value.
If the AIDEE = 0x1 then:
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
Note: The AIDEE and AIDE bits can only be accessed if the CANFD_ACFCTRL[SELMASK] = 0x1. These bits can be used to accept only either standard or extended frames with the selected ACODE / AMASK setting or to accept both frame types. Only acceptance filter 0 is affected by the power-on reset and it is configured to accept both frame types after power-up.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance filter accepts only standard frames</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance filter accepts only extended frames</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AMASK_X</name>
              <description>Acceptance MASK 3.
- AMASK_X(10-0) will be used for standard frames.
- AMASK_X(28-0) will be used for extended frames.
Disabled bits result in accepting the message. Therefore, the default configuration after reset for filter 0 accepts all messages.
Only filter 0 is affected by the power-on reset. All other filters stay uninitialized.
Refer to Section Software Reset.</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Acceptance check for these bits of receive identifier enable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Acceptance check for these bits of receive identifier disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_VER_0</name>
          <description>Version Information 0 Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x09</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VER_0</name>
              <description>Version (minor) [7-0]</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_VER_1</name>
          <description>Version Information 1 Register</description>
          <addressOffset>0xBD</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x07</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VER_1</name>
              <description>Version (major) [15-0]</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_PROT</name>
          <description>Memory Protection Register</description>
          <addressOffset>0xCA</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MAEIF</name>
              <description>Memory: Address Error Interrupt Flag.
This bit will be set if memory protection has detected an error in the address. The error was not corrected.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDEIF</name>
              <description>Memory: Data Error Interrupt Flag.
This bit will be set if memory protection has detected an error in the data which was not correctable.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDWIF</name>
              <description>Memory: Data Warning Interrupt Flag.
This bit will be set if the MDWIE bit is set and memory protection has detected an error in the data which has been automatically corrected. The system continues operation.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDWIE</name>
              <description>Memory: Data Warning Interrupt Enable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MPEN</name>
              <description>Memory Protection Enable.
This bit is only writable if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_STAT</name>
          <description>Memory Status Register</description>
          <addressOffset>0xCB</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HELOC</name>
              <description>Host Side Memory Error Location.
This bit field will be updated with every new error during a read access from the host side. This is sufficient, because read errors during read accesses from the CAN side will be signaled by the ACFA, TXS and TXB bits.
The HELOC bit field will only be updated in case of an error, but not in case of a warning caused by a corrected single bit error.</description>
              <bitRange>[4:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error during access from host side</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error during access from host side in TBUF</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Error during access from host side in RBUF</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Error during access from host side in ACF</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXB</name>
              <description>Transmission Block.
If the CANFD_MEM_PROT[MDEIF] or CANFD_MEM_PROT[MAEIF] bit is set because of an error while the CAN protocol machine is reading data for transmission, then the transmission is immediately blocked.
If the CANFD_SRCFG[SREIF] bit is set, then the transmission is immediately blocked too.
The TXB bit is reset if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission blocked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXS</name>
              <description>Transmission Stop.
If the CANFD_MEM_PROT[MDEIF] or CANFD_MEM_PROT[MAEIF] bit is set because of an error while the priority reordering machine accesses the memory, then any new transmission is stopped. If there is an active transmission, this will be completed before the stop, but if an error occurs during this transmission then no retransmission will be started.
The TXS bit is reset if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmission stopped</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACFA</name>
              <description>Acceptance Filter Accept.
If the CANFD_MEM_PROT[MDEIF] or CANFD_MEM_PROT[MAEIF] bit is set because of an error in the address range of the ACF, this bit is set. Then acceptance filtering is disabled and all frames will be accepted.
The ACFA bit can be reset similar to an interrupt flag by writing a 0x1 to it. But because it will be set while the reception is still active, it is required to reset if later after the reception has been completed and the CANFD_RTIF[RIF] bit has been set.
This bit is also reset if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal operation of ACF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACF disabled: all received frames are accepted</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_0</name>
          <description>Memory Error Stimulation 0 Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MEAEE</name>
              <description>Memory Error: Address Error Enable.
If the MEAEE = 0x1 then the address bit 2 is flipped. The result is an access to the neighbor 32 bit word. The error is only triggered for the access defined by the CANFD_MEM_ES_2[MEEEC], CANFD_MEM_ES_2[MENEC], CANFD_MEM_ES_3[MEL] bit fields and the CANFD_MEM_ES_3[MES] bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ME1EE</name>
              <description>Memory Error: 1^st Error Enable.
If ME1EE = 0x1 then the MEBP1 bit field is used to do stimulation of a single bit error. To stimulate a dual bit error, the CANFD_MEM_ES_1[MEBP2] bit field and the CANFD_MEM_ES_1[ME2EE] bit needs to be used too. The error is only triggered for the access defined by the CANFD_MEM_ES_2[MEEEC], CANFD_MEM_ES_2[MENEC], CANFD_MEM_ES_3[MEL] bit fields and the CANFD_MEM_ES_3[MES] bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEBP1</name>
              <description>Memory Error: Bit Position 1.
This bit field defines the position of one single bit error during memory read.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_1</name>
          <description>Memory Error Stimulation 1 Register</description>
          <addressOffset>0xCD</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ME2EE</name>
              <description>Memory Error: 2^nd Error Enable.
If the ME2EE = 0x1 then the MEBP2 bit field is used to do stimulation of a single bit error. The error is only triggered for the access defined by the CANFD_MEM_ES_2[MEEEC], CANFD_MEM_ES_2[MENEC], CANFD_MEM_ES_3[MEL] bit fields and the CANFD_MEM_ES_3[MES] bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEBP2</name>
              <description>Memory Error: Bit Position 2.
This bit field defines the position of one single bit error during memory read. To stimulate a dual bit error, the CANFD_MEM_ES_0[MEBP1] bit field and the CANFD_MEM_ES_0[ME1EE] bit needs to be used too.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_2</name>
          <description>Memory Error Stimulation 2 Register</description>
          <addressOffset>0xCE</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MENEC</name>
              <description>Memory Error: No Error Counter.
Error stimulation is delayed if the MEEEC bit field value &gt; 0.
The MEEEC bit field value is automatically decremented after each memory read access (defined by the CANFD_MEM_ES_3[MEL] bit field and the CANFD_MEM_ES_3[MES] bit) until it reaches the value 0x0.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEEEC</name>
              <description>Memory Error: Error Enable Counter.
Error stimulation is activated if the MENEC = 0x0 and the MEEEC bit field value &gt; 0.
This bit field is automatically decremented after each event of an error stimulation (defined by the CANFD_MEM_ES_3[MEL] bit field and the CANFD_MEM_ES_3[MES] bit) until it reaches the value 0x0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_MEM_ES_3</name>
          <description>Memory Error Stimulation 3 Register</description>
          <addressOffset>0xCF</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MES</name>
              <description>Memory Error Side.
This bit defines the side which will be hit by the next memory error together with the MEL bit field.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Host side</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CAN side</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEL</name>
              <description>Memory Error Location.
This bit field defines the memory area which will be hit by the next memory error together with the MES bit.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ACF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>TBUF</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>RBUF</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>ACF</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_SRCFG</name>
          <description>Spatial Redundancy Configuration Register</description>
          <addressOffset>0xD0</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SREEC</name>
              <description>Spatial Redundancy: Error Enable in CANFD_CLK Domain.
If the SREEC = 0x1 and SREN = 0x1, then output signal is flipped in the instance defined by the SRISEL bit. This results in a difference between the two instances which will be detected by the logic checker.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error stimulation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error stimulation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SREEH</name>
              <description>Spatial Redundancy: Error Enable in CANFD_HOST_CLK Domain.
If the SREEH = 0x1 and SREN = 0x1, then VERSION(15) is flipped in the instance defined by the SRISEL bit. As a consequence a read access to VERSION results in a difference between the two instances which will be detected by the logic checker.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No error stimulation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Error stimulation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SREIF</name>
              <description>Spatial Redundancy: Error Interrupt Flag.
If the SREN = 0x1 and if there is a severe mismatch between both instances of the logic core of the CAN controller then the SREIF and CANFD_MEM_STAT[TXB] bits will be set.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRISEL</name>
              <description>Spatial Redundancy: Instance Selection.
If the SREN= 0x0 then this bit selects the instance, that is used for operation.
The SRISEL bit can only be modified if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SREN</name>
              <description>Spatial Redundancy: Enable.
If enabled, then two instances of the logic core of the CAN controller are compared at runtime to each other. If this comparison is disabled then one of the two instances is used for operation as defined by the SRISEL bit.
This bit can only be modified if the CANFD_CFG_STAT[RESET] = 0x1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAN_CNT</name>
      <baseAddress>0x49037000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>12</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CANFD_CNTR_CTRL</name>
          <description>CANFD Counter Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>CNTR_CLEAR</name>
              <description>Clear the CANFD counter.</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CNTR_STOP</name>
              <description>Stop the CANFD counter.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CNTR_START</name>
              <description>Start the CANFD counter.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CNTR_LOW</name>
          <description>CANFD Counter Low Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTR_LO</name>
              <description>CANFD counter bits [31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CANFD_CNTR_HIGH</name>
          <description>CANFD Counter High Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTR_HI</name>
              <description>CANFD counter bits [63:32].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLKCTL_PER_MST</name>
      <baseAddress>0x4903F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>176</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CAMERA_PIXCLK_CTRL</name>
          <description>CPI Pixel Clock Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0011</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Pixel clock divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Pixel clock select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 400 MHz clock source (SYST_ACLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 480 MHz clock source (PLL_CLK3)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>Pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CDC200_PIXCLK_CTRL</name>
          <description>CDC Pixel Clock Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0011</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Pixel clock divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Pixel clock select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 400 MHz clock source (SYST_ACLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 480 MHz clock source (PLL_CLK3)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>Pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CSI_PIXCLK_CTRL</name>
          <description>CSI Pixel Clock Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FF0000</resetValue>
          <resetMask>0x01FF0011</resetMask>
          <fields>
            <field>
              <name>CLK_DIVISOR</name>
              <description>Pixel clock divisor
n: Clock divided by n</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Illegal values</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Illegal values</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Clock divided by 2</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Clock divided by 3</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Pixel clock select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select 400 MHz clock source (SYST_ACLK)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select 480 MHz clock source (PLL_CLK3)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_ENA</name>
              <description>Pixel clock enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PERIPH_CLK_ENA</name>
          <description>Peripheral Clock Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x11111113</resetMask>
          <fields>
            <field>
              <name>DSI_CKEN</name>
              <description>Enable clock for DSI</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSI_CKEN</name>
              <description>Enable clock for CSI</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USB_CKEN</name>
              <description>Enable clock for USB</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SDC_CKEN</name>
              <description>Enable clock for SDMMC</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ETH_CKEN</name>
              <description>Enable clock for ETH</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPU_CKEN</name>
              <description>Enable clock for GPU2D</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DMA_CKEN</name>
              <description>Enable clock for DMA0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPI_CKEN</name>
              <description>Enable clock for DPI controller (CDC)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPI_CKEN</name>
              <description>Enable clock for CPI</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Clock disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clock enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_CTRL0</name>
          <description>MIPI-DPHY PLL Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01331111</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_GP_CLK_EN</name>
              <description>Enable signal for CLKOUT_GP clock</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_CLKSEL</name>
              <description>CLKEXT divider selection</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_GMP_CNTRL</name>
              <description>Controls the effective loop-filter resistance (=1/gmp) to increase/decrease MPLL bandwidth</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_SHADOW_CLEAR</name>
              <description>Shadow registers clear</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_UPDATEPLL</name>
              <description>Control for PLL operation frequency updated</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_SHADOW_CONTROL</name>
              <description>Selection of PLL configuration mechanism</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_FORCE_LOCK</name>
              <description>Force lock to device</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_CTRL1</name>
          <description>MIPI-DPHY PLL Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000F3FF</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_N</name>
              <description>Control of the input frequency division ratio N (1 to 16) for device direct PLL control</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_M</name>
              <description>Control of the feedback multiplication ratio M (40 to 625) for device direct PLL control</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_CTRL2</name>
          <description>MIPI-DPHY PLL Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F7F</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_VCO_CNTRL</name>
              <description>VCO operating range for device direct PLL control</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_PROP_CNTRL</name>
              <description>Proportional charge pump control for device direct PLL control</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_INT_CNTRL</name>
              <description>Integral charge pump control for device direct PLL control</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SOC_CPBIAS_CNTRL</name>
              <description>Charge pump bias control for device direct PLL control</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_STAT0</name>
          <description>MIPI-DPHY PLL Status Register 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF3FF0311</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_N</name>
              <description>Control of the input frequency division ratio N (1 to 16) for device direct PLL control</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_M</name>
              <description>Control of the feedback multiplication ratio M (40 to 625) for device direct PLL control</description>
              <bitRange>[25:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_GMP_CNTRL</name>
              <description>Control of the effective loop-filter resistance (=1/gmp) to increase/decrease MPLL bandwidth</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_SHADOW_CONTROL</name>
              <description>Selection of PLL configuration mechanism</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_LOCK</name>
              <description>Force lock to device</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPHY_PLL_STAT1</name>
          <description>MIPI-DPHY PLL Status Register 1</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F7F</resetMask>
          <fields>
            <field>
              <name>PLL_SOC_VCO_CNTRL</name>
              <description>VCO operating range for device direct PLL control</description>
              <bitRange>[29:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_PROP_CNTRL</name>
              <description>Proportional charge pump control for device direct PLL control</description>
              <bitRange>[21:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_INT_CNTRL</name>
              <description>Integral charge pump control for device direct PLL control</description>
              <bitRange>[13:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_SOC_CPBIAS_CNTRL</name>
              <description>Charge pump bias control for device direct PLL control</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DPHY_CTRL0</name>
          <description>MIPI-DPHY TX Control Register 0</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7F311F</resetMask>
          <fields>
            <field>
              <name>CFGCLKFREQRANGE</name>
              <description>Input reference clock frequency</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSFREQRANGE</name>
              <description>Module operating frequency</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASEDIR</name>
              <description>Configures the base direction for PHY data lane 0 (bit [12]) and data lane 1 (bit [13]).</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Configures lane as TX upon startup of the PHY</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Configures lane as RX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXRXZ</name>
              <description>Selects master or slave configuration for the PHY. The configuration applies to all the PHY lanes (data and clock).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave-side D-PHY implementation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master-side D-PHY implementation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TESTPORT_SEL</name>
              <description>Test port select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select TX_TESTPORT</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select RX_TESTPORT</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONT_EN</name>
              <description>This bit places the PHY in IO continuity test mode. All other PHY control bits should be placed in their default values.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_OK</name>
              <description>BIST OK</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_DONE</name>
              <description>BIST done</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_ON</name>
              <description>BIST ON</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DPHY_CTRL1</name>
          <description>MIPI-DPHY TX Control Register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>TURNREQUEST</name>
              <description>Controls TURNREQUEST pin of DPHY (bit [6] for data lane 0; bit [7] for data lane 1)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TURNDISABLE</name>
              <description>Controls TURNDISABLE pin of DPHY (bit [4] for data lane 0; bit [5] for data lane 1)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCETXSTOPMODE</name>
              <description>Controls FORCETXSTOPMODE pin of DPHY (bit [2] for data lane 0; bit [3] for data lane 1)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCERXMODE</name>
              <description>Controls FORCERXMODE pin of DPHY (bit [0] for data lane 0; bit [1] for data lane 1)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DPHY_CTRL0</name>
          <description>MIPI-DPHY RX Control Register 0</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7F311F</resetMask>
          <fields>
            <field>
              <name>CFGCLKFREQRANGE</name>
              <description>Input reference clock frequency</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HSFREQRANGE</name>
              <description>Module operating frequency</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASEDIR</name>
              <description>Configures the base direction for PHY data lane 0 (bit [12]) and data lane 1 (bit [13]).</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Configures lane as TX upon startup of the PHY</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Configures lane as RX</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXRXZ</name>
              <description>Selects master or slave configuration for the PHY. The configuration applies to all the PHY lanes (data and clock).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Slave-side D-PHY implementation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Master-side D-PHY implementation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TESTPORT_SEL</name>
              <description>Test port select</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Select TX_TESTPORT</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Select RX_TESTPORT</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONT_EN</name>
              <description>This bit places the PHY in IO continuity test mode. All other PHY control bits should be placed in their default values.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_OK</name>
              <description>BIST OK</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_DONE</name>
              <description>BIST done</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_ON</name>
              <description>BIST ON</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DPHY_CTRL1</name>
          <description>MIPI-DPHY RX Control Register 1</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>TURNREQUEST</name>
              <description>Controls TURNREQUEST pin of DPHY (bit [6] for data lane 0; bit [7] for data lane 1)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TURNDISABLE</name>
              <description>Controls TURNDISABLE pin of DPHY (bit [4] for data lane 0; bit [5] for data lane 1)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCETXSTOPMODE</name>
              <description>Controls FORCETXSTOPMODE pin of DPHY (bit [2] for data lane 0; bit [3] for data lane 1)</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCERXMODE</name>
              <description>Controls FORCERXMODE pin of DPHY (bit [0] for data lane 0; bit [1] for data lane 1)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MIPI_CKEN</name>
          <description>MIPI-DPHY Clock Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001111</resetMask>
          <fields>
            <field>
              <name>BYPASS_CKEN</name>
              <description>Enable bypass clock for MIPI D-PHY PLL</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable bypass clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable bypass clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLLREF_CKEN</name>
              <description>Enable reference clock for MIPI D-PHY PLL</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDPHY_CKEN</name>
              <description>Enable configure clock for RX D-PHY</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXDPHY_CKEN</name>
              <description>Enable configure clock for TX D-PHY</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable clock</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_CTRL</name>
          <description>DSI Control Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000111</resetMask>
          <fields>
            <field>
              <name>DSI_EDPI_HALT</name>
              <description>DSI EDPI halt status</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLOR_MODE</name>
              <description>DSI color mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_UPD_CFG</name>
              <description>DSI update configuration</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CTRL</name>
          <description>DMA0 Boot Control Register</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>SW_RST</name>
              <description>Software reset for DMA0</description>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No reset</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Reset DMA0. This bit is self-cleared.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_MANAGER</name>
              <description>When DMA0 exits from reset, this bit controls the security state of the DMA manager thread</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Assigns DMA manager to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Assigns DMA manager to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_IRQ</name>
          <description>DMA0 Boot IRQ Non-Secure Register</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_IRQ</name>
              <description>Controls the security state of an event-interrupt resource, when DMA0 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA0 assigns event x or IRQ[x] to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA0 assigns event x or IRQ[x] to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_PERIPH</name>
          <description>DMA0 Boot Peripheral Non-Secure Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_PERIPH</name>
              <description>Controls the security state of a peripheral request interface, when DMA0 exits from reset</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>DMA0 assigns peripheral request interface x to the secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>DMA0 assigns peripheral request interface x to the non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_GLITCH_FLT</name>
          <description>DMA0 Glitch Filter Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable glitch filter for each DMA0 channel. One bit per channel.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable the glitch filter</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the glitch filter</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_CTRL0</name>
          <description>ETH Control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>RMII_CLKSEL</name>
              <description>Select RMII clock source</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>RMII clock source from ETH_REFCLK pin</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RMII clock source from internal 50 MHz PLL clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBD_FLOWCTRL_I</name>
              <description>ETH sideband flow control
When set to 0x1, instructs the MAC to transmit Pause frames in full-duplex mode. In half-duplex mode, the MAC enables the backpressure function until this bit is set to 0x0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_CLAMP_CTRL_I</name>
              <description>ETH always-ON logic reset control</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ETH always-ON logic is not in reset (resets are inactive)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ETH always-ON logic is in reset (resets are active)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PWR_ISOLATE_I</name>
              <description>Isolation cells enable
The isolation cells isolate the signals of the ETH powered-OFF domain from the always-ON domain.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Isolation cells disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Isolation cells enabled and provide required signal values to the ETH always-ON domain</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PWR_DOWN_CTRL_I</name>
              <description>ETH power down control</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power ON. The whole ETH module is powered-ON.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power OFF. All ETH blocks are powered-OFF except the always-ON logic.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_STAT0</name>
          <description>ETH Status Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>MAC_SPEED_O</name>
              <description>Indicates the MAC speed mode selected</description>
              <bitRange>[5:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>10 Mbps</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>100 Mbps</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBD_PWR_DOWN_ACK_O</name>
              <description>ETH power-down sequence acknowledge</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Power-down not acknowledged. ETH power-down sequence cannot be started.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Power-down acknowledged. ETH power-down sequence can be started.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SBD_INTR_O</name>
              <description>This bit reflects the value of the ETH_SBD_IRQ interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_PTP_TMST0</name>
          <description>ETH Timestamp Register 0</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETH_PTP_TMST</name>
              <description>ETH PTP timestamp output value - bits[31-0]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ETH_PTP_TMST1</name>
          <description>ETH Timestamp Register 1</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETH_PTP_TMST</name>
              <description>ETH PTP timestamp output value - bits[63-32]</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDC_CTRL0</name>
          <description>SDMMC Control Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>INT_TMCLK_STABLE</name>
              <description>Internal TMCLK stable
Indicates stability of internal clock to SDMMC controller</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_BCLK_STABLE</name>
              <description>Internal BCLK stable
Indicates stability of internal clock to SDMMC controller</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_ACLK_STABLE</name>
              <description>Internal ACLK stable
Indicates stability of internal clock to SDMMC controller</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_REG_VOL_STABLE</name>
              <description>Indicates stability of host regulator voltage to SDMMC controller</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDC_STAT0</name>
          <description>SDMMC Status Register 0</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>CARD_CLK_FREQ_SEL</name>
              <description>Card clock frequency select</description>
              <bitRange>[13:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>100 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>50 MHz</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>25 MHz</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>12.5 MHz</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>6.25 MHz</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x20</name>
                  <description>3.125 MHz</description>
                  <value>0x20</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x40</name>
                  <description>1.56 MHz</description>
                  <value>0x40</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x80</name>
                  <description>781.25 kHz</description>
                  <value>0x80</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x100</name>
                  <description>390.625 kHz</description>
                  <value>0x100</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x200</name>
                  <description>195.312 kHz</description>
                  <value>0x200</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_CLK_GEN_SEL</name>
              <description>Card clock generator mode</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Divided clock mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Programmable clock mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CARD_CLK_EN</name>
              <description>Card clock PLL enable</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK2CARD_ON</name>
              <description>Control to switch on clock supplied to the card</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTCLK_EN</name>
              <description>Internal clock request. When
this is 0, ACLK and BCLK can be stopped.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SDC_STAT1</name>
          <description>SDMMC Status Register 1</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>UHS1_DRV_STH</name>
              <description>UHS-I driver strength select
Host controller indicates output driver strength in 1.8-V signaling. In 3.3-V signaling, this output is not effective.</description>
              <bitRange>[6:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Driver Type B (Default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Driver Type A</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Driver Type C</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Driver Type D</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UHS1_SWVOLT_EN</name>
              <description>Switch voltage from 3.3 V to 1.8 V for UHS-I
This bit is a command to external voltage regulator to switch voltage from 3.3V to 1.8V.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>3.3-V SD card signaling</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>1.8-V SD card signaling</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_VDD1_SEL</name>
              <description>Select VDD1 voltage level for SD card/eMMC</description>
              <bitRange>[3:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>1.8V</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>3.0V</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>3.3V</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SD_VDD1_ON</name>
              <description>Switch on VDD1/VDD bus power for SD card/eMMC</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_GPIO0</name>
          <description>USB GPIO Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GP_OUT</name>
              <description>USB GPIO output</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GP_IN</name>
              <description>USB GPIO input</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_STAT0</name>
          <description>USB Status Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PME_GENERATION</name>
              <description>PME generation output</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_INTERRUPT</name>
              <description>Host legacy SMI interrupt output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HUB_VBUS_CTRL</name>
              <description>Host VBUS control output</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_SYSTEM_ERR</name>
              <description>Host system error output</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HOST_CURRENT_BELT</name>
              <description>Host current belt output</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_CTRL1</name>
          <description>USB Control Register 1</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>HOST_LEGACY_SMI_BAR_WR</name>
              <description>PCI Base Address Register (BAR) write: one clock pulse. The PCIe interface need to generate one clock pulse during PCIe BAR write.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_LEGACY_SMI_PCI_CMD_REG_WR</name>
              <description>PCI command register write: one clock pulse. The PCIe interface needs to generate one clock pulse during PCIe command register write.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_MSI_ENABLE</name>
              <description>This enables the pulse type interrupt signal (one bus clock cycle) interrupt port instead of level-sensitive interrupt. When interfacing to PCIe, this allows the user to easily map interrupt to MSI in the PCIe controller.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_PORT_POWER_CONTROL_PRESENT</name>
              <description>This bit defines the bit [3] of Capability Parameters (HCCPARAMS). This indicates whether the host controller implementation includes port power control.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Port does not have port power switches</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Port has port power switches</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOST_U2_PORT_DISABLE</name>
              <description>USB 2.0 Port Disable Control
This bit should either be static (should not change during operation) or change only once from 0x0 to 0x1 during operation and stay at 0x1 after that.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Port enabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Port disabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HOST_NUM_U2_PORT</name>
              <description>Number of USB 2.0 ports</description>
              <bitRange>[5:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HUB_PORT_PERM_ATTACH</name>
              <description>Indicates if the device attached to a downstream port is permanently attached or not</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not permanently attached</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Permanently attached</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HUB_PORT_OVERCURRENT</name>
              <description>This is the port over-current indication of the root-hub ports</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No over-current</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Over-current</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_CTRL2</name>
          <description>USB Control Register 2</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x0000017F</resetMask>
          <fields>
            <field>
              <name>POR_RST_MASK</name>
              <description>Active-high USB PHY PoR reset mask. Must be set/cleared during PHY power-down/up sequence.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PME_EN</name>
              <description>Power management enable of USB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLADJ_30MHZ_REG</name>
              <description>Frequency adjust value of USB</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPU2D</name>
      <baseAddress>0x49040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>236</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>GPU2D_IRQ</name>
        <description>GPU2D aggregated interrupt request</description>
        <value>332</value>
      </interrupt>
      <registers>
        <register>
          <name>GPU2D_CONTROL</name>
          <description>Geometry Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_LIMITERPRECISION</name>
              <description>Limiter precision is increased by 6 (10.22)</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_SPANSTORE</name>
              <description>Enable span store</description>
              <bitRange>[23:23]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_SPANABORT</name>
              <description>Enable span abort</description>
              <bitRange>[22:22]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNIONCD</name>
              <description>Combine (AB)/(56) as union</description>
              <bitRange>[21:21]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNIONAB</name>
              <description>Combine (12)/(34) as union</description>
              <bitRange>[20:20]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNION56</name>
              <description>Combine 5/6 as union (+) otherwise intersect (*)</description>
              <bitRange>[19:19]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNION34</name>
              <description>Combine 3/4 as union (+) otherwise intersect (*)</description>
              <bitRange>[18:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_UNION12</name>
              <description>Combine 1/2 as union (+) otherwise intersect (*)</description>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_BAND1ENABLE</name>
              <description>Band filter N enable
Bit 16: Band filter 2 enable
Bit 15: Band filter 1 enable</description>
              <bitRange>[16:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_LIMNTHRESHOLD</name>
              <description>Limiter N threshold enable
Bit 14: Limiter 6 threshold enable
Bit 13: Limiter 5 threshold enable
Bit 12: Limiter 4 threshold enable 
Bit 11: Limiter 3 threshold enable
Bit 10: Limiter 2 threshold enable
Bit 9: Limiter 1 threshold enable</description>
              <bitRange>[14:9]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_QUADNENABLE</name>
              <description>Quadratic coupling N enable
Bit 8: Quadratic coupling 3 enable
Bit 7: Quadratic coupling 2 enable
Bit 6: Quadratic coupling 1 enable</description>
              <bitRange>[8:6]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_LIMNENABLE</name>
              <description>Limiter N enable
Bit 5: Limiter 6 enable
Bit 4: Limiter 5 enable
Bit 3: Limiter 4 enable 
Bit 2: Limiter 3 enable
Bit 1: Limiter 2 enable
Bit 0: Limiter 1 enable</description>
              <bitRange>[5:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_STATUS</name>
          <description>Status Control Register</description>
          <alternateRegister>GPU2D_CONTROL</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_BUS_ERROR_SRC</name>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>MFB bus error</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>MTX bus error</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>MDL bus error</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_IRQ_BUS_ERROR</name>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No bus error occurred or interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Bus error interrupt triggered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_IRQ_DLIST</name>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Display list not finished or interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Display list finished interrupt triggered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_IRQ_ENUM</name>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enumeration not finished or interrupt disabled</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enumeration finished interrupt triggered</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_DLISTACTIVE</name>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Display list reader is idle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Display list reader busy, no direct access to registers</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHE_DIRTY</name>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Framebuffer cache is not dirty</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framebuffer cache is dirty, frame should not be flipped</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BUSY_WRITE</name>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Framebuffer writeback finished</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framebuffer writeback busy, framebuffer type can not be changed</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BUSY_ENUM</name>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Enumeration unit idle</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enumeration unit busy, new primitive can not be started</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_CONTROL2</name>
          <description>Surface Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_RLE_PIXEL_WIDTH</name>
              <description>Width of a texel for the RLE unit:</description>
              <bitRange>[31:30]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>1 byte per texel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>2 bytes per texel</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>3 bytes per texel</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>4 bytes per texel</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BDIA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[29:29]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BDFA</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert destination blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSIA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[28:28]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BSFA</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert source blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CLUTFORMAT</name>
              <bitRange>[27:27]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>ARGB8888 (default)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RGB565</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_COLKEY_ENABLE</name>
              <description>Enable the color keying unit.</description>
              <bitRange>[26:26]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_CLUT_ENABLE</name>
              <description>Enables the CLUT. If CLUT is not enabled for an indexed format, the index will be directly put on the internal R, G, B channels.</description>
              <bitRange>[25:25]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_RLE_ENABLE</name>
              <description>Enables the RLE unit.</description>
              <bitRange>[24:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_WRITEALPHA</name>
              <description>If bit D2C_USE_ ACB == 0:
Set the 'alpha source' for the framebuffer.
0x0: Use alpha from color2
0x1: Use source alpha (pixel coverage)
0x2: Use 0.0 as alpha 
0x3: Use alpha from framebuffer
If bit D2C_USE_ ACB == 1:
0x0: BC2A is 1. Use destination alpha from color2
0x1, 0x2, or 0x3 = BC2A is 0. Use destination alpha</description>
              <bitRange>[23:22]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_WRITEFORMAT</name>
              <description>Pixel format of the framebuffer. This includes configuring the D2C_WRITEFORMAT3 bit.
0x0: ALPHA8 (1 bpp)
0x1: RGB565 (2 bpp)
0x2: ARGB8888 (4 bpp)
0x3: ARGB4444 (2 bpp)
0x6: RGBA8888 (4 bpp)
0x7: RGBA4444 (2 bpp)</description>
              <bitRange>[21:20]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_READFORMAT</name>
              <description>Pixel format of the texture buffer. This includes configuring the D2C_READFORMAT3 and D2C_READFORMAT4 bits.
0x0: ALPHA8 (1 bpp)
0x1: RGB565 (2 bpp)
0x2: ARGB8888 and RGB888 (4 bpp)
0x3: ARGB4444 and RGB444 (2 bpp)
0x4: ARGB1555 and RGB555 (2 bpp)
0x5: AI44: 4-bit alpha, 4-bit indexed color (1 bpp)
0x6: RGBA8888 (4 bpp)
0x7: RGBA4444 (2 bpp)
0x8: RGBA5551 (2 bpp)
0x9: I8, 8-bit indexed color (1 bpp)
0xA: I4, 4-bit indexed color (2 ppb)
0xB: I2, 2-bit indexed color (4 ppb)
0xC: I1, 1-bit indexed color (8 ppb)</description>
              <bitRange>[19:18]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_TEXTUREFILTERY</name>
              <bitRange>[17:17]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No filtering on texture V-axis</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Linear filtering on texture V-axis</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_TEXTUREFILTERX</name>
              <bitRange>[16:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No filtering on texture U-axis</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Linear filtering on texture U-axis</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_TEXTURECLAMPY</name>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mask texture V-coordinate</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clamp texture V-coordinate</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_TEXTURECLAMPX</name>
              <bitRange>[14:14]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mask texture U-coordinate</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clamp texture U-coordinate</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BC2</name>
              <description>Blend color2 instead of framebuffer pixel</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use pixel from framebuffer as destination</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use color2 as destination</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BDI</name>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BDF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert destination blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSI</name>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use blend factor as specified through bit D2C_BSF</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Invert source blend factor (1-x)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BDF</name>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as destination blend factor</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as destination blend factor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSF</name>
              <bitRange>[9:9]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as source blend factor</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as source blend factor</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_WRITEFORMAT3</name>
              <description>Third bit of the framebuffer format. 
See bit D2C_WRITEFORMAT for description.</description>
              <bitRange>[8:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_BDFA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[7:7]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as destination blend factor for alpha channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as destination blend factor for alpha channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_BSFA</name>
              <description>If bit D2C_USE_ ACB == 1:</description>
              <bitRange>[6:6]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 1.0 as source blend factor for alpha channel</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use alpha as source blend factor for alpha channel</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_READFORMAT4</name>
              <description>Fourth bit of the texture buffer format. 
See bit D2C_READFORMAT for description.</description>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_READFORMAT3</name>
              <description>Third bit of the texture buffer format. 
See bit D2C_READFORMAT for description</description>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_USE_ACB</name>
              <description> (see bit D2C_WRITEFORMAT)
 (see bits D2C_BSFA, D2C_BDFA, D2C_BSIA, 
 D2C_BDIA, D2C_WRITEFORMAT)</description>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Use 'write alpha' mode</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Use full alpha channel blending mode</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_PATTERNSOURCEL5</name>
              <description>Limiter 5 is used as pattern index instead of the default U-limiter</description>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>D2C_TEXTUREENABLE</name>
              <description>Pixel source is read from texture and used as an alpha to blend between GPU2D_COLOR1 and GPU2D_COLOR2.</description>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable texture</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable texture</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_PATTERNENABLE</name>
              <description>Pixel source is a pattern color (blend of GPU2D_COLOR1 and GPU2D_COLOR2 depending on GPU2D_PATTERN and pattern index)</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable pattern</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable pattern</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_HWREVISION</name>
          <description>Hardware Version and Feature Set ID Register</description>
          <alternateRegister>GPU2D_CONTROL2</alternateRegister>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0FBE000B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALPHACHANNELBLENDING</name>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>ACB is available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HILIMITERPRECISION</name>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>QLimiter can be switched to high precision</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COLORKEY</name>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Color keying available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEXCLUT256</name>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLUT size is 256 entries</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RLEUNIT</name>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>RLE unit available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEXCLUT</name>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>CLUT vailable</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERFCOUNT</name>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Two performance counters available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXCACHE</name>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Texture cache available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FBCACHE</name>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Framebuffer cache available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DLR</name>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Display list reader available</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWDAVE</name>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Hardware GPU2D</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPU2DTYPE</name>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>GPU2D 2D-TS</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REVISIONNUMBER</name>
              <description>Reserved</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1START</name>
          <description>Geometry Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1START</name>
              <description>Start value of the 1st limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2START</name>
          <description>Geometry Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2START</name>
              <description>Start value of the 2nd limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L3START</name>
          <description>Geometry Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L3START</name>
              <description>Start value of the 3rd limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L4START</name>
          <description>Geometry Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L4START</name>
              <description>Start value of the 4th limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L5START</name>
          <description>Geometry Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L5START</name>
              <description>Start value of the 5th limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L6START</name>
          <description>Geometry Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L6START</name>
              <description>Start value of the 6th limiter. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1XADD</name>
              <description>X-axis increment (XADD) value for the 1st limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2XADD</name>
              <description>X-axis increment (XADD) value for the 2nd limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L3XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L3XADD</name>
              <description>X-axis increment (XADD) value for the 3rd limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L4XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L4XADD</name>
              <description>X-axis increment (XADD) value for the 4th limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L5XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L5XADD</name>
              <description>X-axis increment (XADD) value for the 5th limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L6XADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L6XADD</name>
              <description>X-axis increment (XADD) value for the 6th limiter. The XADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1YADD</name>
              <description>Y-axis increment (YADD) value for the 1st limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2YADD</name>
              <description>Y-axis increment (YADD) value for the 2nd limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L3YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L3YADD</name>
              <description>Y-axis increment (YADD) value for the 3rd limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L4YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L4YADD</name>
              <description>Y-axis increment (YADD) value for the 4th limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L5YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L5YADD</name>
              <description>Y-axis increment (YADD) value for the 5th limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L6YADD</name>
          <description>Geometry Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L6YADD</name>
              <description>Y-axis increment (YADD) value for the 6th limiter. The YADD value is the 16:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L1BAND</name>
          <description>Geometry Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L1BAND</name>
              <description>Limiter1 band width parameter</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_L2BAND</name>
          <description>Geometry Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2_L2BAND</name>
              <description>Limiter2 band width parameter</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_COLOR1</name>
          <description>Base Color Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLOR1_ALPHA</name>
              <description>Alpha channel of color1</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transparent</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFF</name>
                  <description>Opaque</description>
                  <value>0xFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COLOR1_RED</name>
              <description>Red channel of color1</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR1_GREEN</name>
              <description>Green channel of color1</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR1_BLUE</name>
              <description>Blue channel of color1</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_COLOR2</name>
          <description>Secondary Color Register</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLOR2_ALPHA</name>
              <description>Alpha channel of color2</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transparent</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFF</name>
                  <description>Opaque</description>
                  <value>0xFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COLOR2_RED</name>
              <description>Red channel of color2</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR2_GREEN</name>
              <description>Green channel of color2</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>COLOR2_BLUE</name>
              <description>Blue channel of color2</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PATTERN</name>
          <description>Pattern Register</description>
          <addressOffset>0x70</addressOffset>
          <size>8</size>
          <access>write-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PATTERN</name>
              <description>Bitmap of the pattern. Each bit in this field is interpreted as a reference to one of the two color registers ('0' = GPU2D_COLOR1; '1' = GPU2D_COLOR2).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_SIZE</name>
          <description>Bounding Box Dimension Register</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIZEY</name>
              <description>Height of the bounding box</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>SIZEX</name>
              <description>Width of the bounding box</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PITCH</name>
          <description>Framebuffer Pitch and Spanstore Delay Register</description>
          <addressOffset>0x7C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSD</name>
              <description>Span store delay</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>PITCH</name>
              <description>Pitch of the framebuffer. A negative width can be used to render bottom-up instead of top-down.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_ORIGIN</name>
          <description>Address of the First Pixel in Framebuffer Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ORIGIN</name>
              <description>Address of the first pixel in framebuffer.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LUSTART</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LUSTART</name>
              <description>U-limiter start value. The start value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LUXADD</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LUXADD</name>
              <description>U-limiter X-axis increment (XADD) value. The XADD value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LUYADD</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LUYADD</name>
              <description>U-limiter Y-axis increment (YADD) value. The YADD value is a 16:16 fixed-point number valid at the first pixel of the bounding box.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVSTARTI</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVSTARTI</name>
              <description>V-limiter start value, integer part.
The start value of the V-limiter is a 32:16 fixed-point number valid at the first pixel of the bounding box. 
GPU2D_LVSTARTF[LVSTARTF] is used for the fractional part.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVSTARTF</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVSTARTF</name>
              <description>V-limiter start value, fractional part.
The start value of the V-limiter is a 32:16 fixed-point number valid at the first pixel of the bounding box.
GPU2D_LVSTARTI[LVSTARTI] is used for the integer part.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVXADDI</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVXADDI</name>
              <description>V-limiter X-axis increment (XADD) value, integer part.
The XADD value for the V-limiter is the 32:16 fixed-point difference between two samples with a distance of 1 pixel along the X-axis.
GPU2D_LVYXADDF[LVXADDF] is used for the fractional part.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVYADDI</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVYADDI</name>
              <description>V-limiter Y-axis increment (YADD) value, integer part.
The YADD value for the V-limiter is the 32:16 fixed-point difference between two samples with a distance of 1 pixel along the Y-axis.
GPU2D_LVYXADDF[LVYADDF] is used for the fractional part.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_LVYXADDF</name>
          <description>Texture Mapping Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVYADDF</name>
              <description>V-limiter YADD, fractional part.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>LVXADDF</name>
              <description>V-limiter XADD, fractional part.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXPITCH</name>
          <description>Texels per Texture Line Register</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXPITCH</name>
              <description>Texels per texture line.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXMASK</name>
          <description>U/V Texture Mask Register</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXUMASK</name>
              <description>V mask</description>
              <bitRange>[31:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>TEXVMASK</name>
              <description>U mask</description>
              <bitRange>[10:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXORIGIN</name>
          <description>Texture Base Address Register</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXORIGIN</name>
              <description>Texture base address</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_IRQCTL</name>
          <description>Interrupt Control Register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2IRQCTL_CLR_BUS_ERROR</name>
              <bitRange>[5:5]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Leave bus error interrupt untouched</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear bus error interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_ENABLE_BUS_ERROR</name>
              <bitRange>[4:4]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable bus error interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable bus error interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_CLR_FINISH_DLIST</name>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Leave display list interrupt untouched</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear display list interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_CLR_FINISH_ENUM</name>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Leave enumeration interrupt untouched</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Clear enumeration interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_ENABLE_FINISH_DLIST</name>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable display list finished interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable display list finished interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2IRQCTL_ENABLE_FINISH_ENUM</name>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable enumeration finished interrupt</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable enumeration finished interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_CACHECTL</name>
          <description>Cache Control Register</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D2C_CACHECTL_FLUSH_TX</name>
              <bitRange>[3:3]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not flush the texture cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flush the texture cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHECTL_ENABLE_TX</name>
              <bitRange>[2:2]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable the texture cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the texture cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHECTL_FLUSH_FB</name>
              <bitRange>[1:1]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Do not flush the framebuffer cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Flush the framebuffer cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>D2C_CACHECTL_ENABLE_FB</name>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable the framebuffer cache</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable the framebuffer cache</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_DLISTSTART</name>
          <description>Display List Start Address Register</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLISTSTART</name>
              <description>Display list start address
Setting a new display list base address triggers execution of the new display list.
Note that once the display list is started, the display list reader is the master for all register writes to the core. No register write must be done via the slave bus as long as the display list execution is ongoing. Otherwise, commands from the display list may be lost and rendering artifacts as well as core hangups can occur.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PERFCOUNT1</name>
          <description>Performance Counter 1 Register</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERFCOUNT1</name>
              <description>Performance counter 1 value. GPU2D will increment the counter on every event selected by GPU2D_PERFTRIGGER[PERFTRIGGER1].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PERFCOUNT2</name>
          <description>Performance Counter 2 Register</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERFCOUNT2</name>
              <description>Performance counter 2 value. GPU2D will increment the counter on every event selected by GPU2D_PERFTRIGGER[PERFTRIGGER2].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_PERFTRIGGER</name>
          <description>Performance Counter Control Register</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERFTRIGGER2</name>
              <description>Select the internal event that will increment GPU2D_PERFCOUNT2 register.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable performance counter (D2PC_NONE)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GPU2D active cycles (D2PC_DAVECYCLES)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Framebuffer read access (D2PC_FBREADS)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Framebuffer write access (D2PC_FBWRITES)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Texture read access (D2PC_TXREADS)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Invisible pixels (enumerated but selected with alpha 0%) (D2PC_INVPIXELS)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Invisible pixels while internal fifo is empty (lost cycles) (D2PC_INVPIXELS_MISS)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Display list reader active cycles (D2PC_DLRCYCLES)</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Framebuffer read hits (D2PC_FBREADHITS)</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Framebuffer read misses (D2PC_FBREADMISSES)</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Framebuffer write hits (D2PC_FBWRITEMISSES)</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Framebuffer write misses (D2PC_FBWRITEMISSES) </description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Texture read hits (D2PC_TEXREADHITS)</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Texture read misses (D2PC_TEXREADMISSES)</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>RLE rewind count (D2PC_RLEREWIND)</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Every clock cycle (D2PC_CLKCYCLES)</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PERFTRIGGER1</name>
              <description>Select the internal event that will increment GPU2D_PERFCOUNT1 register.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable performance counter (D2PC_NONE)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>GPU2D active cycles (D2PC_DAVECYCLES)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Framebuffer read access (D2PC_FBREADS)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Framebuffer write access (D2PC_FBWRITES)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>Texture read access (D2PC_TXREADS)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>Invisible pixels (enumerated but selected with alpha 0%) (D2PC_INVPIXELS)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>Invisible pixels while internal fifo is empty (lost cycles) (D2PC_INVPIXELS_MISS)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>Display list reader active cycles (D2PC_DLRCYCLES)</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>Framebuffer read hits (D2PC_FBREADHITS)</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>Framebuffer read misses (D2PC_FBREADMISSES)</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>Framebuffer write hits (D2PC_FBWRITEMISSES)</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>Framebuffer write misses (D2PC_FBWRITEMISSES) </description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>Texture read hits (D2PC_TEXREADHITS)</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>Texture read misses (D2PC_TEXREADMISSES)</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>RLE rewind count (D2PC_RLEREWIND)</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>Every clock cycle (D2PC_CLKCYCLES)</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT</name>
          <description>CLUT Index Texture Format Register</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_INDEX</name>
              <description>Index of CLUT entry to write.</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>CLUT_ENTRY</name>
              <description>RGB888 CLUT entry.</description>
              <bitRange>[23:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT_ADDR</name>
          <description>CLUT Write Address Register</description>
          <addressOffset>0xDC</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_ADDR</name>
              <description>CLUT write address</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT_DATA</name>
          <description>CLUT Write Data Register</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_DATA</name>
              <description>For ARGB8888 format:
- Bits 31-0: CLUT data
For RGB565 format:
- Bits 31-16: CLUT data for (index x 2) + 1
- Bits 15-0: CLUT data for index x 2</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_TEXCLUT_OFFSET</name>
          <description>CLUT Offset Access for Index of Texture Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLUT_OFFSET</name>
              <description>CLUT offset</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPU2D_COLKEY</name>
          <description>Color Keying Register</description>
          <addressOffset>0xE8</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COLORKEY</name>
              <description>RGB888 color value for color keying.</description>
              <bitRange>[23:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DMA1_SEC">
      <name>DMA0_SEC</name>
      <baseAddress>0x49080000</baseAddress>
      <interrupt>
        <name>DMA0_IRQ0</name>
        <description>Interrupt request 0. One per DMA request interface (32 in total).</description>
        <value>299</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ1</name>
        <description>Interrupt request 1. One per DMA request interface (32 in total).</description>
        <value>300</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ10</name>
        <description>Interrupt request 10. One per DMA request interface (32 in total).</description>
        <value>309</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ11</name>
        <description>Interrupt request 11. One per DMA request interface (32 in total).</description>
        <value>310</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ12</name>
        <description>Interrupt request 12. One per DMA request interface (32 in total).</description>
        <value>311</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ13</name>
        <description>Interrupt request 13. One per DMA request interface (32 in total).</description>
        <value>312</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ14</name>
        <description>Interrupt request 14. One per DMA request interface (32 in total).</description>
        <value>313</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ15</name>
        <description>Interrupt request 15. One per DMA request interface (32 in total).</description>
        <value>314</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ16</name>
        <description>Interrupt request 16. One per DMA request interface (32 in total).</description>
        <value>315</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ17</name>
        <description>Interrupt request 17. One per DMA request interface (32 in total).</description>
        <value>316</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ18</name>
        <description>Interrupt request 18. One per DMA request interface (32 in total).</description>
        <value>317</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ19</name>
        <description>Interrupt request 19. One per DMA request interface (32 in total).</description>
        <value>318</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ2</name>
        <description>Interrupt request 2. One per DMA request interface (32 in total).</description>
        <value>301</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ20</name>
        <description>Interrupt request 20. One per DMA request interface (32 in total).</description>
        <value>319</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ21</name>
        <description>Interrupt request 21. One per DMA request interface (32 in total).</description>
        <value>320</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ22</name>
        <description>Interrupt request 22. One per DMA request interface (32 in total).</description>
        <value>321</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ23</name>
        <description>Interrupt request 23. One per DMA request interface (32 in total).</description>
        <value>322</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ24</name>
        <description>Interrupt request 24. One per DMA request interface (32 in total).</description>
        <value>323</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ25</name>
        <description>Interrupt request 25. One per DMA request interface (32 in total).</description>
        <value>324</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ26</name>
        <description>Interrupt request 26. One per DMA request interface (32 in total).</description>
        <value>325</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ27</name>
        <description>Interrupt request 27. One per DMA request interface (32 in total).</description>
        <value>326</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ28</name>
        <description>Interrupt request 28. One per DMA request interface (32 in total).</description>
        <value>327</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ29</name>
        <description>Interrupt request 29. One per DMA request interface (32 in total).</description>
        <value>328</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ3</name>
        <description>Interrupt request 3. One per DMA request interface (32 in total).</description>
        <value>302</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ30</name>
        <description>Interrupt request 30. One per DMA request interface (32 in total).</description>
        <value>329</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ31</name>
        <description>Interrupt request 31. One per DMA request interface (32 in total).</description>
        <value>330</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ4</name>
        <description>Interrupt request 4. One per DMA request interface (32 in total).</description>
        <value>303</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ5</name>
        <description>Interrupt request 5. One per DMA request interface (32 in total).</description>
        <value>304</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ6</name>
        <description>Interrupt request 6. One per DMA request interface (32 in total).</description>
        <value>305</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ7</name>
        <description>Interrupt request 7. One per DMA request interface (32 in total).</description>
        <value>306</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ8</name>
        <description>Interrupt request 8. One per DMA request interface (32 in total).</description>
        <value>307</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ9</name>
        <description>Interrupt request 9. One per DMA request interface (32 in total).</description>
        <value>308</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ_ABORT</name>
        <description>DMAC aborted execution of a program thread.</description>
        <value>331</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="DMA1_SEC">
      <name>DMA0_NS</name>
      <baseAddress>0x490A0000</baseAddress>
      <interrupt>
        <name>DMA0_IRQ0</name>
        <description>Interrupt request 0. One per DMA request interface (32 in total).</description>
        <value>299</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ1</name>
        <description>Interrupt request 1. One per DMA request interface (32 in total).</description>
        <value>300</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ10</name>
        <description>Interrupt request 10. One per DMA request interface (32 in total).</description>
        <value>309</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ11</name>
        <description>Interrupt request 11. One per DMA request interface (32 in total).</description>
        <value>310</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ12</name>
        <description>Interrupt request 12. One per DMA request interface (32 in total).</description>
        <value>311</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ13</name>
        <description>Interrupt request 13. One per DMA request interface (32 in total).</description>
        <value>312</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ14</name>
        <description>Interrupt request 14. One per DMA request interface (32 in total).</description>
        <value>313</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ15</name>
        <description>Interrupt request 15. One per DMA request interface (32 in total).</description>
        <value>314</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ16</name>
        <description>Interrupt request 16. One per DMA request interface (32 in total).</description>
        <value>315</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ17</name>
        <description>Interrupt request 17. One per DMA request interface (32 in total).</description>
        <value>316</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ18</name>
        <description>Interrupt request 18. One per DMA request interface (32 in total).</description>
        <value>317</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ19</name>
        <description>Interrupt request 19. One per DMA request interface (32 in total).</description>
        <value>318</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ2</name>
        <description>Interrupt request 2. One per DMA request interface (32 in total).</description>
        <value>301</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ20</name>
        <description>Interrupt request 20. One per DMA request interface (32 in total).</description>
        <value>319</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ21</name>
        <description>Interrupt request 21. One per DMA request interface (32 in total).</description>
        <value>320</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ22</name>
        <description>Interrupt request 22. One per DMA request interface (32 in total).</description>
        <value>321</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ23</name>
        <description>Interrupt request 23. One per DMA request interface (32 in total).</description>
        <value>322</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ24</name>
        <description>Interrupt request 24. One per DMA request interface (32 in total).</description>
        <value>323</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ25</name>
        <description>Interrupt request 25. One per DMA request interface (32 in total).</description>
        <value>324</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ26</name>
        <description>Interrupt request 26. One per DMA request interface (32 in total).</description>
        <value>325</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ27</name>
        <description>Interrupt request 27. One per DMA request interface (32 in total).</description>
        <value>326</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ28</name>
        <description>Interrupt request 28. One per DMA request interface (32 in total).</description>
        <value>327</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ29</name>
        <description>Interrupt request 29. One per DMA request interface (32 in total).</description>
        <value>328</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ3</name>
        <description>Interrupt request 3. One per DMA request interface (32 in total).</description>
        <value>302</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ30</name>
        <description>Interrupt request 30. One per DMA request interface (32 in total).</description>
        <value>329</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ31</name>
        <description>Interrupt request 31. One per DMA request interface (32 in total).</description>
        <value>330</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ4</name>
        <description>Interrupt request 4. One per DMA request interface (32 in total).</description>
        <value>303</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ5</name>
        <description>Interrupt request 5. One per DMA request interface (32 in total).</description>
        <value>304</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ6</name>
        <description>Interrupt request 6. One per DMA request interface (32 in total).</description>
        <value>305</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ7</name>
        <description>Interrupt request 7. One per DMA request interface (32 in total).</description>
        <value>306</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ8</name>
        <description>Interrupt request 8. One per DMA request interface (32 in total).</description>
        <value>307</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ9</name>
        <description>Interrupt request 9. One per DMA request interface (32 in total).</description>
        <value>308</value>
      </interrupt>
      <interrupt>
        <name>DMA0_IRQ_ABORT</name>
        <description>DMAC aborted execution of a program thread.</description>
        <value>331</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>OSPI0</name>
      <groupName>OSPI</groupName>
      <baseAddress>0x83000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>272</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>OSPI0_IRQ</name>
        <description>Combined interrupt request from OSPI0 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</description>
        <value>96</value>
      </interrupt>
      <registers>
        <register>
          <name>OSPI_CTRLR0</name>
          <description>OSPI Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00C04407</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_HYPERBUS_EN</name>
              <description>SPI HyperBus Frame Format Enable.
Selects if data frame format for Transmitting/Receiving data is in HyperBus mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disable HyperBus format.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enable HyperBus format.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI_FRF</name>
              <description>SPI Frame Format
Selects data frame format for Transmitting/Receiving the data. </description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Standard SPI format</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dual SPI format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Quad SPI format</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Octal SPI format</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSTE</name>
              <description>Slave Select Toggle Enable.
While operating in SPI mode with SCPH set to 0, this bit controls the behavior of the slave select line between data frames.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>The slave select line will stay low and OSPI_SCLK will run continuously for the duration of the transfer.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>The slave select line will toggle between consecutive data frames, with the serial clock (OSPI_SCLK) being held to its default value while the slave select line is high.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRL</name>
              <description>Shift Register Loop.
Used for testing purposes only. When internally active, connects the transmit shift register output to the receive shift register input. </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Normal mode operation</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Test mode operation</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TMOD</name>
              <description>Transfer Mode.
Selects the mode of transfer for serial communication. This field does not affect the transfer duplicity. Only indicates whether the receive or transmit data are valid.
In Transmit Only mode, data received from the external device is not valid and is not stored in the receive FIFO memory; it is overwritten on the next transfer.
In Receive Only mode, transmitted data are not valid. After the first write to the transmit FIFO, the same word is retransmitted for the duration of the transfer.
In transmit-and-receive mode, both transmit and receive data are valid. The transfer continues until the transmit FIFO is empty. Data received from the external device are stored into the receive FIFO memory, where it can be accessed by the host processor.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit and Receive; Not Applicable in enhanced SPI operating mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit Only mode; Or Write in enhanced SPI operating mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Receive Only mode; Or Read in enhanced SPI operating mode.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>EEPROM Read mode; Not Applicable in enhanced SPI operating mode.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPOL</name>
              <description>Serial Clock Polarity.
 Used to select the polarity of the inactive serial clock, which is held inactive when the OSPI master is not actively transferring data on the serial bus.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Inactive state of serial clock is low.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Inactive state of serial clock is high.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCPH</name>
              <description>Serial Clock Phase.
 The serial clock phase selects the relationship of the serial clock with the slave select signal.
When SCPH = 0, data are captured on the first edge of the serial clock. 
When SCPH = 1, the serial clock starts toggling one cycle after the slave select line is activated, and data are captured on the second edge of the serial clock.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Serial clock toggles in middle of first bit.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Serial clock toggles at start of first bit.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>Frame Format.
Selects which serial protocol transfers the data.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Motorola SPI Frame Format</description>
                  <value>0x0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFS</name>
              <description>Data Frame Size.
Selects the data frame length. When the data frame size is programmed to be less than 32-bits, the receive data is automatically right-justified by the receive logic, with the upper bits of the receive FIFO zero-padded.
Software must right-justify transmit data before writing into the transmit FIFO. The transmit logic ignores the upper unused bits when transmitting the data.
Note: The DFS value must be, multiple of 2 if SPI_FRF = 0x1, multiple of 4 if SPI_FRF = 0x2, and multiple of 8 if SPI_FRF = 0x3.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>04-bit serial data transfer</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>05-bit serial data transfer</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>06-bit serial data transfer</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>07-bit serial data transfer</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>08-bit serial data transfer</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>09-bit serial data transfer</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>10-bit serial data transfer</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>11-bit serial data transfer</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>12-bit serial data transfer</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>13-bit serial data transfer</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>14-bit serial data transfer</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>15-bit serial data transfer</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>16-bit serial data transfer</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>17-bit serial data transfer</description>
                  <value>0x10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x11</name>
                  <description>18-bit serial data transfer</description>
                  <value>0x11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x12</name>
                  <description>19-bit serial data transfer</description>
                  <value>0x12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x13</name>
                  <description>20-bit serial data transfer</description>
                  <value>0x13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x14</name>
                  <description>21-bit serial data transfer</description>
                  <value>0x14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x15</name>
                  <description>22-bit serial data transfer</description>
                  <value>0x15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x16</name>
                  <description>23-bit serial data transfer</description>
                  <value>0x16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x17</name>
                  <description>24-bit serial data transfer</description>
                  <value>0x17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x18</name>
                  <description>25-bit serial data transfer</description>
                  <value>0x18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x19</name>
                  <description>26-bit serial data transfer</description>
                  <value>0x19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1A</name>
                  <description>27-bit serial data transfer</description>
                  <value>0x1A</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1B</name>
                  <description>28-bit serial data transfer</description>
                  <value>0x1B</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1C</name>
                  <description>29-bit serial data transfer</description>
                  <value>0x1C</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1D</name>
                  <description>30-bit serial data transfer</description>
                  <value>0x1D</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1E</name>
                  <description>31-bit serial data transfer</description>
                  <value>0x1E</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1F</name>
                  <description>32-bit serial data transfer</description>
                  <value>0x1F</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SPI_CTRLR1</name>
          <description>OSPI Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NDF</name>
              <description>Number of Data Frames.
When OSPI_CTRLR0[TMOD] = 0x2 or 0x3, this bit field sets the number of data frames to be continuously received by the OSPI. The OSPI continues to receive serial data until the number of data frames received is equal to this register value plus 1, which enables to receive up to 64KB of data in a continuous transfer.
When OSPI_CTRLR0[TMOD] = 0x1, this bit field sets the number of data frames to be continuously transmitted by OSPI. If the Transmit FIFO goes empty in-between, OSPI masks the serial clock (OSPI_SCLK) and waits for rest of the data until the programmed amount of frames are transferred successfully.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_ENR</name>
          <description>OSPI Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPI_EN</name>
              <description>OSPI Enable.
Enables or disables all OSPI operations. When disabled, all serial transfers are halted immediately. Transmit and receive FIFO buffers are cleared when the device is disabled. It is impossible to program some of the OSPI control registers when enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Disables OSPI</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Enables OSPI</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SER</name>
          <description>OSPI Slave Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SER</name>
              <description>Slave Select Enable Flag.
Each bit of this bit field corresponds to the slave select line from the OSPI master. When a bit in this bit field is set (0x1), the slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this bit field have no effect on the corresponding slave select output until a transfer is started. Before beginning a transfer, the respective bit in this bit field should be enabled depending which slave select line is desired.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_BAUDR</name>
          <description>OSPI Baud Rate Select Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCKDV</name>
              <description>OSPI Clock Divider.
This field contains the MSB 15 bits of the 16-bit SPI_CLK divider value. The LSB for this bit field is always set to 0 and is unaffected by a write operation, which ensures the divider is always set to an even value. If this field is set to all 0s, the serial output clock (OSPI_SCLK) is disabled. The frequency of the OSPI_SCLK is derived from the following equation:
FOSPI_SCLK = FOSPI_CLK/BAUDR
Where BAUDR is any even value between 2 and 65534, and BAUDR = SCKDV x 2. For example, for FOSPI_CLK = 3.6864 MHz and SCKDV = 1b'1:
 BAUDR = 2 and FOSPI_SCLK = 3.6864/2 = 1.8432 MHz</description>
              <bitRange>[15:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_TXFTLR</name>
          <description>OSPI Transmit FIFO Threshold Level Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFTHR</name>
              <description>Transfer Start FIFO Level.
Used to control the level of entries in transmit FIFO above which transfer will start on serial line. This bit field is used to ensure that sufficient data is present in transmit FIFO before starting a write operation on serial line.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TFT</name>
              <description>Transmit FIFO Threshold.
Controls the level of entries (or below) at which the transmit FIFO controller triggers an interrupt. The FIFO depth is 256. If the value in this bit field is greater than or equal to the depth of the FIFO, this bit field is not written and retains its current value. When the number of transmit FIFO entries is less than or equal to this value, the transmit FIFO empty interrupt is triggered.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXFTLR</name>
          <description>OSPI Receive FIFO Threshold Level Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFT</name>
              <description>Receive FIFO Threshold.
Controls the level of entries (or above) at which the receive FIFO controller triggers an interrupt. The FIFO depth is 256. If the value in this bit field is greater than the depth of the FIFO, this bit field is not written and retains its current value. When the number of receive FIFO entries is greater than or equal to this value + 1, the receive FIFO full interrupt is triggered.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_TXFLR</name>
          <description>OSPI Transmit FIFO Level Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXTFL</name>
              <description>Transmit FIFO Level.
Contains the number of valid data entries in the transmit FIFO.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXFLR</name>
          <description>OSPI Receive FIFO Level Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXTFL</name>
              <description>Receive FIFO Level.
Contains the number of valid data entries in the receive FIFO.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SR</name>
          <description>OSPI Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPLTD_DF</name>
              <description>Completed Data Frames.
This bit field indicates total data frames transferred in the previous internal DMA transfer.</description>
              <bitRange>[31:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RFF</name>
              <description>Receive FIFO Full.
When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is not full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RFNE</name>
              <description>Receive FIFO Not Empty.
Set when the receive FIFO contains one or more entries and is cleared when the receive FIFO is empty. This bit can be polled by software to completely empty the receive FIFO.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO is empty.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO is not empty.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit FIFO Empty.
When the transmit FIFO is completely empty, this bit is set. When the transmit FIFO contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is not empty.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is empty.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TFNF</name>
              <description>Transmit FIFO Not Full.
Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO is full.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO is not full.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>OSPI Busy Flag.
When set, indicates that a serial transfer is in progress; when cleared indicates that the OSPI is idle or disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>OSPI is idle or disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>OSPI is actively transferring data.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_IMR</name>
          <description>OSPI Interrupt Mask Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXUIM</name>
              <description>Transmit FIFO Underflow Interrupt Mask</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Underflow interrupt is masked</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Underflow interrupt is not masked</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIM</name>
              <description>Receive FIFO Full Interrupt Mask</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIM</name>
              <description>Receive FIFO Overflow Interrupt Mask</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIM</name>
              <description>Receive FIFO Underflow Interrupt Mask</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIM</name>
              <description>Transmit FIFO Overflow Interrupt Mask</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIM</name>
              <description>Transmit FIFO Empty Interrupt Mask</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is not masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_ISR</name>
          <description>OSPI Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXUIS</name>
              <description>Transmit FIFO Underflow Interrupt Status</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Underflow interrupt is not active after masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Underflow interrupt is active after masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIS</name>
              <description>Receive FIFO Full Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIS</name>
              <description>Receive FIFO Overflow Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIS</name>
              <description>Receive FIFO Underflow Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIS</name>
              <description>Transmit FIFO Overflow Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIS</name>
              <description>Transmit FIFO Empty Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active after masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active after masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RISR</name>
          <description>OSPI Raw Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXUIR</name>
              <description>Transmit FIFO Underflow Interrupt Raw Status</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Underflow interrupt is not active prior masking</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Underflow interrupt is active prior to masking</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXFIR</name>
              <description>Receive FIFO Full Raw Interrupt Status.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Full interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Full interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXOIR</name>
              <description>Receive FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Overflow interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Overflow interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXUIR</name>
              <description>Receive FIFO Underflow Raw Interrupt Status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive FIFO Underflow interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive FIFO Underflow interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXOIR</name>
              <description>Transmit FIFO Overflow Raw Interrupt Status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Overflow interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Overflow interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXEIR</name>
              <description>Transmit FIFO Empty Raw Interrupt Status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit FIFO Empty interrupt is not active prior masking.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit FIFO Empty interrupt is active prior to masking.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_TXEICR</name>
          <description>OSPI Transmit FIFO Error Interrupt Clear Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXEICR</name>
              <description>Clear Transmit FIFO Overflow/Underflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Transmit FIFO Overflow/Underflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXOICR</name>
          <description>OSPI Receive FIFO Overflow Interrupt Clear Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOICR</name>
              <description>Clear Receive FIFO Overflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Overflow interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RXUICR</name>
          <description>OSPI Receive FIFO Underflow Interrupt Clear Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUICR</name>
              <description>Clear Receive FIFO Underflow Interrupt.
This bit reflects the status of the interrupt. A read from this bit clears the Receive FIFO Underflow
 interrupt; writing has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_ICR</name>
          <description>OSPI Interrupt Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ICR</name>
              <description>Clear Interrupts.
This bit is set if any of the interrupts below are active. A read clears the Transmit FIFO Underflow, Transmit FIFO Overflow, Receive FIFO Underflow, and Receive FIFO Overflow interrupts. Writing to this bit has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DMACR</name>
          <description>OSPI DMA Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDMAE</name>
              <description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Transmit DMA disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Transmit DMA enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RDMAE</name>
              <description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Receive DMA disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Receive DMA enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DMATDLR</name>
          <description>OSPI DMA Transmit Data Level Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMATDL</name>
              <description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the Watermark Level; that is, the OSPI_DMA_TX_REQ signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and OSPI_DMACR[TDMAE] = 1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DMARDLR</name>
          <description>OSPI DMA Receive Data Level Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMARDL</name>
              <description>Receive Data Level.
 This bit field controls the level at which a DMA request is made by the receive logic. The Watermark Level is equal to OSPI_DMARDLR[DMARDL] + 1; that is, OSPI_DMA_RX_REQ is generated when the number of valid data entries in the receive FIFO is equal to or above this field value + 1, and OSPI_DMACR[RDMAE] = 1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_IDR</name>
          <description>Identification Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xC7C5C7C5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDCODE</name>
              <description>Identification code</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_VERSION_ID</name>
          <description>Version ID Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3130332A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSPI_COMP_VERSION</name>
              <description>Component version</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>36</dim>
          <dimIncrement>4</dimIncrement>
          <name>OSPI_DR[%s]</name>
          <description>OSPI Data Register (n)</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DR</name>
              <description>Data Register (n). When writing to this register, the data must be right-justified. Read data are automatically right-justified.
Read = Receive FIFO buffer
Write = Transmit FIFO buffer</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_RX_SAMPLE_DELAY</name>
          <description>OSPI RX Sample Delay Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SE</name>
              <description>RXD Sampling Edge. 
This bit is used to decide the sampling edge for RXD signal with OSPI_CLK. Then this bit is set to 1 then negative edge of OSPI_CLK will be used to sample the incoming data, otherwise positive edge will be used for sampling.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSD</name>
              <description>RXD Sample Delay. 
This bit field is used to delay the sample of the RXD input port. Each valuere presents a single OSPI_CLK delay on the sample of RXD.
Note: If this bit is programmed with a value that exceeds the depth of the internal shift registers (internal shift register depth = 4) zero delay will be applied to the RXD sample.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_SPI_CTRLR0</name>
          <description>OSPI SPI Control Register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XIP_PREFETCH_EN</name>
              <description>Enables XIP Pre-fetch functionality in OSPI. 
Once enabled OSPI will pre-fetch data frames from next contiguous location, to reduce the latency for the upcoming contiguous transfer. If the next XIP request is not contiguous then pre-fetched bits will be discarded.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_MBL</name>
              <description>XIP Mode Bits Length. 
Sets the length of Mode bits in XIP mode of operation. These bits are valid only when OSPI_SPI_CTRLR0[XIP_MD_BIT_EN] is set to 1.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mode bits length equal to 2.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Mode bits length equal to 4.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Mode bits length equal to 8.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Mode bits length equal to 16.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPI_RXDS_SIG_EN</name>
              <description>Enable RXDS Signaling during address and command phase of HyperBus transfer.
This bit enables RXDS signaling by HyperBus slave devices during Command-Address (CA) phase. If the RXDS signal is set to 1 during the CA phase of transfer, OSPI transmits [2 x OSPI_SPI_CTRLR0[WAIT_CYCLES]) - 1] wait cycles after the address phase is complete.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DM_EN</name>
              <description>SPI Data Mask Enable bit.
When this bit is enabled, the TXD_DM signal is used to mask the data on the TXD data line.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OSPI_XIP_CONT_XFER_EN</name>
              <description>Enable Continuous Transfer in XIP mode.
 If this bit is set to 1 then continuous transfer mode in XIP is enabled, in this mode OSPI keeps the slave selected until a non-XIP transfer is detected on the AHB interface.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_INST_EN</name>
              <description>XIP Instruction Enable bit. 
If this bit is set to 1 then XIP transfers also have an instruction phase. The instruction opcodes can be chosen from OSPI_XIP_INCR_INST or OSPI_XIP_WRAP_INST registers bases on AHB transfer type.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_DFS_HC</name>
              <description>Fix DFS for XIP transfers.
 If this bit is set to 1 then data frame size for XIP transfers is fixed to the programmed value in OSPI_CTRLR0[DFS] bit field. The number of data frames to fetch is determined by transfer size and burst type signals. If this bit is set to 0 then data frame size and number of data frames to fetch are both determined by transfer size and burst type signals.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_RXDS_EN</name>
              <description>Read Data Strobe Enable bit.
Once this bit is set to 1 OSPI uses Read data strobe (RXDS) to capture read data in DDR mode.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_DDR_EN</name>
              <description>Instruction DDR Enable bit. 
This bit enables Dual Data-Rate transfer for instruction phase.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DDR_EN</name>
              <description>SPI DDR Enable bit. 
This bit enables Dual Data-Rate transfers in Dual/Quad/Octal frame formats of SPI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAIT_CYCLES</name>
              <description>Wait cycles in Dual/Quad/Octal mode between control frames transmission and data reception. Specified as number of SPI clock cycles.</description>
              <bitRange>[15:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_L</name>
              <description>Dual/Quad/Octal mode instruction length in bits.
Note: For enhanced SPI modes, INST_L and ADDR_L cannot be both programmed to 0x0 at the same time.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Instruction.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit instruction length.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit instruction length.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16-bit instruction length.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XIP_MD_BIT_EN</name>
              <description>Mode bits enable in XIP mode.
 If this bit is set to 0x1, then in XIP mode of operation OSPI inserts Mode bits after the address phase. These bits are set in register OSPI_XIP_MODE_BITS register. The length of Mode bits defaults to 8-bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDR_L</name>
              <description>This bit defines Length of Address to be transmitted. Only after this much bits are programmed in to the FIFO the transfer can begin.
Note: For enhanced SPI modes, INST_L and ADDR_L cannot be both programmed to 0x0 at the same time.</description>
              <bitRange>[5:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No address</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit address length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit address length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>12-bit address length</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>16-bit address length</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>20-bit address length</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>24-bit address length</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>28-bit address length</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>32-bit address length</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>36-bit address length</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>40-bit address length</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>44-bit address length</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>48-bit address length</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>52-bit address length</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>56-bit address length</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>60-bit address length</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRANS_TYPE</name>
              <description>Address and Instruction Transfer format.
Selects whether OSPI will transmit instruction/address either in Standard SPI mode or the SPI mode selected in the OSPI_CTRLR0[SPI_FRF] bit field.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction and Address will be sent in Standard SPI Mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction will be sent in Standard SPI Mode and Address will be sent in the mode specified by the OSPI_CTRLR0[SPI_FRF] bit field.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Both Instruction and Address will be sent in the mode specified by OSPI_CTRLR0[SPI_FRF] bit field.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_DDR_DRIVE_EDGE</name>
          <description>OSPI Transmit Drive Edge Register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDE</name>
              <description>TXD Drive Edge register which decided the driving edge of transmit data.
The maximum value of this bit field is equal to [(BAUDR/2) - 1].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_MODE_BITS</name>
          <description>OSPI XIP Mode Bits Register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XIP_MD_BITS</name>
              <description>XIP Mode bits to be sent after address phase of XIP transfer.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_INCR_INST</name>
          <description>OSPI XIP INCR Transfer Opcode Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCR_INST</name>
              <description>XIP INCR transfer opcode. 
When OSPI_SPI_CTRLR0[XIP_INST_EN] bit is set to 1, OSPI sends instruction for all XIP transfers, this register field stores the instruction opcode to be sent when an INCR type transfer is requested on AHB bus. The number of bits to be send in instruction phase is determined by the OSPI_SPI_CTRLR0[INST_L] bit field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_WRAP_INST</name>
          <description>OSPI XIP WRAP Transfer Opcode Register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRAP_INST</name>
              <description>XIP WRAP transfer opcode. 
When OSPI_SPI_CTRLR0[XIP_INST_EN] bit is set to 1, OSPI sends instruction for all XIP transfers, this register field stores the instruction opcode to be sent when an WRAP type transfer is requested on AHB bus. The number of bits to be send in instruction phase is determined by the OSPI_SPI_CTRLR0[INST_L] bit field.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_CTRL</name>
          <description>OSPI XIP Control Register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08000401</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XIP_PREFETCH_EN</name>
              <description>Enables XIP Pre-fetch functionality in OSPI. Once enabled OSPI will pre-fetch data frames from next contiguous location, to reduce the latency for the upcoming contiguous transfer. If the next XIP request is not contiguous then pre-fetched bits will be discarded.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_MBL</name>
              <description>XIP Mode Bits Length. 
Sets the length of Mode bits in XIP mode of operation. These bits are valid only when OSPI_XIP_CTRL[XIP_MD_BIT_EN] is set to 1.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Mode bits length equal to 2.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Mode bits length equal to 4.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Mode bits length equal to 8.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Mode bits length equal to 16.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RXDS_SIG_EN</name>
              <description>Enable RXDS Signaling during address and command phase of HyperBus transfer.
This bit enables RXDS signaling by HyperBus slave devices during Command-Address (CA) phase. If the RXDS signal is set to 1 during the CA phase of transfer, OSPI transmits [2 x OSPI_SPI_CTRLR0[WAIT_CYCLES]) - 1] wait cycles after the address phase is complete.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_HYPERBUS_EN</name>
              <description>SPI Hyperbus Frame format enable for XIP transfers.
Selects if data frame format for XIP transfers is in HyperBus mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONT_XFER_EN</name>
              <description>Enable Continuous Transfer in XIP mode. 
If this bit is set to 1 then continuous transfer mode in XIP will be enabled, in this mode OSPI will keep slave selected until a non-XIP transfer is detected on the AHB interface.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_EN</name>
              <description>XIP Instruction Enable bit.
 If this bit is set to 1 then XIP transfers will also have instruction phase. The instruction opcodes can be chosen from OSPI_XIP_INCR_INST or OSPI_XIP_WRAP_INST registers bases on AHB transfer type.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDS_EN</name>
              <description>Read Data Strobe Enable bit. 
Once this bit is set to 1, OSPI will use Read data strobe (RXDS) to capture read data in DDR mode.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_DDR_EN</name>
              <description>Instruction DDR Enable bit.
 This bit enables Dual Data-Rate transfer for instruction phase</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR_EN</name>
              <description>SPI DDR Enable bit. 
This bit enables Dual Data-Rate transfers in Dual/Quad/Octal frame formats of SPI.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFS_HC</name>
              <description>Fix DFS for XIP transfers. 
If this bit is set to 1 then data frame size for XIP transfers is fixed to the programmed value in OSPI_CTRLR0[DFS] bit field. The number of data frames to fetch is determined by transfer size and burst type signals. If this bit is set to 0 then data frame size and number of data frames to fetch are both determined by transfer size and burst type signals.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAIT_CYCLES</name>
              <description>Wait cycles in Dual/Quad/Octal mode between control frames transmission and data reception. Specified as number of SPI clock cycles.</description>
              <bitRange>[17:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MD_BITS_EN</name>
              <description>Mode bits enable in XIP mode.
 If this bit is set to 1, then in XIP mode of operation OSPI will insert Mode bits after the address phase. These bits are set in register OSPI_XIP_MODE_BITS register. The length of Mode bits defaults to 8-bits.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INST_L</name>
              <description>Dual/Quad/Octal mode instruction length in bits.</description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No Instruction</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit instruction length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit instruction length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>16-bit instruction length</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_L</name>
              <description>This bit defines Length of Address to be transmitted. Only after this much bits are programmed in to the FIFO the transfer can begin.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No address</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>4-bit address length</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>8-bit address length</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>12-bit address length</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x4</name>
                  <description>16-bit address length</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x5</name>
                  <description>20-bit address length</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x6</name>
                  <description>24-bit address length</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x7</name>
                  <description>28-bit address length</description>
                  <value>0x7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x8</name>
                  <description>32-bit address length</description>
                  <value>0x8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x9</name>
                  <description>36-bit address length</description>
                  <value>0x9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xA</name>
                  <description>40-bit address length</description>
                  <value>0xA</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xB</name>
                  <description>44-bit address length</description>
                  <value>0xB</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xC</name>
                  <description>48-bit address length</description>
                  <value>0xC</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xD</name>
                  <description>52-bit address length</description>
                  <value>0xD</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xE</name>
                  <description>56-bit address length</description>
                  <value>0xE</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>60-bit address length</description>
                  <value>0xF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRANS_TYPE</name>
              <description>Address and Instruction Transfer format.
Selects whether OSPI will transmit instruction/address either in Standard SPI mode or the SPI mode selected in the OSPI_XIP_CTRL[FRF] bit field.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Instruction and Address will be sent in Standard SPI Mode.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Instruction will be sent in Standard SPI Mode and Address will be sent in the mode specified by OSPI_XIP_CTRL[FRF] bit field.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Both Instruction and Address will be sent in the mode specified by OSPI_XIP_CTRL[FRF] bit field.</description>
                  <value>0x2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>SPI Frame Format
Selects data frame format for Transmitting/Receiving the data.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Dual SPI format</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>Quad SPI format</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x3</name>
                  <description>Octal SPI format</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPI_XIP_SER</name>
          <description>OSPI XIP Slave Enable Register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SER</name>
              <description>Slave Select Enable Flag.
Each bit of this bit field corresponds to the slave select line from the OSPI master. When a bit in this bit field is set (0x1), the slave select line from the master is activated when a serial transfer begins. It should be noted that setting or clearing bits in this bit field have no effect on the corresponding slave select output until a transfer is started. Before beginning a transfer, the respective bit in this bit field should be enabled depending which slave select line is desired.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Not selected</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Selected</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES0</name>
      <groupName>AES</groupName>
      <baseAddress>0x83001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>33</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>AES0_IRQ</name>
        <description>Combined interrupt request from AES0 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</description>
        <value>98</value>
      </interrupt>
      <registers>
        <register>
          <name>AES_CONTROL</name>
          <description>AES Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LD_KEY</name>
              <description>Write 1 once the new key has been written by the Secure Enclave, so the key can be pre-processed by the AES engine.
Read returns 0x0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_EN</name>
              <description>When this bit is set, the OSPI can be used in XIP mode directly, with or without intervention from the decryption logic.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_LOGIC</name>
              <description>Reset the AES engine.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DECRYPT_EN</name>
              <description>Decryption Enabled
When set, this bit causes host read accesses to use the decryption logic rather than go directly to the OSPI module. 
 Note that the OSPI module must be programmed to work in XIP mode prior to setting this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_INTERRUPT</name>
          <description>AES Interrupt Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_ERR_RESP</name>
              <description>SPI Error Response interrupt enabling.
Set when an error response is received from the OSPI through the AHB bus. Write 1 to clear bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI Error Response interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI Error Response interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REGS_ERR_RESP</name>
              <description>Register Error Response interrupt enabling.
Set when there is an access to an invalid AES register. Write 1 to clear bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Register Error Response interrupt is disabled.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Register Error Response interrupt is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_INTERRUPT_MASK</name>
          <description>AES Interrupt Mask Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI_ERR_RESP</name>
              <description>Mask for the SPI Error Response interrupt.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>SPI Error Response interrupt is not masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>SPI Error Response interrupt is masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REGS_ERR_RESP</name>
              <description>Mask for the Register Error Response interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Register Error Response interrupt is not masked.</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Register Error Response interrupt is masked.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_RXDS_DELAY</name>
          <description>OSPI RXDS Delay Register</description>
          <addressOffset>0x20</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>RXDS_DELAY</name>
              <description>A delay added to the OSPI RXDS input signal in 0.5-ns steps. The maximum allowed value to program is 16.
NOTE: The delay should be set to overcome the internal 3.6 ns delay of OSPI data lines compared to the RXDS line. The objective is to ensure that RXDS is delayed by 1/4 OSPI clock cycle with respect to the leading edge of the valid data lines. The nominal delay code for 100 MHz operation should be set to 12, resulting in approximately 6 ns delay for the RXDS line. This value may need to be calibrated for each specific application.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>No delay</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>0.5 ns delay</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x2</name>
                  <description>2 x 0.5 ns delay</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xF</name>
                  <description>15 x 0.5 ns delay</description>
                  <value>0xF</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x10</name>
                  <description>16 x 0.5 ns delay</description>
                  <value>0x10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="OSPI0">
      <name>OSPI1</name>
      <baseAddress>0x83002000</baseAddress>
      <interrupt>
        <name>OSPI1_IRQ</name>
        <description>Combined interrupt request from OSPI1 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</description>
        <value>97</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="AES0">
      <name>AES1</name>
      <baseAddress>0x83003000</baseAddress>
      <interrupt>
        <name>AES1_IRQ</name>
        <description>Combined interrupt request from AES1 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</description>
        <value>99</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>M55HP_NVIC_S</name>
      <groupName>M55HP</groupName>
      <baseAddress>0xE000E100</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>1248</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ISER[%s]</name>
          <description>Interrupt Set-Enable Register (n)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Allows to enable an interrupt or read the status. For each bit:
Read 0x0: Interrupt is disabled
Read 0x1: Interrupt is enabled
Write 0x0: No effect
Write 0x1: Enable interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ICER[%s]</name>
          <description>Interrupt Clear-Enable Register (n)</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Allows to disable an interrupt or read the status. For each bit:
Read 0x0: Interrupt is disabled
Read 0x1: Interrupt is enabled
Write 0x0: No effect
Write 0x1: Disable interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ISPR[%s]</name>
          <description>Interrupt Set-Pending Register (n)</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Allows to set an interrupt to pending state or read the status. For each bit:
Read 0x0: Interrupt is not pending
Read 0x1: Interrupt is pending
Write 0x0: No effect
Write 0x1: Set interrupt to pending state</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ICPR[%s]</name>
          <description>Interrupt Clear-Pending Register (n)</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Allows to clear an interrupt to not pending state or read the status. For each bit:
Read 0x0: Interrupt is not pending
Read 0x1: Interrupt is pending
Write 0x0: No effect
Write 0x1: Clear pending state of interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_IABR[%s]</name>
          <description>Interrupt Active Bit Register (n)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Indicates the active state of an interrupt. For each bit:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt is not active</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt is active</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_ITNS[%s]</name>
          <description>Interrupt Target Non-Secure Register (n)</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ITNS</name>
              <description>Determines whether an interrupt targets non-secure or secure state. For each bit:</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Interrupt targets secure state</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Interrupt targets non-secure state</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>120</dim>
          <dimIncrement>4</dimIncrement>
          <name>NVIC_IPR[%s]</name>
          <description>Interrupt Priority Register (n)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_N3</name>
              <description>Allows to set or read the priority level for interrupt 3</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_N2</name>
              <description>Allows to set or read the priority level for interrupt 2</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_N1</name>
              <description>Allows to set or read the priority level for interrupt 1</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_N0</name>
              <description>Allows to set or read the priority level for interrupt 0</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Val_0x0</name>
                  <description>Priority level is 0 (highest)</description>
                  <value>0x0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0x1</name>
                  <description>Priority level is 1</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Val_0xFF</name>
                  <description>Priority level is 255 (lowest)</description>
                  <value>0xFF</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="M55HP_NVIC_S">
      <name>M55HP_NVIC_NS</name>
      <baseAddress>0xE002E100</baseAddress>
    </peripheral>
  </peripherals>
  <vendorExtensions>
    <features>
      <package>FBGA194</package>
      <ioPins>96</ioPins>
      <sramSize>3.75</sramSize>
      <mramSize>1.5</mramSize>
      <ospiSize>1024</ospiSize>
      <lteType>-</lteType>
      <gnssType>-</gnssType>
      <securityType>Enclave</securityType>
      <gpuType>2D GPU</gpuType>
      <displayType>24b Parallel + MIPI DSI</displayType>
      <cameraType>8-16b Parallel + MIPI CSI-2</cameraType>
      <temp>-40,85</temp>
      <adc12>3,12</adc12>
      <adc24>1,24</adc24>
      <dac>2,12</dac>
      <cmp>4</cmp>
      <timer>12,32</timer>
      <qec>4,32</qec>
      <i2c>4</i2c>
      <i2s>4</i2s>
      <can>0</can>
      <eth>1,100000000</eth>
      <ospi>2</ospi>
      <sdio>1,8</sdio>
      <spi>4,50000000</spi>
      <uart>8,2500000</uart>
      <usbotg>1</usbotg>
    </features>
    <books>
      <book type="Datasheet" name="https://alifsemi.com/download/ADTS0007" title="E3 Datasheet"/>
      <book type="ERRATA" name="https://alifsemi.com/download/AERR0007" title="E3 Errata and Specification Changes"/>
      <book type="Hardware Reference Manual" name="https://alifsemi.com/download/AHRM0007" title="E3 Hardware Reference Manual"/>
      <book type="SWRM" name="https://alifsemi.com/download/ASRM0001" title="Software Reference Manual"/>
    </books>
    <boards><board vendor="AlifSemiconductor" name="DevKit-E7 (Gen 2)">
        <description>DevKit E7 (FBGA194)</description>
        <mountedDevice deviceIndex="0" Dvendor="Alif Semiconductor:165" Dname="AE722F80F55D5LS"/>
        <compatibleDevice deviceIndex="0" Dvendor="Alif Semiconductor:165" Dname="AE*L?"/>
        <debugInterface adapter="JTAG/SW" connector="20-pin Arm Coresight JTAG Connector (1.27 mm)"/>
        <debugInterface adapter="JTAG/SW" connector="10-pin Arm Coresight JTAG Connector (1.27 mm)"/>
        <feature type="XTAL" n="38400000"/>
        <feature type="XTAL" n="32768"/>
        <feature type="PWR" n="4.75" m="5.25"/>
        <feature type="Batt" n="1" name="CR2032 Battery for RTC and VBATT peripherals"/>
        <feature type="Curr" n="0.6" m="1"/>
        <feature type="RAM" n="1" name="32MB Octal SPI Hyper PSRAM"/>
        <feature type="ROM" n="1" name="32MB Octal SPI Flash"/>
        <feature type="MemCard" n="2" name="Micro SD Card Holder"/>
        <feature type="DIO" n="30" name="Digital IOs on 2 x 20 pin header (2.54 mm pitch)"/>
        <feature type="DIO" n="32" name="Digital IOs on 2 x 20 pin header (2.54 mm pitch) 1.8V/3.3V/5.0V"/>
        <feature type="DIO" n="32" name="Digital IOs on 2 x 20 pin header (2.54 mm pitch) for Parallel Camera or Display"/>
        <feature type="AIO" n="32" name="24 x Analog IOs and 8 x Digital IOs on 2 x 20 pin header (2.54 mm pitch)"/>
        <feature type="USB" n="1" name="High-Speed USB Device, Micro-AB receptacle"/>
        <feature type="USB" n="1" name="High-Speed USB Device, Micro-AB receptacle, PGM interface via USB-to-UART bridge"/>
        <feature type="ETH" n="1" m="100000000" name="RJ-45 receptacle 10/100 Ethernet"/>
        <feature type="LineOut" n="1" name="TRS Audio Line-Out Jack"/>
        <feature type="ConnOther" n="1" name="2 x 8 pin header for MIKROE Click Module"/>
        <feature type="ConnOther" n="1" name="GNSS"/>
        <feature type="Accelerometer" n="1" name="3-axis Digital Accelerometer in ICM-42670-P"/>
        <feature type="Gyro" n="1" name="3-axis Digital Gyroscope in ICM-42670-P"/>
        <feature type="Accelerometer" n="1" name="3-axis Digital Accelerometer in BMI323"/>
        <feature type="Gyro" n="1" name="3-axis Digital Gyroscope in BMI323"/>
        <feature type="TempSens" n="1" name="16-bit Digital Temperature Sensor in BMI323"/>
        <feature type="SensOther" n="4" name="2x I2S Digital MICs and 2x PDM Digital MICs"/>
        <feature type="Poti" n="1" name="Potentiometer between 1.8 V and GND"/>
        <feature type="Joystick" n="1" name="5-position Joystick"/>
        <feature type="Button" n="1" name="Reset push-button"/>
        <feature type="LED" n="2" name="Multicolor LEDs"/>
        <feature type="Camera" n="1" name="2-Lane MIPI CSI Connector for OnSemi ARX3A0 0.3MP 1/10.3 MONO"/>
        <feature type="GLCD" n="1" m="480.800" name="4.3-inch Color TFT LCD with Capacitive Touchscreen"/>
      </board>
      <board vendor="AlifSemiconductor" name="AppKit-E3-AIML (Gen 2)">
        <description>AppKit E3 (FBGA194)</description>
        <mountedDevice deviceIndex="0" Dvendor="Alif Semiconductor:165" Dname="AE302F80F55D5LE"/>
        <compatibleDevice deviceIndex="0" Dvendor="Alif Semiconductor:165" Dname="AE*L?"/>
        <debugInterface adapter="JTAG/SW" connector="20-pin Arm Coresight JTAG Connector (1.27 mm)"/>
        <debugInterface adapter="JTAG/SW" connector="10-pin Arm Coresight JTAG Connector (1.27 mm)"/>
        <feature type="XTAL" n="38400000"/>
        <feature type="XTAL" n="32768"/>
        <feature type="PWR" n="4.75" m="5.25"/>
        <feature type="PWRSock" n="1" name="2.1-mm DC barrel Jack, center positive"/>
        <feature type="Curr" n="0.6" m="1"/>
        <feature type="RAM" n="1" name="32MB Octal SPI Hyper PSRAM"/>
        <feature type="ROM" n="1" name="32MB Octal SPI Flash"/>
        <feature type="MemCard" n="2" name="Micro SD Card Holder"/>
        <feature type="DIO" n="30" name="Digital IOs on 2 x 20 pin header (2.54 mm pitch)"/>
        <feature type="DIO" n="32" name="Digital IOs on 2 x 20 pin header (2.54 mm pitch) 1.8V/3.3V/5.0V"/>
        <feature type="DIO" n="32" name="Digital IOs on 2 x 20 pin header (2.54 mm pitch) for Parallel Camera or Display"/>
        <feature type="DIO" n="12" name="IOs for Click Module on 2 x 8 pin header (2.54 mm pitch)"/>
        <feature type="AIO" n="32" name="24 x Analog IOs and 8 x Digital IOs on 2 x 20 pin header (2.54 mm pitch)"/>
        <feature type="USB" n="1" name="High-Speed USB Device, Micro-AB receptacle"/>
        <feature type="USB" n="1" name="High-Speed USB Device, Micro-AB receptacle, PGM interface via USB-to-UART bridge"/>
        <feature type="USB" n="1" name="High-Speed USB Host, Type-A receptacle"/>
        <feature type="ETH" n="1" m="100000000" name="RJ-45 receptacle 10/100 Ethernet"/>
        <feature type="Accelerometer" n="1" name="3-axis Digital Accelerometer in ICM-42670-P"/>
        <feature type="Gyro" n="1" name="3-axis Digital Gyroscope in ICM-42670-P"/>
        <feature type="Accelerometer" n="1" name="3-axis Digital Accelerometer in BMI323"/>
        <feature type="Gyro" n="1" name="3-axis Digital Gyroscope in BMI323"/>
        <feature type="TempSens" n="1" name="16-bit Digital Temperature Sensor in BMI323"/>
        <feature type="SensOther" n="4" name="2x I2S Digital MICs and 2x PDM Digital MICs"/>
        <feature type="Joystick" n="1" name="5-position Joystick"/>
        <feature type="Button" n="1" name="Reset push-button"/>
        <feature type="LED" n="2" name="Multicolor LEDs"/>
        <feature type="Camera" n="1" name="2-Lane MIPI CSI Connector for OnSemi ARX3A0 0.3MP 1/10.3 MONO"/>
        <feature type="GLCD" n="1" m="480.800" name="4.3-inch Color TFT LCD with Capacitive Touchscreen"/>
        <feature type="Other" n="1" name="WE310F5 WiFi and Bluetooth LE module"/>
      </board>
    </boards>
    <cpus>
      <cpu>
        <name>M55-HP</name>
        <core>Cortex-M55</core>
        <revision>r1p0</revision>
        <endian>Configurable</endian>
        <mpuPresent>true</mpuPresent>
        <fpuPresent>true</fpuPresent>
        <fpuDP>true</fpuDP>
        <dspPresent>true</dspPresent>
        <vtorPresent>true</vtorPresent>
        <nvicPrioBits>8</nvicPrioBits>
        <vendorSystickConfig>false</vendorSystickConfig>
        <sauNumRegions>1</sauNumRegions>
        <pmuPresent>true</pmuPresent>
        <pmuNumEventCnt>8</pmuNumEventCnt>
        <mvePresent>true</mvePresent>
        <mveFP>true</mveFP>
        <tzPresent>true</tzPresent>
        <cpuClock>400000000</cpuClock>
      </cpu>
      <cpu>
        <name>M55-HE</name>
        <core>Cortex-M55</core>
        <revision>r1p0</revision>
        <endian>Configurable</endian>
        <mpuPresent>true</mpuPresent>
        <fpuPresent>true</fpuPresent>
        <fpuDP>true</fpuDP>
        <dspPresent>true</dspPresent>
        <vtorPresent>true</vtorPresent>
        <nvicPrioBits>8</nvicPrioBits>
        <vendorSystickConfig>false</vendorSystickConfig>
        <sauNumRegions>1</sauNumRegions>
        <pmuPresent>true</pmuPresent>
        <pmuNumEventCnt>8</pmuNumEventCnt>
        <mvePresent>true</mvePresent>
        <mveFP>true</mveFP>
        <tzPresent>true</tzPresent>
        <cpuClock>160000000</cpuClock>
      </cpu>
    </cpus>
    <memories>
      <memory name="Backup_SRAM" start="0x4902C000" size="0x00001000" access="rw" default="1"/>
      <memory name="SRAM1" start="0x08000000" size="0x00200000" access="rw" default="1"/>
      <memory name="SRAM2" start="0x50000000" size="0x00040000" access="rw" default="1"/>
      <memory name="SRAM3" start="0x50800000" size="0x00100000" access="rw" default="1"/>
      <memory name="SRAM4" start="0x58000000" size="0x00040000" access="rw" default="1"/>
      <memory name="SRAM5" start="0x58800000" size="0x00040000" access="rw" default="1"/>
      <memory name="MRAM" start="0x80000000" size="0x00180000" access="rx" default="1"/>
      <memory name="OSPI0" start="0xA0000000" size="0x20000000" access="rwx" default="1"/>
      <memory name="OSPI1" start="0xC0000000" size="0x20000000" access="rwx" default="1"/>
    </memories>
    <firewalls>
      <firewall name="FCTLR" ProtectionExtension="PE.1" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.1" num_rgn="3" mnrs="4KB" mxrs="2MB" num_mpe="1" single_mst="0" location="Slave side" protectedRegion="0x1A80_0000 - 0x1A8E_FFFF"/>
      <firewall name="FC1" ProtectionExtension="PE.1" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.0" num_rgn="22" mnrs="4KB" mxrs="512MB" num_mpe="1" single_mst="0" location="Slave side" protectedRegion="0x1000_0000 - 0x17FF_FFFF, 0x1B00_0000 - 0x1E0F_FFFF"/>
      <firewall name="FC2" ProtectionExtension="PE.1" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.0" num_rgn="1" mnrs="4KB" mxrs="512MB" num_mpe="1" single_mst="0" location="Slave side" protectedRegion="0x1800_0000 - 0x19FF_FFFF"/>
      <firewall name="FC3" ProtectionExtension="PE.1" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.0" num_rgn="40" mnrs="4KB" mxrs="8MB" num_mpe="1" single_mst="0" location="Slave side" protectedRegion="0x1A00_0000 - 0x1A60_FFFF"/>
      <firewall name="FC4" ProtectionExtension="PE.2" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.1" num_rgn="32" mnrs="4KB" mxrs="128MB" num_mpe="4" single_mst="0" location="Slave side" protectedRegion="0x0800_0000 - 0x0FFF_FFFF"/>
      <firewall name="FC5" ProtectionExtension="PE.2" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.1" num_rgn="32" mnrs="256B" mxrs="32MB" num_mpe="4" single_mst="0" location="Slave side" protectedRegion="0x0200_0000 - 0x03FF_FFFF"/>
      <firewall name="FC7" ProtectionExtension="PE.2" MonitorExtension="ME.2" TranslationExtension="TE.2" RegionSizeExtension="RSE.1" num_rgn="16" mnrs="4KB" mxrs="4GB" num_mpe="1" single_mst="1" location="Master side" protectedRegion="M55-HP address map (0x0000_0000 - 0xFFFF_FFFF)"/>
      <firewall name="FC8" ProtectionExtension="PE.2" MonitorExtension="ME.2" TranslationExtension="TE.2" RegionSizeExtension="RSE.1" num_rgn="16" mnrs="4KB" mxrs="4GB" num_mpe="1" single_mst="1" location="Master side" protectedRegion="M55-HE address map (0x0000_0000 - 0xFFFF_FFFF)"/>
      <firewall name="FC9" ProtectionExtension="PE.2" MonitorExtension="ME.2" TranslationExtension="TE.2" RegionSizeExtension="RSE.1" num_rgn="32" mnrs="4KB" mxrs="4GB" num_mpe="4" single_mst="0" location="Master side" protectedRegion="Reserved"/>
      <firewall name="FC10" ProtectionExtension="PE.2" MonitorExtension="ME.2" TranslationExtension="TE.2" RegionSizeExtension="RSE.1" num_rgn="8" mnrs="4KB" mxrs="4GB" num_mpe="4" single_mst="0" location="Master side" protectedRegion="Reserved"/>
      <firewall name="FC11" ProtectionExtension="PE.2" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.1" num_rgn="32" mnrs="256B" mxrs="512MB" num_mpe="4" single_mst="0" location="Slave side" protectedRegion="0x4000_0000 - 0x5FFF_FFFF"/>
      <firewall name="FC12" ProtectionExtension="PE.2" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.1" num_rgn="32" mnrs="256B" mxrs="512MB" num_mpe="4" single_mst="0" location="Slave side" protectedRegion="0x6000_0000 - 0x6FFF_FFFF"/>
      <firewall name="FC13" ProtectionExtension="PE.2" MonitorExtension="ME.0" TranslationExtension="TE.0" RegionSizeExtension="RSE.1" num_rgn="32" mnrs="4KB" mxrs="2GB" num_mpe="4" single_mst="0" location="Slave side" protectedRegion="0x8000_0000 - 0xDFFF_FFFF"/>
      <firewall name="FC14" ProtectionExtension="PE.2" MonitorExtension="ME.2" TranslationExtension="TE.2" RegionSizeExtension="RSE.1" num_rgn="8" mnrs="4KB" mxrs="4GB" num_mpe="2" single_mst="0" location="Master side" protectedRegion="Reserved"/>
    </firewalls>
    <pins>
      <pin name="P0_0" location="R19" register="P0_0" offset="0x0" muxModes="GPIO0_0, OSPI0_D0_A, UART0_RX_A, I3C_SDA_A, UT0_T0_A, LPCAM_HSYNC_B, CAM_HSYNC_A, ANA_S0"/>
      <pin name="P0_1" location="R13" register="P0_1" offset="0x4" muxModes="GPIO0_1, OSPI0_D1_A, UART0_TX_A, I3C_SCL_A, UT0_T1_A, LPCAM_VSYNC_B, CAM_VSYNC_A, ANA_S1"/>
      <pin name="P0_2" location="R12" register="P0_2" offset="0x8" muxModes="GPIO0_2, OSPI0_D2_A, UART0_CTS_A, I2C0_SDA_A, UT1_T0_A, LPCAM_PCLK_B, CAM_PCLK_A, ANA_S2"/>
      <pin name="P0_3" location="R11" register="P0_3" offset="0xC" muxModes="GPIO0_3, OSPI0_D3_A, UART0_RTS_A, I2C0_SCL_A, UT1_T1_A, LPCAM_XVCLK_B, CAM_XVCLK_A, ANA_S3"/>
      <pin name="P0_4" location="R10" register="P0_4" offset="0x10" muxModes="GPIO0_4, OSPI0_D4_A, UART1_RX_A, PDM_D0_A, I2C1_SDA_A, UT2_T0_A, Reserved, ANA_S4"/>
      <pin name="P0_5" location="N15" register="P0_5" offset="0x14" muxModes="GPIO0_5, OSPI0_D5_A, UART1_TX_A, PDM_C0_A, I2C1_SCL_A, UT2_T1_A, Reserved, ANA_S5"/>
      <pin name="P0_6" location="P15" register="P0_6" offset="0x18" muxModes="GPIO0_6, OSPI0_D6_A, UART1_CTS_A, PDM_D1_A, I2C2_SCL_A, UT3_T0_A, Reserved, ANA_S6"/>
      <pin name="P0_7" location="R15" register="P0_7" offset="0x1C" muxModes="GPIO0_7, OSPI0_D7_A, UART1_RTS_A, PDM_C1_A, I2C2_SDA_A, UT3_T1_A, CDC_DE_B, ANA_S7"/>
      <pin name="P1_0" location="R14" register="P1_0" offset="0x20" muxModes="GPIO1_0, UART2_RX_A, SPI0_MISO_A, I2C3_SDA_A, UT4_T0_A, LPCAM_HSYNC_C, ETH_RXD0_C, ANA_S8"/>
      <pin name="P1_1" location="M15" register="P1_1" offset="0x24" muxModes="GPIO1_1, UART2_TX_A, SPI0_MOSI_A, I2C3_SCL_A, UT4_T1_A, LPCAM_VSYNC_C, ETH_RXD1_C, ANA_S9"/>
      <pin name="P1_2" location="L15" register="P1_2" offset="0x28" muxModes="GPIO1_2, UART3_RX_A, SPI0_SCLK_A, I3C_SDA_B, UT5_T0_A, LPCAM_PCLK_C, ETH_RST_C, ANA_S10"/>
      <pin name="P1_3" location="K15" register="P1_3" offset="0x2C" muxModes="GPIO1_3, UART3_TX_A, SPI0_SS0_A, I3C_SCL_B, UT5_T1_A, LPCAM_XVCLK_C, ETH_TXD0_C, ANA_S11"/>
      <pin name="P1_4" location="M19" register="P1_4" offset="0x30" muxModes="GPIO1_4, OSPI0_SS0_A, UART0_RX_B, SPI0_SS1_A, UT6_T0_A, LPCAM_D0_C, ETH_TXD1_C, ANA_S12"/>
      <pin name="P1_5" location="L18" register="P1_5" offset="0x34" muxModes="GPIO1_5, OSPI0_SS1_A, UART0_TX_B, SPI0_SS2_A, UT6_T1_A, LPCAM_D1_C, ETH_TXEN_C, ANA_S13"/>
      <pin name="P1_6" location="L19" register="P1_6" offset="0x38" muxModes="GPIO1_6, OSPI0_RXDS_B, UART1_RX_B, I2S0_SDI_A, UT7_T0_A, LPCAM_D2_C, ETH_IRQ_C, ANA_S14"/>
      <pin name="P1_7" location="J18" register="P1_7" offset="0x3C" muxModes="GPIO1_7, OSPI0_SCLK_A, UART1_TX_B, I2S0_SDO_A, UT7_T1_A, LPCAM_D3_C, ETH_REFCLK_C, ANA_S15"/>
      <pin name="P2_0" location="K19" register="P2_0" offset="0x40" muxModes="GPIO2_0, OSPI0_D0_B, UART2_RX_B, LPPDM_D0_A, UT8_T0_A, LPCAM_D4_C, ETH_MDIO_C, ANA_S16"/>
      <pin name="P2_1" location="K18" register="P2_1" offset="0x44" muxModes="GPIO2_1, OSPI0_D1_B, UART2_TX_B, LPPDM_C0_A, UT8_T1_A, LPCAM_D5_C, ETH_MDC_C, ANA_S17"/>
      <pin name="P2_2" location="J15" register="P2_2" offset="0x48" muxModes="GPIO2_2, OSPI0_D2_B, UART3_RX_B, LPPDM_D1_A, UT9_T0_A, LPCAM_D6_C, ETH_CRS_DV_C, ANA_S18"/>
      <pin name="P2_3" location="H15" register="P2_3" offset="0x4C" muxModes="GPIO2_3, OSPI0_D3_B, UART3_TX_B, LPPDM_C1_A, UT9_T1_A, LPCAM_D7_C, CDC_PCLK_B, ANA_S19"/>
      <pin name="P2_4" location="G19" register="P2_4" offset="0x50" muxModes="GPIO2_4, OSPI0_D4_B, LPI2S_SDI_A, SPI1_MISO_A, UT10_T0_A, LPCAM_D0_B, CAM_D0_A, ANA_S20"/>
      <pin name="P2_5" location="H19" register="P2_5" offset="0x54" muxModes="GPIO2_5, OSPI0_D5_B, LPI2S_SDO_A, SPI1_MOSI_A, UT10_T1_A, LPCAM_D1_B, CAM_D1_A, ANA_S21"/>
      <pin name="P2_6" location="H18" register="P2_6" offset="0x58" muxModes="GPIO2_6, OSPI0_D6_B, LPI2S_SCLK_A, SPI1_SCLK_A, UT11_T0_A, LPCAM_D2_B, CAM_D2_A, ANA_S22"/>
      <pin name="P2_7" location="J19" register="P2_7" offset="0x5C" muxModes="GPIO2_7, OSPI0_D7_B, LPI2S_WS_A, SPI1_SS0_A, UT11_T1_A, LPCAM_D3_B, CAM_D3_A, ANA_S23"/>
      <pin name="P3_0" location="B6" register="P3_0" offset="0x60" muxModes="GPIO3_0, OSPI0_SCLK_B, UART4_RX_A, PDM_D0_B, I2S0_SCLK_A, QEC0_X_A, LPCAM_D4_B, CAM_D4_A"/>
      <pin name="P3_1" location="A6" register="P3_1" offset="0x64" muxModes="GPIO3_1, OSPI0_SCLKN_B, UART4_TX_A, PDM_C0_B, I2S0_WS_A, QEC0_Y_A, LPCAM_D5_B, CAM_D5_A"/>
      <pin name="P3_2" location="E2" register="P3_2" offset="0x68" muxModes="GPIO3_2, OSPI0_SS0_B, PDM_D1_B, I2S1_SDI_A, I3C_SDA_C, QEC0_Z_A, LPCAM_D6_B, CAM_D6_A"/>
      <pin name="P3_3" location="G2" register="P3_3" offset="0x6C" muxModes="GPIO3_3, OSPI0_SS1_B, PDM_C1_B, I2S1_SDO_A, I3C_SCL_C, QEC1_X_A, LPCAM_D7_B, CAM_D7_A"/>
      <pin name="P3_4" location="F2" register="P3_4" offset="0x70" muxModes="GPIO3_4, OSPI0_RXDS_A, UART5_RX_A, LPPDM_C0_B, I2S1_SCLK_A, I2C0_SCL_B, QEC1_Y_A, CAM_D8_A"/>
      <pin name="P3_5" location="F1" register="P3_5" offset="0x74" muxModes="GPIO3_5, OSPI0_SCLKN_A, UART5_TX_A, LPPDM_D0_B, SPI0_SS1_B, I2C0_SDA_B, QEC1_Z_A, CAM_D9_A"/>
      <pin name="P3_6" location="V5" register="P3_6" offset="0x78" muxModes="GPIO3_6, HFXO_OUT_A, LPUART_CTS_B, LPPDM_C1_B, SPI0_SS2_B, I2C1_SDA_B, QEC2_X_A, CAM_D10_A"/>
      <pin name="P3_7" location="L8" register="P3_7" offset="0x7C" muxModes="GPIO3_7, JTAG_TRACECLK, LPUART_RTS_B, LPPDM_D1_B, SPI1_SS1_A, I2C1_SCL_B, QEC2_Y_A, CAM_D11_A"/>
      <pin name="P4_0" location="F18" register="P4_0" offset="0x80" muxModes="GPIO4_0, JTAG_TDATA0, Reserved, I2S1_WS_A, SPI1_SS2_A, QEC2_Z_A, CDC_VSYNC_B, CAM_D12_A"/>
      <pin name="P4_1" location="B19" register="P4_1" offset="0x84" muxModes="GPIO4_1, JTAG_TDATA1, I2S0_SDI_B, SPI1_SS3_A, QEC3_X_A, SD_CLK_D, CDC_HSYNC_B, CAM_D13_A"/>
      <pin name="P4_2" location="C19" register="P4_2" offset="0x88" muxModes="GPIO4_2, JTAG_TDATA2, Reserved, I2S0_SDO_B, SPI2_MISO_A, QEC3_Y_A, SD_CMD_D, CAM_D14_A"/>
      <pin name="P4_3" location="B18" register="P4_3" offset="0x8C" muxModes="GPIO4_3, JTAG_TDATA3, Reserved, I2S0_SCLK_B, SPI2_MOSI_A, QEC3_Z_A, SD_RST_D, CAM_D15_A"/>
      <pin name="P4_4" location="B17" register="P4_4" offset="0x90" muxModes="GPIO4_4, JTAG_TCK, I2S0_WS_B, SPI2_SCLK_A, FAULT0_A"/>
      <pin name="P4_5" location="A19" register="P4_5" offset="0x94" muxModes="GPIO4_5, JTAG_TMS, SPI2_SS0_A, FAULT1_A"/>
      <pin name="P4_6" location="A18" register="P4_6" offset="0x98" muxModes="GPIO4_6, JTAG_TDI, SPI2_SS1_A, FAULT2_A"/>
      <pin name="P4_7" location="B16" register="P4_7" offset="0x9C" muxModes="GPIO4_7, JTAG_TDO, SPI2_SS2_A, FAULT3_A"/>
      <pin name="P5_0" location="A16" register="P5_0" offset="0xA0" muxModes="GPIO5_0, OSPI1_RXDS_A, UART4_RX_C, PDM_D2_A, SPI0_MISO_B, I2C2_SDA_B, UT0_T0_B, SD_D0_A"/>
      <pin name="P5_1" location="B14" register="P5_1" offset="0xA4" muxModes="GPIO5_1, OSPI1_SS0_A, UART4_TX_C, PDM_D3_A, SPI0_MOSI_B, I2C2_SCL_B, UT0_T1_B, SD_D1_A"/>
      <pin name="P5_2" location="E12" register="P5_2" offset="0xA8" muxModes="GPIO5_2, OSPI1_SCLKN_A, UART5_RX_C, PDM_C3_A, SPI0_SS0_B, LPI2C_SCL_B, UT1_T0_B, SD_D2_A"/>
      <pin name="P5_3" location="B13" register="P5_3" offset="0xAC" muxModes="GPIO5_3, OSPI1_SCLK_A, UART5_TX_C, SPI0_SCLK_B, LPI2C_SDA_B, UT1_T1_B, SD_D3_A, CDC_PCLK_A"/>
      <pin name="P5_4" location="E11" register="P5_4" offset="0xB0" muxModes="GPIO5_4, OSPI1_SS1_A, UART3_CTS_A, PDM_D2_B, SPI0_SS3_A, UT2_T0_B, SD_D4_A, CDC_DE_A"/>
      <pin name="P5_5" location="E10" register="P5_5" offset="0xB4" muxModes="GPIO5_5, OSPI1_SCLK_C, UART3_RTS_A, PDM_D3_B, UT2_T1_B, SD_D5_A, ETH_RXD0_A, CDC_HSYNC_A"/>
      <pin name="P5_6" location="B12" register="P5_6" offset="0xB8" muxModes="GPIO5_6, Reserved, UART1_CTS_B, I2C2_SCL_C, UT3_T0_B, SD_D6_A, ETH_RXD1_A, CDC_VSYNC_A"/>
      <pin name="P5_7" location="B11" register="P5_7" offset="0xBC" muxModes="GPIO5_7, OSPI1_SS0_C, UART1_RTS_B, I2C2_SDA_C, UT3_T1_B, SD_D7_A, ETH_RST_A"/>
      <pin name="P6_0" location="A12" register="P6_0" offset="0xC0" muxModes="GPIO6_0, OSPI0_D0_C, UART4_DE_A, PDM_D0_C, UT4_T0_B, SD_D0_D, ETH_TXD0_A"/>
      <pin name="P6_1" location="E9" register="P6_1" offset="0xC4" muxModes="GPIO6_1, OSPI0_D1_C, UART5_DE_A, PDM_C0_C, UT4_T1_B, SD_D1_D, ETH_TXD1_A"/>
      <pin name="P6_2" location="A11" register="P6_2" offset="0xC8" muxModes="GPIO6_2, OSPI0_D2_C, UART2_CTS_A, Reserved, PDM_D1_C, UT5_T0_B, SD_D2_D, ETH_TXEN_A"/>
      <pin name="P6_3" location="B10" register="P6_3" offset="0xCC" muxModes="GPIO6_3, OSPI0_D3_C, UART2_RTS_A, Reserved, PDM_C1_C, UT5_T1_B, SD_D3_D, ETH_IRQ_A"/>
      <pin name="P6_4" location="E8" register="P6_4" offset="0xD0" muxModes="GPIO6_4, OSPI0_D4_C, UART2_CTS_B, Reserved, SPI1_SS0_B, UT6_T0_B, SD_D4_D, ETH_REFCLK_A"/>
      <pin name="P6_5" location="E7" register="P6_5" offset="0xD4" muxModes="GPIO6_5, OSPI0_D5_C, UART2_RTS_B, Reserved, SPI1_SS1_B, UT6_T1_B, SD_D5_D, ETH_MDIO_A"/>
      <pin name="P6_6" location="E6" register="P6_6" offset="0xD8" muxModes="GPIO6_6, OSPI0_D6_C, UART0_CTS_B, Reserved, SPI1_SS2_B, UT7_T0_B, SD_D6_D, ETH_MDC_A"/>
      <pin name="P6_7" location="A9" register="P6_7" offset="0xDC" muxModes="GPIO6_7, OSPI0_D7_C, UART0_RTS_B, PDM_C2_A, SPI1_SS3_B, UT7_T1_B, SD_D7_D, ETH_CRS_DV_A"/>
      <pin name="P7_0" location="B8" register="P7_0" offset="0xE0" muxModes="GPIO7_0, Reserved, CMP3_OUT_A, SPI0_MISO_C, I2C0_SDA_C, UT8_T0_B, SD_CMD_A, Reserved"/>
      <pin name="P7_1" location="B3" register="P7_1" offset="0xE4" muxModes="GPIO7_1, Reserved, CMP2_OUT_A, SPI0_MOSI_C, I2C0_SCL_C, UT8_T1_B, SD_CLK_A, Reserved"/>
      <pin name="P7_2" location="D1" register="P7_2" offset="0xE8" muxModes="GPIO7_2, Reserved, UART3_CTS_B, CMP1_OUT_A, SPI0_SCLK_C, I2C1_SDA_C, UT9_T0_B, SD_RST_A"/>
      <pin name="P7_3" location="A8" register="P7_3" offset="0xEC" muxModes="GPIO7_3, Reserved, UART3_RTS_B, CMP0_OUT_A, SPI0_SS0_C, I2C1_SCL_C, UT9_T1_B, Reserved"/>
      <pin name="P7_4" location="T1" register="P7_4" offset="0xF0" muxModes="GPIO7_4, Reserved, LPUART_CTS_A, LPPDM_C2_A, LPSPI_MISO_A, LPI2C_SCL_A, UT10_T0_B"/>
      <pin name="P7_5" location="T2" register="P7_5" offset="0xF4" muxModes="GPIO7_5, Reserved, LPUART_RTS_A, Reserved, LPPDM_D2_A, LPSPI_MOSI_A, LPI2C_SDA_A, UT10_T1_B"/>
      <pin name="P7_6" location="U3" register="P7_6" offset="0xF8" muxModes="GPIO7_6, Reserved, LPUART_RX_A, Reserved, LPPDM_C3_A, LPSPI_SCLK_A, I3C_SDA_D, UT11_T0_B"/>
      <pin name="P7_7" location="U1" register="P7_7" offset="0xFC" muxModes="GPIO7_7, Reserved, LPUART_TX_A, Reserved, LPPDM_D3_A, LPSPI_SS_A, I3C_SCL_D, UT11_T1_B"/>
      <pin name="P8_0" location="B7" register="P8_0" offset="0x100" muxModes="GPIO8_0, OSPI1_SCLKN_C, AUDIO_CLK_A, FAULT0_B, LPCAM_D0_A, SD_D0_C, CDC_D0_A, CAM_D0_B"/>
      <pin name="P8_1" location="C2" register="P8_1" offset="0x104" muxModes="GPIO8_1, I2S2_SDI_A, FAULT1_B, LPCAM_D1_A, SD_D1_C, CDC_D1_A, CAM_D1_B"/>
      <pin name="P8_2" location="C3" register="P8_2" offset="0x108" muxModes="GPIO8_2, I2S2_SDO_A, SPI0_SS3_B, FAULT2_B, LPCAM_D2_A, SD_D2_C, CDC_D2_A, CAM_D2_B"/>
      <pin name="P8_3" location="A7" register="P8_3" offset="0x10C" muxModes="GPIO8_3, I2S2_SCLK_A, SPI1_MISO_B, FAULT3_B, LPCAM_D3_A, SD_D3_C, CDC_D3_A, CAM_D3_B"/>
      <pin name="P8_4" location="B4" register="P8_4" offset="0x110" muxModes="GPIO8_4, I2S2_WS_A, SPI1_MOSI_B, QEC0_X_B, LPCAM_D4_A, SD_D4_C, CDC_D4_A, CAM_D4_B"/>
      <pin name="P8_5" location="H1" register="P8_5" offset="0x114" muxModes="GPIO8_5, Reserved, SPI1_SCLK_B, QEC0_Y_B, LPCAM_D5_A, SD_D5_C, CDC_D5_A, CAM_D5_B"/>
      <pin name="P8_6" location="J2" register="P8_6" offset="0x118" muxModes="GPIO8_6, Reserved, I2S3_SCLK_B, QEC0_Z_B, LPCAM_D6_A, SD_D6_C, CDC_D6_A, CAM_D6_B"/>
      <pin name="P8_7" location="J1" register="P8_7" offset="0x11C" muxModes="GPIO8_7, Reserved, I2S3_WS_B, QEC1_X_B, LPCAM_D7_A, SD_D7_C, CDC_D7_A, CAM_D7_B"/>
      <pin name="P9_0" location="K2" register="P9_0" offset="0x120" muxModes="GPIO9_0, Reserved, I2S3_SDI_B, QEC1_Y_B, SD_CMD_C, CDC_D8_A, CAM_D8_B"/>
      <pin name="P9_1" location="K1" register="P9_1" offset="0x124" muxModes="GPIO9_1, LPUART_RX_B, I2S3_SDO_B, QEC1_Z_B, SD_CLK_C, CDC_D9_A, CAM_D9_B"/>
      <pin name="P9_2" location="G5" register="P9_2" offset="0x128" muxModes="GPIO9_2, LPUART_TX_B, I2S3_SDI_A, SPI2_MISO_B, QEC2_X_B, SD_RST_C, CDC_D10_A, CAM_D10_B"/>
      <pin name="P9_3" location="H5" register="P9_3" offset="0x12C" muxModes="GPIO9_3, HFXO_OUT_B, UART7_RX_B, I2S3_SDO_A, SPI2_MOSI_B, QEC2_Y_B, CDC_D11_A, CAM_D11_B"/>
      <pin name="P9_4" location="J5" register="P9_4" offset="0x130" muxModes="GPIO9_4, UART7_TX_B, I2S3_SCLK_A, SPI2_SCLK_B, I2C3_SDA_C, QEC2_Z_B, CDC_D12_A, CAM_D12_B"/>
      <pin name="P9_5" location="L1" register="P9_5" offset="0x134" muxModes="GPIO9_5, OSPI1_D0_C, I2S3_WS_A, SPI2_SS0_B, I2C3_SCL_C, QEC3_X_B, CDC_D13_A, CAM_D13_B"/>
      <pin name="P9_6" location="K5" register="P9_6" offset="0x138" muxModes="GPIO9_6, OSPI1_D1_C, AUDIO_CLK_B, SPI2_SS1_B, I2C3_SDA_B, QEC3_Y_B, CDC_D14_A, CAM_D14_B"/>
      <pin name="P9_7" location="L5" register="P9_7" offset="0x13C" muxModes="GPIO9_7, OSPI1_D2_C, UART7_DE_B, SPI2_SS2_B, I2C3_SCL_B, QEC3_Z_B, CDC_D15_A, CAM_D15_B"/>
      <pin name="P10_0" location="M2" register="P10_0" offset="0x140" muxModes="GPIO10_0, OSPI1_D3_C, UART6_DE_B, SPI2_SS3_B, UT0_T0_C, LPCAM_HSYNC_A, CDC_D16_A, CAM_HSYNC_B"/>
      <pin name="P10_1" location="M1" register="P10_1" offset="0x144" muxModes="GPIO10_1, OSPI1_D4_C, Reserved, LPI2S_SDI_B, UT0_T1_C, LPCAM_VSYNC_A, CDC_D17_A, CAM_VSYNC_B"/>
      <pin name="P10_2" location="N1" register="P10_2" offset="0x148" muxModes="GPIO10_2, OSPI1_D5_C, Reserved, LPI2S_SDO_B, UT1_T0_C, LPCAM_PCLK_A, CDC_D18_A, CAM_PCLK_B"/>
      <pin name="P10_3" location="N2" register="P10_3" offset="0x14C" muxModes="GPIO10_3, OSPI1_D6_C, Reserved, LPI2S_SCLK_B, UT1_T1_C, LPCAM_XVCLK_A, CDC_D19_A, CAM_XVCLK_B"/>
      <pin name="P10_4" location="M5" register="P10_4" offset="0x150" muxModes="GPIO10_4, OSPI1_D7_C, Reserved, LPI2S_WS_B, I2C0_SDA_D, UT2_T0_C, ETH_TXD0_B, CDC_D20_A"/>
      <pin name="P10_5" location="N5" register="P10_5" offset="0x154" muxModes="GPIO10_5, UART6_RX_A, I2S2_SDI_B, SPI3_MISO_B, I2C0_SCL_D, UT2_T1_C, ETH_TXD1_B, CDC_D21_A"/>
      <pin name="P10_6" location="P5" register="P10_6" offset="0x158" muxModes="GPIO10_6, UART6_TX_A, I2S2_SDO_B, SPI3_MOSI_B, I2C1_SDA_D, UT3_T0_C, ETH_TXEN_B, CDC_D22_A"/>
      <pin name="P10_7" location="P1" register="P10_7" offset="0x15C" muxModes="GPIO10_7, UART7_RX_A, I2S2_SCLK_B, SPI3_SCLK_B, I2C1_SCL_D, UT3_T1_C, CDC_D23_A, OSPI1_RXDS_C"/>
      <pin name="P11_0" location="P2" register="P11_0" offset="0x160" muxModes="GPIO11_0, OSPI1_D0_A, UART7_TX_A, I2S2_WS_B, SPI3_SS0_B, UT4_T0_C, ETH_REFCLK_B, CDC_D0_B"/>
      <pin name="P11_1" location="R1" register="P11_1" offset="0x164" muxModes="GPIO11_1, OSPI1_D1_A, UART7_DE_A, SPI3_SS1_B, UT4_T1_C, ETH_MDIO_B, CDC_D1_B"/>
      <pin name="P11_2" location="R2" register="P11_2" offset="0x168" muxModes="GPIO11_2, OSPI1_D2_A, UART6_DE_A, LPPDM_C2_B, SPI3_SS2_B, UT5_T0_C, ETH_MDC_B, CDC_D2_B"/>
      <pin name="P11_3" location="R5" register="P11_3" offset="0x16C" muxModes="GPIO11_3, OSPI1_D3_A, UART5_RX_B, LPPDM_C3_B, SPI3_SS3_B, UT5_T1_C, ETH_RXD0_B, CDC_D3_B"/>
      <pin name="P11_4" location="K8" register="P11_4" offset="0x170" muxModes="GPIO11_4, OSPI1_D4_A, UART5_TX_B, PDM_C2_B, LPSPI_MISO_B, UT6_T0_C, ETH_RXD1_B, CDC_D4_B"/>
      <pin name="P11_5" location="J9" register="P11_5" offset="0x174" muxModes="GPIO11_5, OSPI1_D5_A, UART6_RX_B, PDM_C3_B, LPSPI_MOSI_B, UT6_T1_C, ETH_CRS_DV_B, CDC_D5_B"/>
      <pin name="P11_6" location="R6" register="P11_6" offset="0x178" muxModes="GPIO11_6, OSPI1_D6_A, UART6_TX_B, LPPDM_D2_B, LPSPI_SCLK_B, UT7_T0_C, ETH_RST_B, CDC_D6_B"/>
      <pin name="P11_7" location="L9" register="P11_7" offset="0x17C" muxModes="GPIO11_7, OSPI1_D7_A, UART5_DE_B, LPPDM_D3_B, LPSPI_SS_B, UT7_T1_C, ETH_IRQ_B, CDC_D7_B"/>
      <pin name="P12_0" location="F19" register="P12_0" offset="0x180" muxModes="GPIO12_0, OSPI0_SCLK_C, AUDIO_CLK_C, I2S1_SDI_B, UT8_T0_C, CDC_D8_B"/>
      <pin name="P12_1" location="E18" register="P12_1" offset="0x184" muxModes="GPIO12_1, OSPI0_SCLKN_C, UART4_RX_B, I2S1_SDO_B, UT8_T1_C, CDC_D9_B"/>
      <pin name="P12_2" location="E15" register="P12_2" offset="0x188" muxModes="GPIO12_2, OSPI0_RXDS_C, UART4_TX_B, I2S1_SCLK_B, UT9_T0_C, CDC_D10_B"/>
      <pin name="P12_3" location="D18" register="P12_3" offset="0x18C" muxModes="GPIO12_3, OSPI0_SS0_C, UART4_DE_B, I2S1_WS_B, UT9_T1_C, CDC_D11_B"/>
      <pin name="P12_4" location="F5" register="P12_4" offset="0x190" muxModes="GPIO12_4, OSPI0_SS1_C, SPI3_MISO_A, UT10_T0_C, Reserved, CDC_D12_B"/>
      <pin name="P12_5" location="A10" register="P12_5" offset="0x194" muxModes="GPIO12_5, Reserved, SPI3_MOSI_A, UT10_T1_C, Reserved, CDC_D13_B"/>
      <pin name="P12_6" location="E5" register="P12_6" offset="0x198" muxModes="GPIO12_6, Reserved, SPI3_SCLK_A, UT11_T0_C, Reserved, CDC_D14_B"/>
      <pin name="P12_7" location="D2" register="P12_7" offset="0x19C" muxModes="GPIO12_7, OSPI1_RXDS_B, Reserved, SPI3_SS0_A, UT11_T1_C, CDC_D15_B"/>
      <pin name="P13_0" location="G18" register="P13_0" offset="0x1A0" muxModes="GPIO13_0, OSPI1_D0_B, Reserved, SPI3_SS1_A, QEC0_X_C, SD_D0_B, CDC_D16_B"/>
      <pin name="P13_1" location="G15" register="P13_1" offset="0x1A4" muxModes="GPIO13_1, OSPI1_D1_B, SPI3_SS2_A, QEC0_Y_C, SD_D1_B, CDC_D17_B"/>
      <pin name="P13_2" location="F15" register="P13_2" offset="0x1A8" muxModes="GPIO13_2, OSPI1_D2_B, SPI3_SS3_A, QEC0_Z_C, SD_D2_B, CDC_D18_B"/>
      <pin name="P13_3" location="E13" register="P13_3" offset="0x1AC" muxModes="GPIO13_3, OSPI1_D3_B, SPI2_SS3_A, QEC1_X_C, SD_D3_B, CDC_D19_B"/>
      <pin name="P13_4" location="E14" register="P13_4" offset="0x1B0" muxModes="GPIO13_4, OSPI1_D4_B, LPI2S_SDI_C, QEC1_Y_C, SD_D4_B, CDC_D20_B"/>
      <pin name="P13_5" location="A17" register="P13_5" offset="0x1B4" muxModes="GPIO13_5, OSPI1_D5_B, LPI2S_SDO_C, QEC1_Z_C, SD_D5_B, CDC_D21_B"/>
      <pin name="P13_6" location="B15" register="P13_6" offset="0x1B8" muxModes="GPIO13_6, OSPI1_D6_B, LPI2S_SCLK_C, QEC2_X_C, SD_D6_B, CDC_D22_B"/>
      <pin name="P13_7" location="A15" register="P13_7" offset="0x1BC" muxModes="GPIO13_7, OSPI1_D7_B, LPI2S_WS_C, QEC2_Y_C, SD_D7_B, CDC_D23_B"/>
      <pin name="P14_0" location="B9" register="P14_0" offset="0x1C0" muxModes="GPIO14_0, OSPI1_SCLK_B, UART6_RX_C, QEC2_Z_C, SD_CMD_B"/>
      <pin name="P14_1" location="H2" register="P14_1" offset="0x1C4" muxModes="GPIO14_1, OSPI1_SCLKN_B, UART6_TX_C, Reserved, QEC3_X_C, SD_CLK_B"/>
      <pin name="P14_2" location="G1" register="P14_2" offset="0x1C8" muxModes="GPIO14_2, OSPI1_SS0_B, UART7_RX_C, Reserved, QEC3_Y_C, SD_RST_B"/>
      <pin name="P14_3" location="R7" register="P14_3" offset="0x1CC" muxModes="GPIO14_3, OSPI1_SS1_B, UART7_TX_C, Reserved, QEC3_Z_C"/>
      <pin name="P14_4" location="R8" register="P14_4" offset="0x1D0" muxModes="GPIO14_4, CMP3_OUT_B, SPI1_MISO_C, FAULT0_C"/>
      <pin name="P14_5" location="L11" register="P14_5" offset="0x1D4" muxModes="GPIO14_5, CMP2_OUT_B, SPI1_MOSI_C, FAULT1_C"/>
      <pin name="P14_6" location="K12" register="P14_6" offset="0x1D8" muxModes="GPIO14_6, CMP1_OUT_B, SPI1_SCLK_C, FAULT2_C"/>
      <pin name="P14_7" location="L12" register="P14_7" offset="0x1DC" muxModes="GPIO14_7, CMP0_OUT_B, SPI1_SS0_C, FAULT3_C"/>
      <pin name="P15_0" location="V2" register="LPGPIO_CTRL_0" offset="0x0" muxModes="GPIOV_0, LPTMR0_CLK_IO"/>
      <pin name="P15_1" location="W2" register="LPGPIO_CTRL_1" offset="0x4" muxModes="GPIOV_1, LPTMR1_CLK_IO"/>
      <pin name="P15_2" location="U2" register="LPGPIO_CTRL_2" offset="0x8" muxModes="GPIOV_2, LPTMR2_CLK_IO"/>
      <pin name="P15_3" location="V1" register="LPGPIO_CTRL_3" offset="0xC" muxModes="GPIOV_3, LPTMR3_CLK_IO"/>
      <pin name="P15_4" location="V3" register="LPGPIO_CTRL_4" offset="0x10" muxModes="GPIOV_4"/>
      <pin name="P15_5" location="W4" register="LPGPIO_CTRL_5" offset="0x14" muxModes="GPIOV_5"/>
      <pin name="P15_6" location="V4" register="LPGPIO_CTRL_6" offset="0x18" muxModes="GPIOV_6"/>
      <pin name="P15_7" location="W5" register="LPGPIO_CTRL_7" offset="0x1C" muxModes="GPIOV_7"/>
      <pin name="SEUART_RX" location="A14" register="NA" offset="NA" muxModes="SEUART_RX"/>
      <pin name="SEUART_TX" location="A13" register="NA" offset="NA" muxModes="SEUART_TX"/>
      <pin name="N.C." location="J11" register="NA" offset="NA" muxModes="N.C."/>
      <pin name="N.C." location="M18" register="NA" offset="NA" muxModes="N.C."/>
      <pin name="N.C." location="J8" register="NA" offset="NA" muxModes="N.C."/>
      <pin name="N.C." location="C1" register="NA" offset="NA" muxModes="N.C."/>
      <pin name="N.C." location="B1" register="NA" offset="NA" muxModes="N.C."/>
      <pin name="N.C." location="A1" register="NA" offset="NA" muxModes="N.C."/>
      <pin name="NSRST" location="J12" register="NA" offset="NA" muxModes="NSRST"/>
      <pin name="POR_N" location="U18" register="NA" offset="NA" muxModes="POR_N"/>
      <pin name="HFXO_P" location="A4" register="NA" offset="NA" muxModes="HFXO_P"/>
      <pin name="HFXO_N" location="A3" register="NA" offset="NA" muxModes="HFXO_N"/>
      <pin name="LFXO_P" location="V17" register="NA" offset="NA" muxModes="LFXO_P"/>
      <pin name="LFXO_N" location="W17" register="NA" offset="NA" muxModes="LFXO_N"/>
      <pin name="VREF_P" location="N18" register="NA" offset="NA" muxModes="VREF_P"/>
      <pin name="VDD_MAIN" location="P19" register="NA" offset="NA" muxModes="VDD_MAIN"/>
      <pin name="VDD_BATT" location="T18" register="NA" offset="NA" muxModes="VDD_BATT"/>
      <pin name="VDD_BUCK" location="R18" register="NA" offset="NA" muxModes="VDD_BUCK"/>
      <pin name="VDD_IO_FLEX" location="W1" register="NA" offset="NA" muxModes="VDD_IO_FLEX"/>
      <pin name="VDD_IO_1V8" location="A5" register="NA" offset="NA" muxModes="VDD_IO_1V8"/>
      <pin name="VDD_IO_1V8" location="D19" register="NA" offset="NA" muxModes="VDD_IO_1V8"/>
      <pin name="VDD_IO_1V8" location="W3" register="NA" offset="NA" muxModes="VDD_IO_1V8"/>
      <pin name="VDD_CORE_0V8" location="B5" register="NA" offset="NA" muxModes="VDD_CORE_0V8"/>
      <pin name="VDD_CORE_0V8" location="E1" register="NA" offset="NA" muxModes="VDD_CORE_0V8"/>
      <pin name="VDD_CORE_0V8" location="E19" register="NA" offset="NA" muxModes="VDD_CORE_0V8"/>
      <pin name="VDD_CORE_0V8" location="V6" register="NA" offset="NA" muxModes="VDD_CORE_0V8"/>
      <pin name="VREG_MIPI_0V8" location="W13" register="NA" offset="NA" muxModes="VREG_MIPI_0V8"/>
      <pin name="VDD_MIPI_1V8" location="W12" register="NA" offset="NA" muxModes="VDD_MIPI_1V8"/>
      <pin name="VDD_USB_3V3" location="W8" register="NA" offset="NA" muxModes="VDD_USB_3V3"/>
      <pin name="VDD_SX_0V8" location="A2" register="NA" offset="NA" muxModes="VDD_SX_0V8"/>
      <pin name="VSS" location="B2" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="V12" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="K9" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="K11" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="K10" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="C18" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="J10" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="L2" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS" location="L10" register="NA" offset="NA" muxModes="VSS"/>
      <pin name="VSS_BUCK" location="V19" register="NA" offset="NA" muxModes="VSS_BUCK"/>
      <pin name="VSS_ANA" location="P18" register="NA" offset="NA" muxModes="VSS_ANA"/>
      <pin name="VREG_CORE_0V8" location="W18" register="NA" offset="NA" muxModes="VREG_CORE_0V8"/>
      <pin name="VREG_AON" location="U17" register="NA" offset="NA" muxModes="VREG_AON"/>
      <pin name="VREG_LP_1V8" location="W19" register="NA" offset="NA" muxModes="VREG_LP_1V8"/>
      <pin name="VREG_DIG_1V8" location="U19" register="NA" offset="NA" muxModes="VREG_DIG_1V8"/>
      <pin name="VREG_AUX_1V8" location="V18" register="NA" offset="NA" muxModes="VREG_AUX_1V8"/>
      <pin name="VREG_MIPI_1V8" location="N19" register="NA" offset="NA" muxModes="VREG_MIPI_1V8"/>
      <pin name="VSW" location="T19" register="NA" offset="NA" muxModes="VSW"/>
      <pin name="USB_REXT" location="V8" register="NA" offset="NA" muxModes="USB_REXT"/>
      <pin name="USB_DP" location="W7" register="NA" offset="NA" muxModes="USB_DP"/>
      <pin name="USB_DM" location="V7" register="NA" offset="NA" muxModes="USB_DM"/>
      <pin name="USB_VBUS" location="W6" register="NA" offset="NA" muxModes="USB_VBUS"/>
      <pin name="USB_IO_ID" location="R9" register="NA" offset="NA" muxModes="USB_IO_ID"/>
      <pin name="MIPI_REXT" location="V13" register="NA" offset="NA" muxModes="MIPI_REXT"/>
      <pin name="MIPICSI_0_P" location="W14" register="NA" offset="NA" muxModes="MIPICSI_0_P"/>
      <pin name="MIPICSI_0_N" location="V14" register="NA" offset="NA" muxModes="MIPICSI_0_N"/>
      <pin name="MIPICSI_1_P" location="V15" register="NA" offset="NA" muxModes="MIPICSI_1_P"/>
      <pin name="MIPICSI_1_N" location="W15" register="NA" offset="NA" muxModes="MIPICSI_1_N"/>
      <pin name="MIPICSI_C_P" location="W16" register="NA" offset="NA" muxModes="MIPICSI_C_P"/>
      <pin name="MIPICSI_C_N" location="V16" register="NA" offset="NA" muxModes="MIPICSI_C_N"/>
      <pin name="MIPIDSI_0_P" location="W11" register="NA" offset="NA" muxModes="MIPIDSI_0_P"/>
      <pin name="MIPIDSI_0_N" location="V11" register="NA" offset="NA" muxModes="MIPIDSI_0_N"/>
      <pin name="MIPIDSI_1_P" location="W9" register="NA" offset="NA" muxModes="MIPIDSI_1_P"/>
      <pin name="MIPIDSI_1_N" location="V9" register="NA" offset="NA" muxModes="MIPIDSI_1_N"/>
      <pin name="MIPIDSI_C_P" location="V10" register="NA" offset="NA" muxModes="MIPIDSI_C_P"/>
      <pin name="MIPIDSI_C_N" location="W10" register="NA" offset="NA" muxModes="MIPIDSI_C_N"/>
    </pins>
    <clocks>
      <module name="CRC0">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>CRC0 AHB slave interface clock</clkDesc>
        </clk>
      </module>
      <module name="CRC1">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>CRC1 AHB slave interface clock</clkDesc>
        </clk>
      </module>
      <module name="IRQRTR">
        <clk name="CLKIN" clkSource="SYST_REFCLK">
          <clkDesc>IRQRTR functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="EVTRTR0">
        <clk name="CLKIN" clkSource="SYST_ACLK">
          <clkDesc>EVTRTR0 functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="EVTRTR1">
        <clk name="CLKIN" clkSource="RTSS_HP_CLK">
          <clkDesc>EVTRTR1 functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="EVTRTR2">
        <clk name="CLKIN" clkSource="RTSS_HE_CLK">
          <clkDesc>EVTRTR2 functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="DMA0_SEC">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock and DMAC functional clock</clkDesc>
        </clk>
      </module>
      <module name="DMA0_NS">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock and DMAC functional clock</clkDesc>
        </clk>
      </module>
      <module name="DMA1_SEC">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock and DMAC functional clock</clkDesc>
        </clk>
      </module>
      <module name="DMA1_NS">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock and DMAC functional clock</clkDesc>
        </clk>
      </module>
      <module name="DMA2_SEC">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock and DMAC functional clock</clkDesc>
        </clk>
      </module>
      <module name="DMA2_NS">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock and DMAC functional clock</clkDesc>
        </clk>
      </module>
      <module name="LPTIMER0">
        <clk name="LPTIMER0_CLK" clkSource="S32K_CLK, 128 kHz, or LPTMR0_CLK_IO pin (selection in TIMER_CLKSEL[SEL1] register bit)">
          <clkDesc>LPTIMER0 timer clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPTIMER0 APB bus clock</clkDesc>
        </clk>
      </module>
      <module name="LPTIMER1">
        <clk name="LPTIMER1_CLK" clkSource="S32K_CLK, 128 kHz, LPTMR1_CLK_IO pin, or LPTMR0_OUT (selection in TIMER_CLKSEL[SEL2] register bit)">
          <clkDesc>LPTIMER1 timer clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPTIMER1 APB bus clock</clkDesc>
        </clk>
      </module>
      <module name="LPTIMER2">
        <clk name="LPTIMER2_CLK" clkSource="S32K_CLK, 128 kHz, or LPTMR2_CLK_IO pin (selection in TIMER_CLKSEL[SEL3] register bit)">
          <clkDesc>LPTIMER2 timer clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPTIMER2 APB bus clock</clkDesc>
        </clk>
      </module>
      <module name="LPTIMER3">
        <clk name="LPTIMER3_CLK" clkSource="S32K_CLK, 128 kHz, LPTMR3_CLK_IO pin, or LPTMR2_OUT (selection in TIMER_CLKSEL[SEL4] register bit)">
          <clkDesc>LPTIMER3 timer clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPTIMER3 APB bus clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER0">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER1">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER2">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER3">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER4">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER5">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER6">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER7">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER8">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER9">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER10">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UTIMER11">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="QEC0">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="QEC1">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="QEC2">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="QEC3">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>Internal core clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="WDT_HP">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB interface clock</clkDesc>
        </clk>
        <clk name="WDOGCLK0" clkSource="RTSS_HP_CLK">
          <clkDesc>WDT_HP functional clock</clkDesc>
        </clk>
      </module>
      <module name="WDT_HE">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB interface clock</clkDesc>
        </clk>
        <clk name="WDOGCLK1" clkSource="RTSS_HE_CLK">
          <clkDesc>WDT_HE functional clock</clkDesc>
        </clk>
      </module>
      <module name="LPRTC">
        <clk name="LPRTC_CLK" clkSource="S32K_CLK; Clock source for S32K_CLK (LFRC or LFXO) can be selected by the clock select register bit: MISC_CTRL[SEL_32K]">
          <clkDesc>LPRTC counter clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPRTC APB bus clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO0">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO0 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO0 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO0 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO1">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO1 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO1 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO1 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO2">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO2 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO2 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO2 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO3">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO3 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO3 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO3 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO4">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO4 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO4 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO4 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO5">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO5 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO5 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO5 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO6">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO6 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO6 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO6 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO7">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO7 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO7 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO7 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO8">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO8 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO8 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO8 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO9">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO9 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO9 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO9 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO10">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO10 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO10 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO10 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO11">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO11 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO11 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO11 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO12">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO12 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO12 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO12 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO13">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO13 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO13 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO13 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="GPIO14">
        <clk name="DBCLK" clkSource="S32K_CLK / DIV; Clock gating and clock speed for GPIO debounce clock can be controlled by the GPIO_CTRLn[DB_CKEN], [DB_CKDIV] fields">
          <clkDesc>GPIO14 debounce clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>GPIO14 APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>GPIO14 interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="LPGPIO">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPGPIO APB interface clock</clkDesc>
        </clk>
        <clk name="PCLK_INTR" clkSource="SYST_PCLK">
          <clkDesc>LPGPIO interrupt clock</clkDesc>
        </clk>
      </module>
      <module name="ETH">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock. The DMA also uses this clock.</clkDesc>
        </clk>
        <clk name="CLK_CSR" clkSource="SYST_HCLK">
          <clkDesc>AHB slave interface clock</clkDesc>
        </clk>
        <clk name="CLK_PTP" clkSource="100M_CLK">
          <clkDesc>Reference clock for the timestamp update logic</clkDesc>
        </clk>
        <clk name="RMII_CLK" clkSource="ETH_CLK; Selection in ETH_CTRL0[RMII_CLKSEL]">
          <clkDesc>RMII Clock. This is the 50-MHz clock used by the RMII interface.</clkDesc>
        </clk>
        <clk name="RX_CLK" clkSource="ETH_CLK/2 or ETH_CLK/2/10; Selection in ETH_MAC_CONFIGURATION[FES]">
          <clkDesc>Receive clock</clkDesc>
        </clk>
        <clk name="TX_CLK" clkSource="ETH_CLK/2 or ETH_CLK/2/10; Selection in ETH_MAC_CONFIGURATION[FES]">
          <clkDesc>Transmit clock</clkDesc>
        </clk>
      </module>
      <module name="I2C0">
        <clk name="IC_CLK" clkSource="SYST_PCLK">
          <clkDesc>I2C0 peripheral clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>I2C0 APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="I2C1">
        <clk name="IC_CLK" clkSource="SYST_PCLK">
          <clkDesc>I2C1 peripheral clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>I2C1 APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="I2C2">
        <clk name="IC_CLK" clkSource="SYST_PCLK">
          <clkDesc>I2C2 peripheral clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>I2C2 APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="I2C3">
        <clk name="IC_CLK" clkSource="SYST_PCLK">
          <clkDesc>I2C3 peripheral clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>I2C3 APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="LPI2C">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPI2C APB interface and peripheral clock</clkDesc>
        </clk>
      </module>
      <module name="I2S0">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB slave interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Serial interface clock</clkDesc>
        </clk>
        <clk name="SCLK_N" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Inverted serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="I2S1">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB slave interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Serial interface clock</clkDesc>
        </clk>
        <clk name="SCLK_N" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Inverted serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="I2S2">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB slave interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Serial interface clock</clkDesc>
        </clk>
        <clk name="SCLK_N" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Inverted serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="I2S3">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB slave interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Serial interface clock</clkDesc>
        </clk>
        <clk name="SCLK_N" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in I2Sn_CTRL[CLK_SEL] register bit); (Divider can be controlled by the I2Sn_CTRL[CKDIV] field)">
          <clkDesc>Inverted serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="LPI2S">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB slave interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in HE_I2S_CTRL[CLK_SEL] register bit); (Divider can be controlled by the HE_I2S_CTRL[CLK_DIVISOR] field)">
          <clkDesc>Serial interface clock</clkDesc>
        </clk>
        <clk name="SCLK_N" clkSource="(76M8_CLK or AUDIO_CLK) / DIV (selection in HE_I2S_CTRL[CLK_SEL] register bit); (Divider can be controlled by the HE_I2S_CTRL[CLK_DIVISOR] field)">
          <clkDesc>Inverted serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="I3C">
        <clk name="CORE_CLK" clkSource="SYST_PCLK">
          <clkDesc>I3C core interface clock</clkDesc>
        </clk>
        <clk name="DMA_CLK" clkSource="SYST_PCLK">
          <clkDesc>I3C SDMA interface clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>I3C APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="PDM">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>PDM APB interface clock</clkDesc>
        </clk>
        <clk name="PDM_CLK" clkSource="76M8_CLK or AUDIO_CLK; Clock selection in EXPMST0_CTRL[PDM_SEL] register bit">
          <clkDesc>PDM functional clock</clkDesc>
        </clk>
      </module>
      <module name="LPPDM">
        <clk name="LPPDM_CLK" clkSource="76M8_CLK or AUDIO_CLK; Clock selection in HE_CLK_ENA[PDM_CKSEL] register bit">
          <clkDesc>LPPDM functional clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPPDM APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="SPI0">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>SPI0 AHB interface clock</clkDesc>
        </clk>
        <clk name="SPI_0_CLK" clkSource="SYST_HCLK">
          <clkDesc>SPI0 core clock is identical to AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="SPI1">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>SPI1 AHB interface clock</clkDesc>
        </clk>
        <clk name="SPI_1_CLK" clkSource="SYST_HCLK">
          <clkDesc>SPI1 core clock is identical to AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="SPI2">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>SPI2 AHB interface clock</clkDesc>
        </clk>
        <clk name="SPI_2_CLK" clkSource="SYST_HCLK">
          <clkDesc>SPI2 core clock is identical to AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="SPI3">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>SPI3 AHB interface clock</clkDesc>
        </clk>
        <clk name="SPI_3_CLK" clkSource="SYST_HCLK">
          <clkDesc>SPI3 core clock is identical to AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="LPSPI">
        <clk name="LPSPI_CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>LPSPI core clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="RTSS_HE_CLK">
          <clkDesc>LPSPI APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART0">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART0 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART0 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART1">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART1 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART1 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART2">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART2 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART2 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART3">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART3 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART3 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART4">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART4 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART4 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART5">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART5 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART5 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART6">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART6 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART6 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="UART7">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>UART7 APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="HFOSC_CLK or SYST_PCLK; (selection in UART_CTRL[CLK_SEL] register field)">
          <clkDesc>UART7 serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="LPUART">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPUART APB interface clock</clkDesc>
        </clk>
        <clk name="SCLK" clkSource="RTSS_HE_CLK">
          <clkDesc>LPUART serial interface clock</clkDesc>
        </clk>
      </module>
      <module name="USB">
        <clk name="BUS_CLK" clkSource="SYST_HCLK">
          <clkDesc>AHB interface clock</clkDesc>
        </clk>
        <clk name="REF_CLK" clkSource="10M_CLK">
          <clkDesc>REF_CLK generates the ITP counter when the UTMI PHY is in the suspended state (10 MHz)</clkDesc>
        </clk>
      </module>
      <module name="USB2PHY">
        <clk name="USB2_REFCLOCK" clkSource="USB_CLK">
          <clkDesc>PHY PLL reference clock (20 MHz)</clkDesc>
        </clk>
      </module>
      <module name="OSPI0">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>OSPI0 AHB interface clock</clkDesc>
        </clk>
        <clk name="OSPI0_CLK" clkSource="SYST_ACLK">
          <clkDesc>OSPI0 internal core clock</clkDesc>
        </clk>
      </module>
      <module name="OSPI1">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>OSPI1 AHB interface clock</clkDesc>
        </clk>
        <clk name="OSPI1_CLK" clkSource="SYST_ACLK">
          <clkDesc>OSPI1 internal core clock</clkDesc>
        </clk>
      </module>
      <module name="AES0">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AES0 AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="AES1">
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AES1 AHB interface clock</clkDesc>
        </clk>
      </module>
      <module name="SDMMC">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>AXI master interface clock</clkDesc>
        </clk>
        <clk name="BCLK" clkSource="100M_CLK">
          <clkDesc>SDMMC core base clock</clkDesc>
        </clk>
        <clk name="CCLK_RX" clkSource="For more information, see Section SDMMC Clocking">
          <clkDesc>SDMMC card receive clock</clkDesc>
        </clk>
        <clk name="CCLK_TX" clkSource="For more information, see Section SDMMC Clocking">
          <clkDesc>SDMMC card transmit clock</clkDesc>
        </clk>
        <clk name="HCLK" clkSource="SYST_HCLK">
          <clkDesc>AHB slave interface clock</clkDesc>
        </clk>
        <clk name="TMCLK" clkSource="10M_CLK">
          <clkDesc>SDMMC timer clock</clkDesc>
        </clk>
      </module>
      <module name="CPI">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>CPI AXI interface clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>CPI APB interface clock</clkDesc>
        </clk>
        <clk name="PIXEL_CLK" clkSource="Source selection in CAM_CFG[MIPI_CSI] bit and depends on the pixel data interface in use. When external camera interface is used, the CAM_PCLK polarity is controlled via CAM_CFG[PCLK_POL] bit. When MIPI CSI interface is used, the CSI PIXLCK is determined by the CSI_PIXCLK_CTRL[CLK_SEL] and [CLK_DIVISOR] fields">
          <clkDesc>CPI pixel clock</clkDesc>
        </clk>
      </module>
      <module name="LPCPI">
        <clk name="ACLK" clkSource="RTSS_HE_CLK">
          <clkDesc>LPCPI AXI interface clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>LPCPI APB interface clock</clkDesc>
        </clk>
        <clk name="PIXEL_CLK" clkSource="The LPCAM_PCLK polarity is controlled via CAM_CFG[PCLK_POL] bit">
          <clkDesc>LPCPI pixel clock</clkDesc>
        </clk>
      </module>
      <module name="CSI">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>CSI APB slave interface clock</clkDesc>
        </clk>
        <clk name="PIXCLK" clkSource="(SYST_ACLK or PLL_CLK3) / Div ; (source selection and divider value can be configured in the CSI_PIXCLK_CTRL[CLK_SEL][CLK_DIVISOR] register fields)">
          <clkDesc>CSI IPI interface pixel clock</clkDesc>
        </clk>
        <clk name="RXBYTECLKHS" clkSource="D-PHY RX">
          <clkDesc>CSI high-speed receive byte clock</clkDesc>
        </clk>
      </module>
      <module name="D-PHYRX">
        <clk name="CFG_CLK" clkSource="100M_CLK/4">
          <clkDesc>CSI D-PHY RX configuration clock (25 MHz)</clkDesc>
        </clk>
      </module>
      <module name="CDC">
        <clk name="ACLK" clkSource="SYST_ACLK">
          <clkDesc>CDC AXI master interface clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>CDC APB slave interface clock</clkDesc>
        </clk>
        <clk name="PIXEL_CLK" clkSource="(SYST_ACLK or PLL_CLK3) / Div; (source selection and divider value can be configured in the CDC200_PIXCLK_CTRL[CLK_SEL][CLK_DIVISOR] register fields)">
          <clkDesc>CDC pixel data clock</clkDesc>
        </clk>
      </module>
      <module name="DSI">
        <clk name="LANEBYTECLK" clkSource="D-PHY TX">
          <clkDesc>DSI lane byte clock</clkDesc>
        </clk>
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>DSI APB slave interface clock</clkDesc>
        </clk>
        <clk name="RXCLKESC" clkSource="D-PHY TX">
          <clkDesc>DSI RX escape clock</clkDesc>
        </clk>
      </module>
      <module name="D-PHYTX">
        <clk name="CFG_CLK" clkSource="100M_CLK/4">
          <clkDesc>D-PHY TX configuration clock (25 MHz)</clkDesc>
        </clk>
        <clk name="CLKEXT" clkSource="PLL_CLK1">
          <clkDesc>D-PHY TX PLL bypass clock (800 MHz)</clkDesc>
        </clk>
        <clk name="CLKIN" clkSource="HFOSC_CLK">
          <clkDesc>D-PHY TX PLL reference clock (38.4 MHz)</clkDesc>
        </clk>
        <clk name="TXCLKESC" clkSource="DSI">
          <clkDesc>DSI escape mode transmit clock</clkDesc>
        </clk>
      </module>
      <module name="ADC120">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="ADC121">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="ADC122">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="ADC24">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="CMP0">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Register interface clock</clkDesc>
        </clk>
      </module>
      <module name="CMP1">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Register interface clock</clkDesc>
        </clk>
      </module>
      <module name="CMP2">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Register interface clock</clkDesc>
        </clk>
      </module>
      <module name="CMP3">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>Register interface clock</clkDesc>
        </clk>
      </module>
      <module name="LPCMP">
        <clk name="CLK32K" clkSource="LFRC,LFXO">
          <clkDesc>LPCMP 32-kHz functional clock</clkDesc>
        </clk>
      </module>
      <module name="M55-HP">
        <clk name="CLKIN" clkSource="RTSS_HP_CLK">
          <clkDesc>M55-HP functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="M55-HE">
        <clk name="CLKIN" clkSource="RTSS_HE_CLK">
          <clkDesc>M55-HE functional and interface clock</clkDesc>
        </clk>
      </module>
      <module name="GPU2D">
        <clk name="CLK" clkSource="SYST_ACLK">
          <clkDesc>Functional and AXI interface clock</clkDesc>
        </clk>
      </module>
      <module name="HWSEM">
        <clk name="PCLK" clkSource="SYST_PCLK">
          <clkDesc>APB interface clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_SECPU_M55HE_0_RX">
        <clk name="CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HE_SECPU_0_TX">
        <clk name="CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_SECPU_M55HE_1_RX">
        <clk name="CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HE_SECPU_1_TX">
        <clk name="CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HP_M55HE_0_RX">
        <clk name="CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HE_M55HP_0_TX">
        <clk name="CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HP_M55HE_1_RX">
        <clk name="CLK" clkSource="RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HE_M55HP_1_TX">
        <clk name="CLK" clkSource="RTSS_HE_CLK,RTSS_HE_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_SECPU_M55HP_0_RX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HP_SECPU_0_TX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_SECPU_M55HP_1_RX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HP_SECPU_1_TX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HE_M55HP_0_RX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HP_M55HE_0_TX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HE_M55HP_1_RX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
      <module name="MHU_M55HP_M55HE_1_TX">
        <clk name="CLK" clkSource="RTSS_HP_CLK">
          <clkDesc>Interface and functional clock</clkDesc>
        </clk>
      </module>
    </clocks>
    <irqs>
      <module name="FCTLR">
        <irq name="FW_IRQ" cpuLine="IRQRTR_SII_0" cpuLineNum="0" type="Level">
          <irqDesc>FCTLR interrupt request</irqDesc>
        </irq>
      </module>
      <module name="HWSEM">
        <irq name="HWSEM_IRQ0" cpuLine="M55HE_IRQS_105,M55HP_IRQS_105,IRQRTR_SII_41" cpuLineNum="105,105,41" type="Level">
          <irqDesc>HWSEM interrupt request 0</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ1" cpuLine="M55HE_IRQS_106,M55HP_IRQS_106,IRQRTR_SII_42" cpuLineNum="106,106,42" type="Level">
          <irqDesc>HWSEM interrupt request 1</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ10" cpuLine="M55HE_IRQS_115,M55HP_IRQS_115,IRQRTR_SII_51" cpuLineNum="115,115,51" type="Level">
          <irqDesc>HWSEM interrupt request 10</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ11" cpuLine="M55HE_IRQS_116,M55HP_IRQS_116,IRQRTR_SII_52" cpuLineNum="116,116,52" type="Level">
          <irqDesc>HWSEM interrupt request 11</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ12" cpuLine="M55HE_IRQS_117,M55HP_IRQS_117,IRQRTR_SII_53" cpuLineNum="117,117,53" type="Level">
          <irqDesc>HWSEM interrupt request 12</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ13" cpuLine="M55HE_IRQS_118,M55HP_IRQS_118,IRQRTR_SII_54" cpuLineNum="118,118,54" type="Level">
          <irqDesc>HWSEM interrupt request 13</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ14" cpuLine="M55HE_IRQS_119,M55HP_IRQS_119,IRQRTR_SII_55" cpuLineNum="119,119,55" type="Level">
          <irqDesc>HWSEM interrupt request 14</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ15" cpuLine="M55HE_IRQS_120,M55HP_IRQS_120,IRQRTR_SII_56" cpuLineNum="120,120,56" type="Level">
          <irqDesc>HWSEM interrupt request 15</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ2" cpuLine="M55HE_IRQS_107,M55HP_IRQS_107,IRQRTR_SII_43" cpuLineNum="107,107,43" type="Level">
          <irqDesc>HWSEM interrupt request 2</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ3" cpuLine="M55HE_IRQS_108,M55HP_IRQS_108,IRQRTR_SII_44" cpuLineNum="108,108,44" type="Level">
          <irqDesc>HWSEM interrupt request 3</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ4" cpuLine="M55HE_IRQS_109,M55HP_IRQS_109,IRQRTR_SII_45" cpuLineNum="109,109,45" type="Level">
          <irqDesc>HWSEM interrupt request 4</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ5" cpuLine="M55HE_IRQS_110,M55HP_IRQS_110,IRQRTR_SII_46" cpuLineNum="110,110,46" type="Level">
          <irqDesc>HWSEM interrupt request 5</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ6" cpuLine="M55HE_IRQS_111,M55HP_IRQS_111,IRQRTR_SII_47" cpuLineNum="111,111,47" type="Level">
          <irqDesc>HWSEM interrupt request 6</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ7" cpuLine="M55HE_IRQS_112,M55HP_IRQS_112,IRQRTR_SII_48" cpuLineNum="112,112,48" type="Level">
          <irqDesc>HWSEM interrupt request 7</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ8" cpuLine="M55HE_IRQS_113,M55HP_IRQS_113,IRQRTR_SII_49" cpuLineNum="113,113,49" type="Level">
          <irqDesc>HWSEM interrupt request 8</irqDesc>
        </irq>
        <irq name="HWSEM_IRQ9" cpuLine="M55HE_IRQS_114,M55HP_IRQS_114,IRQRTR_SII_50" cpuLineNum="114,114,50" type="Level">
          <irqDesc>HWSEM interrupt request 9</irqDesc>
        </irq>
      </module>
      <module name="DMA0_SEC">
        <irq name="DMA0_IRQ0" cpuLine="IRQRTR_SII_235,M55HE_IRQS_299,M55HP_IRQS_299" cpuLineNum="235,299,299" type="Level">
          <irqDesc>Interrupt request 0. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ1" cpuLine="IRQRTR_SII_236,M55HE_IRQS_300,M55HP_IRQS_300" cpuLineNum="236,300,300" type="Level">
          <irqDesc>Interrupt request 1. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ10" cpuLine="IRQRTR_SII_245,M55HE_IRQS_309,M55HP_IRQS_309" cpuLineNum="245,309,309" type="Level">
          <irqDesc>Interrupt request 10. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ11" cpuLine="IRQRTR_SII_246,M55HE_IRQS_310,M55HP_IRQS_310" cpuLineNum="246,310,310" type="Level">
          <irqDesc>Interrupt request 11. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ12" cpuLine="IRQRTR_SII_247,M55HE_IRQS_311,M55HP_IRQS_311" cpuLineNum="247,311,311" type="Level">
          <irqDesc>Interrupt request 12. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ13" cpuLine="IRQRTR_SII_248,M55HE_IRQS_312,M55HP_IRQS_312" cpuLineNum="248,312,312" type="Level">
          <irqDesc>Interrupt request 13. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ14" cpuLine="IRQRTR_SII_249,M55HE_IRQS_313,M55HP_IRQS_313" cpuLineNum="249,313,313" type="Level">
          <irqDesc>Interrupt request 14. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ15" cpuLine="IRQRTR_SII_250,M55HE_IRQS_314,M55HP_IRQS_314" cpuLineNum="250,314,314" type="Level">
          <irqDesc>Interrupt request 15. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ16" cpuLine="IRQRTR_SII_251,M55HE_IRQS_315,M55HP_IRQS_315" cpuLineNum="251,315,315" type="Level">
          <irqDesc>Interrupt request 16. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ17" cpuLine="IRQRTR_SII_252,M55HE_IRQS_316,M55HP_IRQS_316" cpuLineNum="252,316,316" type="Level">
          <irqDesc>Interrupt request 17. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ18" cpuLine="IRQRTR_SII_253,M55HE_IRQS_317,M55HP_IRQS_317" cpuLineNum="253,317,317" type="Level">
          <irqDesc>Interrupt request 18. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ19" cpuLine="IRQRTR_SII_254,M55HE_IRQS_318,M55HP_IRQS_318" cpuLineNum="254,318,318" type="Level">
          <irqDesc>Interrupt request 19. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ2" cpuLine="IRQRTR_SII_237,M55HE_IRQS_301,M55HP_IRQS_301" cpuLineNum="237,301,301" type="Level">
          <irqDesc>Interrupt request 2. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ20" cpuLine="IRQRTR_SII_255,M55HE_IRQS_319,M55HP_IRQS_319" cpuLineNum="255,319,319" type="Level">
          <irqDesc>Interrupt request 20. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ21" cpuLine="IRQRTR_SII_256,M55HE_IRQS_320,M55HP_IRQS_320" cpuLineNum="256,320,320" type="Level">
          <irqDesc>Interrupt request 21. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ22" cpuLine="IRQRTR_SII_257,M55HE_IRQS_321,M55HP_IRQS_321" cpuLineNum="257,321,321" type="Level">
          <irqDesc>Interrupt request 22. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ23" cpuLine="IRQRTR_SII_258,M55HE_IRQS_322,M55HP_IRQS_322" cpuLineNum="258,322,322" type="Level">
          <irqDesc>Interrupt request 23. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ24" cpuLine="IRQRTR_SII_259,M55HE_IRQS_323,M55HP_IRQS_323" cpuLineNum="259,323,323" type="Level">
          <irqDesc>Interrupt request 24. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ25" cpuLine="IRQRTR_SII_260,M55HE_IRQS_324,M55HP_IRQS_324" cpuLineNum="260,324,324" type="Level">
          <irqDesc>Interrupt request 25. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ26" cpuLine="IRQRTR_SII_261,M55HE_IRQS_325,M55HP_IRQS_325" cpuLineNum="261,325,325" type="Level">
          <irqDesc>Interrupt request 26. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ27" cpuLine="IRQRTR_SII_262,M55HE_IRQS_326,M55HP_IRQS_326" cpuLineNum="262,326,326" type="Level">
          <irqDesc>Interrupt request 27. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ28" cpuLine="IRQRTR_SII_263,M55HE_IRQS_327,M55HP_IRQS_327" cpuLineNum="263,327,327" type="Level">
          <irqDesc>Interrupt request 28. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ29" cpuLine="IRQRTR_SII_264,M55HE_IRQS_328,M55HP_IRQS_328" cpuLineNum="264,328,328" type="Level">
          <irqDesc>Interrupt request 29. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ3" cpuLine="IRQRTR_SII_238,M55HE_IRQS_302,M55HP_IRQS_302" cpuLineNum="238,302,302" type="Level">
          <irqDesc>Interrupt request 3. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ30" cpuLine="IRQRTR_SII_265,M55HE_IRQS_329,M55HP_IRQS_329" cpuLineNum="265,329,329" type="Level">
          <irqDesc>Interrupt request 30. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ31" cpuLine="IRQRTR_SII_266,M55HE_IRQS_330,M55HP_IRQS_330" cpuLineNum="266,330,330" type="Level">
          <irqDesc>Interrupt request 31. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ4" cpuLine="IRQRTR_SII_239,M55HE_IRQS_303,M55HP_IRQS_303" cpuLineNum="239,303,303" type="Level">
          <irqDesc>Interrupt request 4. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ5" cpuLine="IRQRTR_SII_240,M55HE_IRQS_304,M55HP_IRQS_304" cpuLineNum="240,304,304" type="Level">
          <irqDesc>Interrupt request 5. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ6" cpuLine="IRQRTR_SII_241,M55HE_IRQS_305,M55HP_IRQS_305" cpuLineNum="241,305,305" type="Level">
          <irqDesc>Interrupt request 6. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ7" cpuLine="IRQRTR_SII_242,M55HE_IRQS_306,M55HP_IRQS_306" cpuLineNum="242,306,306" type="Level">
          <irqDesc>Interrupt request 7. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ8" cpuLine="IRQRTR_SII_243,M55HE_IRQS_307,M55HP_IRQS_307" cpuLineNum="243,307,307" type="Level">
          <irqDesc>Interrupt request 8. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ9" cpuLine="IRQRTR_SII_244,M55HE_IRQS_308,M55HP_IRQS_308" cpuLineNum="244,308,308" type="Level">
          <irqDesc>Interrupt request 9. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ_ABORT" cpuLine="IRQRTR_SII_267,M55HE_IRQS_331,M55HP_IRQS_331" cpuLineNum="267,331,331" type="Level">
          <irqDesc>DMAC aborted execution of a program thread.</irqDesc>
        </irq>
      </module>
      <module name="DMA0_NS">
        <irq name="DMA0_IRQ0" cpuLine="IRQRTR_SII_235,M55HE_IRQS_299,M55HP_IRQS_299" cpuLineNum="235,299,299" type="Level">
          <irqDesc>Interrupt request 0. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ1" cpuLine="IRQRTR_SII_236,M55HE_IRQS_300,M55HP_IRQS_300" cpuLineNum="236,300,300" type="Level">
          <irqDesc>Interrupt request 1. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ10" cpuLine="IRQRTR_SII_245,M55HE_IRQS_309,M55HP_IRQS_309" cpuLineNum="245,309,309" type="Level">
          <irqDesc>Interrupt request 10. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ11" cpuLine="IRQRTR_SII_246,M55HE_IRQS_310,M55HP_IRQS_310" cpuLineNum="246,310,310" type="Level">
          <irqDesc>Interrupt request 11. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ12" cpuLine="IRQRTR_SII_247,M55HE_IRQS_311,M55HP_IRQS_311" cpuLineNum="247,311,311" type="Level">
          <irqDesc>Interrupt request 12. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ13" cpuLine="IRQRTR_SII_248,M55HE_IRQS_312,M55HP_IRQS_312" cpuLineNum="248,312,312" type="Level">
          <irqDesc>Interrupt request 13. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ14" cpuLine="IRQRTR_SII_249,M55HE_IRQS_313,M55HP_IRQS_313" cpuLineNum="249,313,313" type="Level">
          <irqDesc>Interrupt request 14. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ15" cpuLine="IRQRTR_SII_250,M55HE_IRQS_314,M55HP_IRQS_314" cpuLineNum="250,314,314" type="Level">
          <irqDesc>Interrupt request 15. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ16" cpuLine="IRQRTR_SII_251,M55HE_IRQS_315,M55HP_IRQS_315" cpuLineNum="251,315,315" type="Level">
          <irqDesc>Interrupt request 16. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ17" cpuLine="IRQRTR_SII_252,M55HE_IRQS_316,M55HP_IRQS_316" cpuLineNum="252,316,316" type="Level">
          <irqDesc>Interrupt request 17. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ18" cpuLine="IRQRTR_SII_253,M55HE_IRQS_317,M55HP_IRQS_317" cpuLineNum="253,317,317" type="Level">
          <irqDesc>Interrupt request 18. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ19" cpuLine="IRQRTR_SII_254,M55HE_IRQS_318,M55HP_IRQS_318" cpuLineNum="254,318,318" type="Level">
          <irqDesc>Interrupt request 19. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ2" cpuLine="IRQRTR_SII_237,M55HE_IRQS_301,M55HP_IRQS_301" cpuLineNum="237,301,301" type="Level">
          <irqDesc>Interrupt request 2. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ20" cpuLine="IRQRTR_SII_255,M55HE_IRQS_319,M55HP_IRQS_319" cpuLineNum="255,319,319" type="Level">
          <irqDesc>Interrupt request 20. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ21" cpuLine="IRQRTR_SII_256,M55HE_IRQS_320,M55HP_IRQS_320" cpuLineNum="256,320,320" type="Level">
          <irqDesc>Interrupt request 21. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ22" cpuLine="IRQRTR_SII_257,M55HE_IRQS_321,M55HP_IRQS_321" cpuLineNum="257,321,321" type="Level">
          <irqDesc>Interrupt request 22. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ23" cpuLine="IRQRTR_SII_258,M55HE_IRQS_322,M55HP_IRQS_322" cpuLineNum="258,322,322" type="Level">
          <irqDesc>Interrupt request 23. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ24" cpuLine="IRQRTR_SII_259,M55HE_IRQS_323,M55HP_IRQS_323" cpuLineNum="259,323,323" type="Level">
          <irqDesc>Interrupt request 24. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ25" cpuLine="IRQRTR_SII_260,M55HE_IRQS_324,M55HP_IRQS_324" cpuLineNum="260,324,324" type="Level">
          <irqDesc>Interrupt request 25. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ26" cpuLine="IRQRTR_SII_261,M55HE_IRQS_325,M55HP_IRQS_325" cpuLineNum="261,325,325" type="Level">
          <irqDesc>Interrupt request 26. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ27" cpuLine="IRQRTR_SII_262,M55HE_IRQS_326,M55HP_IRQS_326" cpuLineNum="262,326,326" type="Level">
          <irqDesc>Interrupt request 27. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ28" cpuLine="IRQRTR_SII_263,M55HE_IRQS_327,M55HP_IRQS_327" cpuLineNum="263,327,327" type="Level">
          <irqDesc>Interrupt request 28. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ29" cpuLine="IRQRTR_SII_264,M55HE_IRQS_328,M55HP_IRQS_328" cpuLineNum="264,328,328" type="Level">
          <irqDesc>Interrupt request 29. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ3" cpuLine="IRQRTR_SII_238,M55HE_IRQS_302,M55HP_IRQS_302" cpuLineNum="238,302,302" type="Level">
          <irqDesc>Interrupt request 3. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ30" cpuLine="IRQRTR_SII_265,M55HE_IRQS_329,M55HP_IRQS_329" cpuLineNum="265,329,329" type="Level">
          <irqDesc>Interrupt request 30. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ31" cpuLine="IRQRTR_SII_266,M55HE_IRQS_330,M55HP_IRQS_330" cpuLineNum="266,330,330" type="Level">
          <irqDesc>Interrupt request 31. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ4" cpuLine="IRQRTR_SII_239,M55HE_IRQS_303,M55HP_IRQS_303" cpuLineNum="239,303,303" type="Level">
          <irqDesc>Interrupt request 4. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ5" cpuLine="IRQRTR_SII_240,M55HE_IRQS_304,M55HP_IRQS_304" cpuLineNum="240,304,304" type="Level">
          <irqDesc>Interrupt request 5. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ6" cpuLine="IRQRTR_SII_241,M55HE_IRQS_305,M55HP_IRQS_305" cpuLineNum="241,305,305" type="Level">
          <irqDesc>Interrupt request 6. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ7" cpuLine="IRQRTR_SII_242,M55HE_IRQS_306,M55HP_IRQS_306" cpuLineNum="242,306,306" type="Level">
          <irqDesc>Interrupt request 7. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ8" cpuLine="IRQRTR_SII_243,M55HE_IRQS_307,M55HP_IRQS_307" cpuLineNum="243,307,307" type="Level">
          <irqDesc>Interrupt request 8. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ9" cpuLine="IRQRTR_SII_244,M55HE_IRQS_308,M55HP_IRQS_308" cpuLineNum="244,308,308" type="Level">
          <irqDesc>Interrupt request 9. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA0_IRQ_ABORT" cpuLine="IRQRTR_SII_267,M55HE_IRQS_331,M55HP_IRQS_331" cpuLineNum="267,331,331" type="Level">
          <irqDesc>DMAC aborted execution of a program thread.</irqDesc>
        </irq>
      </module>
      <module name="GPIO0">
        <irq name="GPIO0_IRQ0" cpuLine="IRQRTR_SII_115,M55HE_IRQS_179,M55HP_IRQS_179" cpuLineNum="115,179,179" type="Level">
          <irqDesc>GPIO0 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO0_IRQ1" cpuLine="IRQRTR_SII_116,M55HE_IRQS_180,M55HP_IRQS_180" cpuLineNum="116,180,180" type="Level">
          <irqDesc>GPIO0 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO0_IRQ2" cpuLine="IRQRTR_SII_117,M55HE_IRQS_181,M55HP_IRQS_181" cpuLineNum="117,181,181" type="Level">
          <irqDesc>GPIO0 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO0_IRQ3" cpuLine="IRQRTR_SII_118,M55HE_IRQS_182,M55HP_IRQS_182" cpuLineNum="118,182,182" type="Level">
          <irqDesc>GPIO0 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO0_IRQ4" cpuLine="IRQRTR_SII_119,M55HE_IRQS_183,M55HP_IRQS_183" cpuLineNum="119,183,183" type="Level">
          <irqDesc>GPIO0 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO0_IRQ5" cpuLine="IRQRTR_SII_120,M55HE_IRQS_184,M55HP_IRQS_184" cpuLineNum="120,184,184" type="Level">
          <irqDesc>GPIO0 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO0_IRQ6" cpuLine="IRQRTR_SII_121,M55HE_IRQS_185,M55HP_IRQS_185" cpuLineNum="121,185,185" type="Level">
          <irqDesc>GPIO0 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO0_IRQ7" cpuLine="IRQRTR_SII_122,M55HE_IRQS_186,M55HP_IRQS_186" cpuLineNum="122,186,186" type="Level">
          <irqDesc>GPIO0 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO1">
        <irq name="GPIO1_IRQ0" cpuLine="IRQRTR_SII_123,M55HE_IRQS_187,M55HP_IRQS_187" cpuLineNum="123,187,187" type="Level">
          <irqDesc>GPIO1 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO1_IRQ1" cpuLine="IRQRTR_SII_124,M55HE_IRQS_188,M55HP_IRQS_188" cpuLineNum="124,188,188" type="Level">
          <irqDesc>GPIO1 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO1_IRQ2" cpuLine="IRQRTR_SII_125,M55HE_IRQS_189,M55HP_IRQS_189" cpuLineNum="125,189,189" type="Level">
          <irqDesc>GPIO1 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO1_IRQ3" cpuLine="IRQRTR_SII_126,M55HE_IRQS_190,M55HP_IRQS_190" cpuLineNum="126,190,190" type="Level">
          <irqDesc>GPIO1 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO1_IRQ4" cpuLine="IRQRTR_SII_127,M55HE_IRQS_191,M55HP_IRQS_191" cpuLineNum="127,191,191" type="Level">
          <irqDesc>GPIO1 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO1_IRQ5" cpuLine="IRQRTR_SII_128,M55HE_IRQS_192,M55HP_IRQS_192" cpuLineNum="128,192,192" type="Level">
          <irqDesc>GPIO1 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO1_IRQ6" cpuLine="IRQRTR_SII_129,M55HE_IRQS_193,M55HP_IRQS_193" cpuLineNum="129,193,193" type="Level">
          <irqDesc>GPIO1 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO1_IRQ7" cpuLine="IRQRTR_SII_130,M55HE_IRQS_194,M55HP_IRQS_194" cpuLineNum="130,194,194" type="Level">
          <irqDesc>GPIO1 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO2">
        <irq name="GPIO2_IRQ0" cpuLine="IRQRTR_SII_131,M55HE_IRQS_195,M55HP_IRQS_195" cpuLineNum="131,195,195" type="Level">
          <irqDesc>GPIO2 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO2_IRQ1" cpuLine="IRQRTR_SII_132,M55HE_IRQS_196,M55HP_IRQS_196" cpuLineNum="132,196,196" type="Level">
          <irqDesc>GPIO2 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO2_IRQ2" cpuLine="IRQRTR_SII_133,M55HE_IRQS_197,M55HP_IRQS_197" cpuLineNum="133,197,197" type="Level">
          <irqDesc>GPIO2 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO2_IRQ3" cpuLine="IRQRTR_SII_134,M55HE_IRQS_198,M55HP_IRQS_198" cpuLineNum="134,198,198" type="Level">
          <irqDesc>GPIO2 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO2_IRQ4" cpuLine="IRQRTR_SII_135,M55HE_IRQS_199,M55HP_IRQS_199" cpuLineNum="135,199,199" type="Level">
          <irqDesc>GPIO2 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO2_IRQ5" cpuLine="IRQRTR_SII_136,M55HE_IRQS_200,M55HP_IRQS_200" cpuLineNum="136,200,200" type="Level">
          <irqDesc>GPIO2 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO2_IRQ6" cpuLine="IRQRTR_SII_137,M55HE_IRQS_201,M55HP_IRQS_201" cpuLineNum="137,201,201" type="Level">
          <irqDesc>GPIO2 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO2_IRQ7" cpuLine="IRQRTR_SII_138,M55HE_IRQS_202,M55HP_IRQS_202" cpuLineNum="138,202,202" type="Level">
          <irqDesc>GPIO2 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO3">
        <irq name="GPIO3_IRQ0" cpuLine="IRQRTR_SII_139,M55HE_IRQS_203,M55HP_IRQS_203" cpuLineNum="139,203,203" type="Level">
          <irqDesc>GPIO3 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO3_IRQ1" cpuLine="IRQRTR_SII_140,M55HE_IRQS_204,M55HP_IRQS_204" cpuLineNum="140,204,204" type="Level">
          <irqDesc>GPIO3 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO3_IRQ2" cpuLine="IRQRTR_SII_141,M55HE_IRQS_205,M55HP_IRQS_205" cpuLineNum="141,205,205" type="Level">
          <irqDesc>GPIO3 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO3_IRQ3" cpuLine="IRQRTR_SII_142,M55HE_IRQS_206,M55HP_IRQS_206" cpuLineNum="142,206,206" type="Level">
          <irqDesc>GPIO3 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO3_IRQ4" cpuLine="IRQRTR_SII_143,M55HE_IRQS_207,M55HP_IRQS_207" cpuLineNum="143,207,207" type="Level">
          <irqDesc>GPIO3 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO3_IRQ5" cpuLine="IRQRTR_SII_144,M55HE_IRQS_208,M55HP_IRQS_208" cpuLineNum="144,208,208" type="Level">
          <irqDesc>GPIO3 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO3_IRQ6" cpuLine="IRQRTR_SII_145,M55HE_IRQS_209,M55HP_IRQS_209" cpuLineNum="145,209,209" type="Level">
          <irqDesc>GPIO3 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO3_IRQ7" cpuLine="IRQRTR_SII_146,M55HE_IRQS_210,M55HP_IRQS_210" cpuLineNum="146,210,210" type="Level">
          <irqDesc>GPIO3 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO4">
        <irq name="GPIO4_IRQ0" cpuLine="IRQRTR_SII_147,M55HE_IRQS_211,M55HP_IRQS_211" cpuLineNum="147,211,211" type="Level">
          <irqDesc>GPIO4 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO4_IRQ1" cpuLine="IRQRTR_SII_148,M55HE_IRQS_212,M55HP_IRQS_212" cpuLineNum="148,212,212" type="Level">
          <irqDesc>GPIO4 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO4_IRQ2" cpuLine="IRQRTR_SII_149,M55HE_IRQS_213,M55HP_IRQS_213" cpuLineNum="149,213,213" type="Level">
          <irqDesc>GPIO4 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO4_IRQ3" cpuLine="IRQRTR_SII_150,M55HE_IRQS_214,M55HP_IRQS_214" cpuLineNum="150,214,214" type="Level">
          <irqDesc>GPIO4 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO4_IRQ4" cpuLine="IRQRTR_SII_151,M55HE_IRQS_215,M55HP_IRQS_215" cpuLineNum="151,215,215" type="Level">
          <irqDesc>GPIO4 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO4_IRQ5" cpuLine="IRQRTR_SII_152,M55HE_IRQS_216,M55HP_IRQS_216" cpuLineNum="152,216,216" type="Level">
          <irqDesc>GPIO4 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO4_IRQ6" cpuLine="IRQRTR_SII_153,M55HE_IRQS_217,M55HP_IRQS_217" cpuLineNum="153,217,217" type="Level">
          <irqDesc>GPIO4 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO4_IRQ7" cpuLine="IRQRTR_SII_154,M55HE_IRQS_218,M55HP_IRQS_218" cpuLineNum="154,218,218" type="Level">
          <irqDesc>GPIO4 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO5">
        <irq name="GPIO5_IRQ0" cpuLine="IRQRTR_SII_155,M55HE_IRQS_219,M55HP_IRQS_219" cpuLineNum="155,219,219" type="Level">
          <irqDesc>GPIO5 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO5_IRQ1" cpuLine="IRQRTR_SII_156,M55HE_IRQS_220,M55HP_IRQS_220" cpuLineNum="156,220,220" type="Level">
          <irqDesc>GPIO5 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO5_IRQ2" cpuLine="IRQRTR_SII_157,M55HE_IRQS_221,M55HP_IRQS_221" cpuLineNum="157,221,221" type="Level">
          <irqDesc>GPIO5 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO5_IRQ3" cpuLine="IRQRTR_SII_158,M55HE_IRQS_222,M55HP_IRQS_222" cpuLineNum="158,222,222" type="Level">
          <irqDesc>GPIO5 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO5_IRQ4" cpuLine="IRQRTR_SII_159,M55HE_IRQS_223,M55HP_IRQS_223" cpuLineNum="159,223,223" type="Level">
          <irqDesc>GPIO5 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO5_IRQ5" cpuLine="IRQRTR_SII_160,M55HE_IRQS_224,M55HP_IRQS_224" cpuLineNum="160,224,224" type="Level">
          <irqDesc>GPIO5 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO5_IRQ6" cpuLine="IRQRTR_SII_161,M55HE_IRQS_225,M55HP_IRQS_225" cpuLineNum="161,225,225" type="Level">
          <irqDesc>GPIO5 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO5_IRQ7" cpuLine="IRQRTR_SII_162,M55HE_IRQS_226,M55HP_IRQS_226" cpuLineNum="162,226,226" type="Level">
          <irqDesc>GPIO5 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO6">
        <irq name="GPIO6_IRQ0" cpuLine="IRQRTR_SII_163,M55HE_IRQS_227,M55HP_IRQS_227" cpuLineNum="163,227,227" type="Level">
          <irqDesc>GPIO6 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO6_IRQ1" cpuLine="IRQRTR_SII_164,M55HE_IRQS_228,M55HP_IRQS_228" cpuLineNum="164,228,228" type="Level">
          <irqDesc>GPIO6 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO6_IRQ2" cpuLine="IRQRTR_SII_165,M55HE_IRQS_229,M55HP_IRQS_229" cpuLineNum="165,229,229" type="Level">
          <irqDesc>GPIO6 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO6_IRQ3" cpuLine="IRQRTR_SII_166,M55HE_IRQS_230,M55HP_IRQS_230" cpuLineNum="166,230,230" type="Level">
          <irqDesc>GPIO6 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO6_IRQ4" cpuLine="IRQRTR_SII_167,M55HE_IRQS_231,M55HP_IRQS_231" cpuLineNum="167,231,231" type="Level">
          <irqDesc>GPIO6 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO6_IRQ5" cpuLine="IRQRTR_SII_168,M55HE_IRQS_232,M55HP_IRQS_232" cpuLineNum="168,232,232" type="Level">
          <irqDesc>GPIO6 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO6_IRQ6" cpuLine="IRQRTR_SII_169,M55HE_IRQS_233,M55HP_IRQS_233" cpuLineNum="169,233,233" type="Level">
          <irqDesc>GPIO6 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO6_IRQ7" cpuLine="IRQRTR_SII_170,M55HE_IRQS_234,M55HP_IRQS_234" cpuLineNum="170,234,234" type="Level">
          <irqDesc>GPIO6 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO7">
        <irq name="GPIO7_IRQ0" cpuLine="IRQRTR_SII_171,M55HE_IRQS_235,M55HP_IRQS_235" cpuLineNum="171,235,235" type="Level">
          <irqDesc>GPIO7 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO7_IRQ1" cpuLine="IRQRTR_SII_172,M55HE_IRQS_236,M55HP_IRQS_236" cpuLineNum="172,236,236" type="Level">
          <irqDesc>GPIO7 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO7_IRQ2" cpuLine="IRQRTR_SII_173,M55HE_IRQS_237,M55HP_IRQS_237" cpuLineNum="173,237,237" type="Level">
          <irqDesc>GPIO7 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO7_IRQ3" cpuLine="IRQRTR_SII_174,M55HE_IRQS_238,M55HP_IRQS_238" cpuLineNum="174,238,238" type="Level">
          <irqDesc>GPIO7 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO7_IRQ4" cpuLine="IRQRTR_SII_175,M55HE_IRQS_239,M55HP_IRQS_239" cpuLineNum="175,239,239" type="Level">
          <irqDesc>GPIO7 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO7_IRQ5" cpuLine="IRQRTR_SII_176,M55HE_IRQS_240,M55HP_IRQS_240" cpuLineNum="176,240,240" type="Level">
          <irqDesc>GPIO7 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO7_IRQ6" cpuLine="IRQRTR_SII_177,M55HE_IRQS_241,M55HP_IRQS_241" cpuLineNum="177,241,241" type="Level">
          <irqDesc>GPIO7 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO7_IRQ7" cpuLine="IRQRTR_SII_178,M55HE_IRQS_242,M55HP_IRQS_242" cpuLineNum="178,242,242" type="Level">
          <irqDesc>GPIO7 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO8">
        <irq name="GPIO8_IRQ0" cpuLine="IRQRTR_SII_179,M55HE_IRQS_243,M55HP_IRQS_243" cpuLineNum="179,243,243" type="Level">
          <irqDesc>GPIO8 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO8_IRQ1" cpuLine="IRQRTR_SII_180,M55HE_IRQS_244,M55HP_IRQS_244" cpuLineNum="180,244,244" type="Level">
          <irqDesc>GPIO8 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO8_IRQ2" cpuLine="IRQRTR_SII_181,M55HE_IRQS_245,M55HP_IRQS_245" cpuLineNum="181,245,245" type="Level">
          <irqDesc>GPIO8 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO8_IRQ3" cpuLine="IRQRTR_SII_182,M55HE_IRQS_246,M55HP_IRQS_246" cpuLineNum="182,246,246" type="Level">
          <irqDesc>GPIO8 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO8_IRQ4" cpuLine="IRQRTR_SII_183,M55HE_IRQS_247,M55HP_IRQS_247" cpuLineNum="183,247,247" type="Level">
          <irqDesc>GPIO8 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO8_IRQ5" cpuLine="IRQRTR_SII_184,M55HE_IRQS_248,M55HP_IRQS_248" cpuLineNum="184,248,248" type="Level">
          <irqDesc>GPIO8 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO8_IRQ6" cpuLine="IRQRTR_SII_185,M55HE_IRQS_249,M55HP_IRQS_249" cpuLineNum="185,249,249" type="Level">
          <irqDesc>GPIO8 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO8_IRQ7" cpuLine="IRQRTR_SII_186,M55HE_IRQS_250,M55HP_IRQS_250" cpuLineNum="186,250,250" type="Level">
          <irqDesc>GPIO8 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO9">
        <irq name="GPIO9_IRQ0" cpuLine="IRQRTR_SII_187,M55HE_IRQS_251,M55HP_IRQS_251" cpuLineNum="187,251,251" type="Level">
          <irqDesc>GPIO9 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO9_IRQ1" cpuLine="IRQRTR_SII_188,M55HE_IRQS_252,M55HP_IRQS_252" cpuLineNum="188,252,252" type="Level">
          <irqDesc>GPIO9 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO9_IRQ2" cpuLine="IRQRTR_SII_189,M55HE_IRQS_253,M55HP_IRQS_253" cpuLineNum="189,253,253" type="Level">
          <irqDesc>GPIO9 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO9_IRQ3" cpuLine="IRQRTR_SII_190,M55HE_IRQS_254,M55HP_IRQS_254" cpuLineNum="190,254,254" type="Level">
          <irqDesc>GPIO9 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO9_IRQ4" cpuLine="IRQRTR_SII_191,M55HE_IRQS_255,M55HP_IRQS_255" cpuLineNum="191,255,255" type="Level">
          <irqDesc>GPIO9 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO9_IRQ5" cpuLine="IRQRTR_SII_192,M55HE_IRQS_256,M55HP_IRQS_256" cpuLineNum="192,256,256" type="Level">
          <irqDesc>GPIO9 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO9_IRQ6" cpuLine="IRQRTR_SII_193,M55HE_IRQS_257,M55HP_IRQS_257" cpuLineNum="193,257,257" type="Level">
          <irqDesc>GPIO9 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO9_IRQ7" cpuLine="IRQRTR_SII_194,M55HE_IRQS_258,M55HP_IRQS_258" cpuLineNum="194,258,258" type="Level">
          <irqDesc>GPIO9 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO10">
        <irq name="GPIO10_IRQ0" cpuLine="IRQRTR_SII_195,M55HE_IRQS_259,M55HP_IRQS_259" cpuLineNum="195,259,259" type="Level">
          <irqDesc>GPIO10 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO10_IRQ1" cpuLine="IRQRTR_SII_196,M55HE_IRQS_260,M55HP_IRQS_260" cpuLineNum="196,260,260" type="Level">
          <irqDesc>GPIO10 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO10_IRQ2" cpuLine="IRQRTR_SII_197,M55HE_IRQS_261,M55HP_IRQS_261" cpuLineNum="197,261,261" type="Level">
          <irqDesc>GPIO10 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO10_IRQ3" cpuLine="IRQRTR_SII_198,M55HE_IRQS_262,M55HP_IRQS_262" cpuLineNum="198,262,262" type="Level">
          <irqDesc>GPIO10 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO10_IRQ4" cpuLine="IRQRTR_SII_199,M55HE_IRQS_263,M55HP_IRQS_263" cpuLineNum="199,263,263" type="Level">
          <irqDesc>GPIO10 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO10_IRQ5" cpuLine="IRQRTR_SII_200,M55HE_IRQS_264,M55HP_IRQS_264" cpuLineNum="200,264,264" type="Level">
          <irqDesc>GPIO10 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO10_IRQ6" cpuLine="IRQRTR_SII_201,M55HE_IRQS_265,M55HP_IRQS_265" cpuLineNum="201,265,265" type="Level">
          <irqDesc>GPIO10 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO10_IRQ7" cpuLine="IRQRTR_SII_202,M55HE_IRQS_266,M55HP_IRQS_266" cpuLineNum="202,266,266" type="Level">
          <irqDesc>GPIO10 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO11">
        <irq name="GPIO11_IRQ0" cpuLine="IRQRTR_SII_203,M55HE_IRQS_267,M55HP_IRQS_267" cpuLineNum="203,267,267" type="Level">
          <irqDesc>GPIO11 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO11_IRQ1" cpuLine="IRQRTR_SII_204,M55HE_IRQS_268,M55HP_IRQS_268" cpuLineNum="204,268,268" type="Level">
          <irqDesc>GPIO11 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO11_IRQ2" cpuLine="IRQRTR_SII_205,M55HE_IRQS_269,M55HP_IRQS_269" cpuLineNum="205,269,269" type="Level">
          <irqDesc>GPIO11 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO11_IRQ3" cpuLine="IRQRTR_SII_206,M55HE_IRQS_270,M55HP_IRQS_270" cpuLineNum="206,270,270" type="Level">
          <irqDesc>GPIO11 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO11_IRQ4" cpuLine="IRQRTR_SII_207,M55HE_IRQS_271,M55HP_IRQS_271" cpuLineNum="207,271,271" type="Level">
          <irqDesc>GPIO11 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO11_IRQ5" cpuLine="IRQRTR_SII_208,M55HE_IRQS_272,M55HP_IRQS_272" cpuLineNum="208,272,272" type="Level">
          <irqDesc>GPIO11 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO11_IRQ6" cpuLine="IRQRTR_SII_209,M55HE_IRQS_273,M55HP_IRQS_273" cpuLineNum="209,273,273" type="Level">
          <irqDesc>GPIO11 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO11_IRQ7" cpuLine="IRQRTR_SII_210,M55HE_IRQS_274,M55HP_IRQS_274" cpuLineNum="210,274,274" type="Level">
          <irqDesc>GPIO11 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO12">
        <irq name="GPIO12_IRQ0" cpuLine="IRQRTR_SII_211,M55HE_IRQS_275,M55HP_IRQS_275" cpuLineNum="211,275,275" type="Level">
          <irqDesc>GPIO12 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO12_IRQ1" cpuLine="IRQRTR_SII_212,M55HE_IRQS_276,M55HP_IRQS_276" cpuLineNum="212,276,276" type="Level">
          <irqDesc>GPIO12 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO12_IRQ2" cpuLine="IRQRTR_SII_213,M55HE_IRQS_277,M55HP_IRQS_277" cpuLineNum="213,277,277" type="Level">
          <irqDesc>GPIO12 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO12_IRQ3" cpuLine="IRQRTR_SII_214,M55HE_IRQS_278,M55HP_IRQS_278" cpuLineNum="214,278,278" type="Level">
          <irqDesc>GPIO12 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO12_IRQ4" cpuLine="IRQRTR_SII_215,M55HE_IRQS_279,M55HP_IRQS_279" cpuLineNum="215,279,279" type="Level">
          <irqDesc>GPIO12 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO12_IRQ5" cpuLine="IRQRTR_SII_216,M55HE_IRQS_280,M55HP_IRQS_280" cpuLineNum="216,280,280" type="Level">
          <irqDesc>GPIO12 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO12_IRQ6" cpuLine="IRQRTR_SII_217,M55HE_IRQS_281,M55HP_IRQS_281" cpuLineNum="217,281,281" type="Level">
          <irqDesc>GPIO12 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO12_IRQ7" cpuLine="IRQRTR_SII_218,M55HE_IRQS_282,M55HP_IRQS_282" cpuLineNum="218,282,282" type="Level">
          <irqDesc>GPIO12 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO13">
        <irq name="GPIO13_IRQ0" cpuLine="IRQRTR_SII_219,M55HE_IRQS_283,M55HP_IRQS_283" cpuLineNum="219,283,283" type="Level">
          <irqDesc>GPIO13 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO13_IRQ1" cpuLine="IRQRTR_SII_220,M55HE_IRQS_284,M55HP_IRQS_284" cpuLineNum="220,284,284" type="Level">
          <irqDesc>GPIO13 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO13_IRQ2" cpuLine="IRQRTR_SII_221,M55HE_IRQS_285,M55HP_IRQS_285" cpuLineNum="221,285,285" type="Level">
          <irqDesc>GPIO13 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO13_IRQ3" cpuLine="IRQRTR_SII_222,M55HE_IRQS_286,M55HP_IRQS_286" cpuLineNum="222,286,286" type="Level">
          <irqDesc>GPIO13 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO13_IRQ4" cpuLine="IRQRTR_SII_223,M55HE_IRQS_287,M55HP_IRQS_287" cpuLineNum="223,287,287" type="Level">
          <irqDesc>GPIO13 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO13_IRQ5" cpuLine="IRQRTR_SII_224,M55HE_IRQS_288,M55HP_IRQS_288" cpuLineNum="224,288,288" type="Level">
          <irqDesc>GPIO13 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO13_IRQ6" cpuLine="IRQRTR_SII_225,M55HE_IRQS_289,M55HP_IRQS_289" cpuLineNum="225,289,289" type="Level">
          <irqDesc>GPIO13 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO13_IRQ7" cpuLine="IRQRTR_SII_226,M55HE_IRQS_290,M55HP_IRQS_290" cpuLineNum="226,290,290" type="Level">
          <irqDesc>GPIO13 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="GPIO14">
        <irq name="GPIO14_IRQ0" cpuLine="IRQRTR_SII_227,M55HE_IRQS_291,M55HP_IRQS_291" cpuLineNum="227,291,291" type="Level">
          <irqDesc>GPIO14 interrupt request 0</irqDesc>
        </irq>
        <irq name="GPIO14_IRQ1" cpuLine="IRQRTR_SII_228,M55HE_IRQS_292,M55HP_IRQS_292" cpuLineNum="228,292,292" type="Level">
          <irqDesc>GPIO14 interrupt request 1</irqDesc>
        </irq>
        <irq name="GPIO14_IRQ2" cpuLine="IRQRTR_SII_229,M55HE_IRQS_293,M55HP_IRQS_293" cpuLineNum="229,293,293" type="Level">
          <irqDesc>GPIO14 interrupt request 2</irqDesc>
        </irq>
        <irq name="GPIO14_IRQ3" cpuLine="IRQRTR_SII_230,M55HE_IRQS_294,M55HP_IRQS_294" cpuLineNum="230,294,294" type="Level">
          <irqDesc>GPIO14 interrupt request 3</irqDesc>
        </irq>
        <irq name="GPIO14_IRQ4" cpuLine="IRQRTR_SII_231,M55HE_IRQS_295,M55HP_IRQS_295" cpuLineNum="231,295,295" type="Level">
          <irqDesc>GPIO14 interrupt request 4</irqDesc>
        </irq>
        <irq name="GPIO14_IRQ5" cpuLine="IRQRTR_SII_232,M55HE_IRQS_296,M55HP_IRQS_296" cpuLineNum="232,296,296" type="Level">
          <irqDesc>GPIO14 interrupt request 5</irqDesc>
        </irq>
        <irq name="GPIO14_IRQ6" cpuLine="IRQRTR_SII_233,M55HE_IRQS_297,M55HP_IRQS_297" cpuLineNum="233,297,297" type="Level">
          <irqDesc>GPIO14 interrupt request 6</irqDesc>
        </irq>
        <irq name="GPIO14_IRQ7" cpuLine="IRQRTR_SII_234,M55HE_IRQS_298,M55HP_IRQS_298" cpuLineNum="234,298,298" type="Level">
          <irqDesc>GPIO14 interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="LPRTC">
        <irq name="LPRTC_IRQ" cpuLine="IRQRTR_SII_286,M55HE_IRQS_350,M55HP_IRQS_350,M55HE_IRQS_58,M55HP_IRQS_58" cpuLineNum="286,350,350,58,58" type="Level">
          <irqDesc>LPRTC interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPTIMER0">
        <irq name="LPTIMER0_IRQ" cpuLine="IRQRTR_SII_282,M55HE_IRQS_346,M55HP_IRQS_346,M55HE_IRQS_60,M55HP_IRQS_60" cpuLineNum="282,346,346,60,60" type="Level">
          <irqDesc>LPTIMER0 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPTIMER1">
        <irq name="LPTIMER1_IRQ" cpuLine="IRQRTR_SII_283,M55HE_IRQS_347,M55HP_IRQS_347,M55HE_IRQS_61,M55HP_IRQS_61" cpuLineNum="283,347,347,61,61" type="Level">
          <irqDesc>LPTIMER1 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPTIMER2">
        <irq name="LPTIMER2_IRQ" cpuLine="IRQRTR_SII_284,M55HE_IRQS_348,M55HP_IRQS_348,M55HE_IRQS_62,M55HP_IRQS_62" cpuLineNum="284,348,348,62,62" type="Level">
          <irqDesc>LPTIMER2 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPTIMER3">
        <irq name="LPTIMER3_IRQ" cpuLine="IRQRTR_SII_285,M55HE_IRQS_349,M55HP_IRQS_349,M55HE_IRQS_63,M55HP_IRQS_63" cpuLineNum="285,349,349,63,63" type="Level">
          <irqDesc>LPTIMER3 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPGPIO">
        <irq name="LPGPIO_COMB_IRQ" cpuLine="M55HE_IRQS_57,M55HP_IRQS_57" cpuLineNum="57,57" type="Level">
          <irqDesc>LPGPIO combined interrupt request</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ0" cpuLine="IRQRTR_SII_107,M55HE_IRQS_171,M55HP_IRQS_171" cpuLineNum="107,171,171" type="Level">
          <irqDesc>LPGPIO interrupt request 0</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ1" cpuLine="IRQRTR_SII_108,M55HE_IRQS_172,M55HP_IRQS_172" cpuLineNum="108,172,172" type="Level">
          <irqDesc>LPGPIO interrupt request 1</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ2" cpuLine="IRQRTR_SII_109,M55HE_IRQS_173,M55HP_IRQS_173" cpuLineNum="109,173,173" type="Level">
          <irqDesc>LPGPIO interrupt request 2</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ3" cpuLine="IRQRTR_SII_110,M55HE_IRQS_174,M55HP_IRQS_174" cpuLineNum="110,174,174" type="Level">
          <irqDesc>LPGPIO interrupt request 3</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ4" cpuLine="IRQRTR_SII_111,M55HE_IRQS_175,M55HP_IRQS_175" cpuLineNum="111,175,175" type="Level">
          <irqDesc>LPGPIO interrupt request 4</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ5" cpuLine="IRQRTR_SII_112,M55HE_IRQS_176,M55HP_IRQS_176" cpuLineNum="112,176,176" type="Level">
          <irqDesc>LPGPIO interrupt request 5</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ6" cpuLine="IRQRTR_SII_113,M55HE_IRQS_177,M55HP_IRQS_177" cpuLineNum="113,177,177" type="Level">
          <irqDesc>LPGPIO interrupt request 6</irqDesc>
        </irq>
        <irq name="LPGPIO_IRQ7" cpuLine="IRQRTR_SII_114,M55HE_IRQS_178,M55HP_IRQS_178" cpuLineNum="114,178,178" type="Level">
          <irqDesc>LPGPIO interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="LPSPI">
        <irq name="LPSPI_IRQ" cpuLine="M55HE_IRQS_46" cpuLineNum="46" type="Level">
          <irqDesc>LPSPI interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPI2S">
        <irq name="LPI2S_IRQ" cpuLine="M55HE_IRQS_48" cpuLineNum="48" type="Level">
          <irqDesc>LPI2S interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPPDM">
        <irq name="LPPDM_IRQ" cpuLine="M55HE_IRQS_49" cpuLineNum="49" type="Level">
          <irqDesc>LPPDM combined (OR-ed) interrupt of the following requests :
 Warning interrupt request (WARN_IRQ)
 Error interrupt request (ERROR_IRQ)
 Audio peak detection interrupt request (AUDIO_DET_IRQ)</irqDesc>
        </irq>
      </module>
      <module name="LPCPI">
        <irq name="LPCAM_IRQ" cpuLine="M55HE_IRQS_54" cpuLineNum="54" type="Level">
          <irqDesc>LPCPI interrupt</irqDesc>
        </irq>
      </module>
      <module name="LPUART">
        <irq name="LPUART_IRQ" cpuLine="M55HE_IRQS_45" cpuLineNum="45" type="Level">
          <irqDesc>LPUART interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPI2C">
        <irq name="LPI2C_IRQ" cpuLine="M55HE_IRQS_47" cpuLineNum="47" type="Level">
          <irqDesc>LPI2C interrupt request</irqDesc>
        </irq>
      </module>
      <module name="LPCMP">
        <irq name="LPCMP_IRQ" cpuLine="M55HE_IRQS_56,M55HP_IRQS_56" cpuLineNum="56,56" type="Level">
          <irqDesc>Comparator output changed</irqDesc>
        </irq>
      </module>
      <module name="DSI">
        <irq name="DSI_IRQ" cpuLine="IRQRTR_SII_279,M55HE_IRQS_343,M55HP_IRQS_343" cpuLineNum="279,343,343" type="Level">
          <irqDesc>DSI error interrupt</irqDesc>
        </irq>
      </module>
      <module name="CDC">
        <irq name="CDC_BUS_ERROR0_IRQ" cpuLine="IRQRTR_SII_275,M55HE_IRQS_339,M55HP_IRQS_339" cpuLineNum="275,339,339" type="Level">
          <irqDesc>CDC bus error interrupt</irqDesc>
        </irq>
        <irq name="CDC_FIFO_UNDERRUN0_IRQ" cpuLine="IRQRTR_SII_273,M55HE_IRQS_337,M55HP_IRQS_337" cpuLineNum="273,337,337" type="Level">
          <irqDesc>CDC layer FIFO underrun interrupt</irqDesc>
        </irq>
        <irq name="CDC_FIFO_WARNING0_IRQ" cpuLine="IRQRTR_SII_271,M55HE_IRQS_335,M55HP_IRQS_335" cpuLineNum="271,335,335" type="Level">
          <irqDesc>CDC FIFO underrun warning interrupt</irqDesc>
        </irq>
        <irq name="CDC_REG_RELOAD0_IRQ" cpuLine="IRQRTR_SII_277,M55HE_IRQS_341,M55HP_IRQS_341" cpuLineNum="277,341,341" type="Level">
          <irqDesc>CDC register reload interrupt</irqDesc>
        </irq>
        <irq name="CDC_SCANLINE0_IRQ" cpuLine="IRQRTR_SII_269,M55HE_IRQS_333,M55HP_IRQS_333" cpuLineNum="269,333,333" type="Level">
          <irqDesc>CDC line interrupt</irqDesc>
        </irq>
      </module>
      <module name="CSI">
        <irq name="CSI_IRQ" cpuLine="IRQRTR_SII_280,M55HE_IRQS_344,M55HP_IRQS_344" cpuLineNum="280,344,344" type="Level">
          <irqDesc>CSI interrupt</irqDesc>
        </irq>
      </module>
      <module name="CPI">
        <irq name="CAM_IRQ" cpuLine="IRQRTR_SII_281,M55HE_IRQS_345,M55HP_IRQS_345" cpuLineNum="281,345,345" type="Level">
          <irqDesc>CPI interrupt</irqDesc>
        </irq>
      </module>
      <module name="GPU2D">
        <irq name="GPU2D_IRQ" cpuLine="IRQRTR_SII_268,M55HE_IRQS_332,M55HP_IRQS_332" cpuLineNum="268,332,332" type="Level">
          <irqDesc>GPU2D aggregated interrupt request</irqDesc>
        </irq>
      </module>
      <module name="ADC120">
        <irq name="ADC120_CMPA_IRQ" cpuLine="M55HE_IRQS_157,M55HP_IRQS_157,IRQRTR_SII_93" cpuLineNum="157,157,93" type="Level">
          <irqDesc>Comparator A interrupt</irqDesc>
        </irq>
        <irq name="ADC120_CMPB_IRQ" cpuLine="M55HE_IRQS_160,M55HP_IRQS_160,IRQRTR_SII_96" cpuLineNum="160,160,96" type="Level">
          <irqDesc>Comparator B interrupt</irqDesc>
        </irq>
        <irq name="ADC120_DONE0_IRQ" cpuLine="M55HE_IRQS_151,M55HP_IRQS_151,IRQRTR_SII_87" cpuLineNum="151,151,87" type="Level">
          <irqDesc>Averaged sample ready</irqDesc>
        </irq>
        <irq name="ADC120_DONE1_IRQ" cpuLine="M55HE_IRQS_154,M55HP_IRQS_154,IRQRTR_SII_90" cpuLineNum="154,154,90" type="Level">
          <irqDesc>All samples taken</irqDesc>
        </irq>
      </module>
      <module name="ADC121">
        <irq name="ADC121_CMPA_IRQ" cpuLine="M55HE_IRQS_158,M55HP_IRQS_158,IRQRTR_SII_94" cpuLineNum="158,158,94" type="Level">
          <irqDesc>Comparator A interrupt</irqDesc>
        </irq>
        <irq name="ADC121_CMPB_IRQ" cpuLine="M55HE_IRQS_161,M55HP_IRQS_161,IRQRTR_SII_97" cpuLineNum="161,161,97" type="Level">
          <irqDesc>Comparator B interrupt</irqDesc>
        </irq>
        <irq name="ADC121_DONE0_IRQ" cpuLine="M55HE_IRQS_152,M55HP_IRQS_152,IRQRTR_SII_88" cpuLineNum="152,152,88" type="Level">
          <irqDesc>Averaged sample ready</irqDesc>
        </irq>
        <irq name="ADC121_DONE1_IRQ" cpuLine="M55HE_IRQS_155,M55HP_IRQS_155,IRQRTR_SII_91" cpuLineNum="155,155,91" type="Level">
          <irqDesc>All samples taken</irqDesc>
        </irq>
      </module>
      <module name="ADC122">
        <irq name="ADC122_CMPA_IRQ" cpuLine="M55HE_IRQS_159,M55HP_IRQS_159,IRQRTR_SII_95" cpuLineNum="159,159,95" type="Level">
          <irqDesc>Comparator A interrupt</irqDesc>
        </irq>
        <irq name="ADC122_CMPB_IRQ" cpuLine="M55HE_IRQS_162,M55HP_IRQS_162,IRQRTR_SII_98" cpuLineNum="162,162,98" type="Level">
          <irqDesc>Comparator B interrupt</irqDesc>
        </irq>
        <irq name="ADC122_DONE0_IRQ" cpuLine="M55HE_IRQS_153,M55HP_IRQS_153,IRQRTR_SII_89" cpuLineNum="153,153,89" type="Level">
          <irqDesc>Averaged sample ready</irqDesc>
        </irq>
        <irq name="ADC122_DONE1_IRQ" cpuLine="M55HE_IRQS_156,M55HP_IRQS_156,IRQRTR_SII_92" cpuLineNum="156,156,92" type="Level">
          <irqDesc>All samples taken</irqDesc>
        </irq>
      </module>
      <module name="ADC24">
        <irq name="ADC24_CMPA_IRQ" cpuLine="IRQRTR_SII_101,M55HE_IRQS_165,M55HP_IRQS_165" cpuLineNum="101,165,165" type="Level">
          <irqDesc>Comparator A interrupt</irqDesc>
        </irq>
        <irq name="ADC24_CMPB_IRQ" cpuLine="IRQRTR_SII_102,M55HE_IRQS_166,M55HP_IRQS_166" cpuLineNum="102,166,166" type="Level">
          <irqDesc>Comparator B interrupt</irqDesc>
        </irq>
        <irq name="ADC24_DONE0_IRQ" cpuLine="M55HE_IRQS_163,M55HP_IRQS_163,IRQRTR_SII_99" cpuLineNum="163,163,99" type="Level">
          <irqDesc>Averaged sample ready</irqDesc>
        </irq>
        <irq name="ADC24_DONE1_IRQ" cpuLine="IRQRTR_SII_100,M55HE_IRQS_164,M55HP_IRQS_164" cpuLineNum="100,164,164" type="Level">
          <irqDesc>All samples taken</irqDesc>
        </irq>
      </module>
      <module name="CMP0">
        <irq name="CMP0_IRQ" cpuLine="IRQRTR_SII_103,M55HE_IRQS_167,M55HP_IRQS_167" cpuLineNum="103,167,167" type="Level">
          <irqDesc>Comparator result changed</irqDesc>
        </irq>
      </module>
      <module name="CMP1">
        <irq name="CMP1_IRQ" cpuLine="IRQRTR_SII_104,M55HE_IRQS_168,M55HP_IRQS_168" cpuLineNum="104,168,168" type="Level">
          <irqDesc>Comparator result changed</irqDesc>
        </irq>
      </module>
      <module name="CMP2">
        <irq name="CMP2_IRQ" cpuLine="IRQRTR_SII_105,M55HE_IRQS_169,M55HP_IRQS_169" cpuLineNum="105,169,169" type="Level">
          <irqDesc>Comparator result changed</irqDesc>
        </irq>
      </module>
      <module name="CMP3">
        <irq name="CMP3_IRQ" cpuLine="IRQRTR_SII_106,M55HE_IRQS_170,M55HP_IRQS_170" cpuLineNum="106,170,170" type="Level">
          <irqDesc>Comparator result changed</irqDesc>
        </irq>
      </module>
      <module name="ETH">
        <irq name="ETH_PMT_IRQ" cpuLine="M55HE_IRQS_149,M55HP_IRQS_149,IRQRTR_SII_85" cpuLineNum="149,149,85" type="Level">
          <irqDesc>Non-maskable interrupt generated when the MAC receives remote wake-up frame or magic packet</irqDesc>
        </irq>
        <irq name="ETH_SBD_IRQ" cpuLine="M55HE_IRQS_148,M55HP_IRQS_148,IRQRTR_SII_84" cpuLineNum="148,148,84" type="Level">
          <irqDesc>ETH main interrupt asserted by many events. Its value can also be read via the ETH_STAT0[SBD_INTR_O] bit.</irqDesc>
        </irq>
      </module>
      <module name="I2C0">
        <irq name="I2C0_IRQ" cpuLine="M55HE_IRQS_132,M55HP_IRQS_132,IRQRTR_SII_68" cpuLineNum="132,132,68" type="Level">
          <irqDesc>I2C0 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I2C1">
        <irq name="I2C1_IRQ" cpuLine="M55HE_IRQS_133,M55HP_IRQS_133,IRQRTR_SII_69" cpuLineNum="133,133,69" type="Level">
          <irqDesc>I2C1 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I2C2">
        <irq name="I2C2_IRQ" cpuLine="M55HE_IRQS_134,M55HP_IRQS_134,IRQRTR_SII_70" cpuLineNum="134,134,70" type="Level">
          <irqDesc>I2C2 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I2C3">
        <irq name="I2C3_IRQ" cpuLine="M55HE_IRQS_135,M55HP_IRQS_135,IRQRTR_SII_71" cpuLineNum="135,135,71" type="Level">
          <irqDesc>I2C3 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I2S0">
        <irq name="I2S0_IRQ" cpuLine="M55HE_IRQS_141,M55HP_IRQS_141,IRQRTR_SII_77" cpuLineNum="141,141,77" type="Level">
          <irqDesc>I2S0 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I2S1">
        <irq name="I2S1_IRQ" cpuLine="M55HE_IRQS_142,M55HP_IRQS_142,IRQRTR_SII_78" cpuLineNum="142,142,78" type="Level">
          <irqDesc>I2S1 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I2S2">
        <irq name="I2S2_IRQ" cpuLine="M55HE_IRQS_143,M55HP_IRQS_143,IRQRTR_SII_79" cpuLineNum="143,143,79" type="Level">
          <irqDesc>I2S2 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I2S3">
        <irq name="I2S3_IRQ" cpuLine="M55HE_IRQS_144,M55HP_IRQS_144,IRQRTR_SII_80" cpuLineNum="144,144,80" type="Level">
          <irqDesc>I2S3 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="I3C">
        <irq name="I3C_IRQ" cpuLine="M55HE_IRQS_136,M55HP_IRQS_136,IRQRTR_SII_72" cpuLineNum="136,136,72" type="Level">
          <irqDesc>I3C interrupt request</irqDesc>
        </irq>
      </module>
      <module name="PDM">
        <irq name="PDM_AUDIO_DET_IRQ" cpuLine="M55HE_IRQS_147,M55HP_IRQS_147,IRQRTR_SII_83" cpuLineNum="147,147,83" type="Level">
          <irqDesc>PDM Audio peak detection interrupt request</irqDesc>
        </irq>
        <irq name="PDM_ERROR_IRQ" cpuLine="M55HE_IRQS_146,M55HP_IRQS_146,IRQRTR_SII_82" cpuLineNum="146,146,82" type="Level">
          <irqDesc>PDM Error interrupt request</irqDesc>
        </irq>
        <irq name="PDM_WARN_IRQ" cpuLine="M55HE_IRQS_145,M55HP_IRQS_145,IRQRTR_SII_81" cpuLineNum="145,145,81" type="Level">
          <irqDesc>PDM Warning interrupt request</irqDesc>
        </irq>
      </module>
      <module name="SPI0">
        <irq name="SPI0_IRQ" cpuLine="M55HE_IRQS_137,M55HP_IRQS_137,IRQRTR_SII_73" cpuLineNum="137,137,73" type="Level">
          <irqDesc>SPI0 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="SPI1">
        <irq name="SPI1_IRQ" cpuLine="M55HE_IRQS_138,M55HP_IRQS_138,IRQRTR_SII_74" cpuLineNum="138,138,74" type="Level">
          <irqDesc>SPI1 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="SPI2">
        <irq name="SPI2_IRQ" cpuLine="M55HE_IRQS_139,M55HP_IRQS_139,IRQRTR_SII_75" cpuLineNum="139,139,75" type="Level">
          <irqDesc>SPI2 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="SPI3">
        <irq name="SPI3_IRQ" cpuLine="M55HE_IRQS_140,M55HP_IRQS_140,IRQRTR_SII_76" cpuLineNum="140,140,76" type="Level">
          <irqDesc>SPI3 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART0">
        <irq name="UART0_IRQ" cpuLine="M55HE_IRQS_124,M55HP_IRQS_124,IRQRTR_SII_60" cpuLineNum="124,124,60" type="Level">
          <irqDesc>UART0 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART1">
        <irq name="UART1_IRQ" cpuLine="M55HE_IRQS_125,M55HP_IRQS_125,IRQRTR_SII_61" cpuLineNum="125,125,61" type="Level">
          <irqDesc>UART1 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART2">
        <irq name="UART2_IRQ" cpuLine="M55HE_IRQS_126,M55HP_IRQS_126,IRQRTR_SII_62" cpuLineNum="126,126,62" type="Level">
          <irqDesc>UART2 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART3">
        <irq name="UART3_IRQ" cpuLine="M55HE_IRQS_127,M55HP_IRQS_127,IRQRTR_SII_63" cpuLineNum="127,127,63" type="Level">
          <irqDesc>UART3 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART4">
        <irq name="UART4_IRQ" cpuLine="M55HE_IRQS_128,M55HP_IRQS_128,IRQRTR_SII_64" cpuLineNum="128,128,64" type="Level">
          <irqDesc>UART4 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART5">
        <irq name="UART5_IRQ" cpuLine="M55HE_IRQS_129,M55HP_IRQS_129,IRQRTR_SII_65" cpuLineNum="129,129,65" type="Level">
          <irqDesc>UART5 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART6">
        <irq name="UART6_IRQ" cpuLine="M55HE_IRQS_130,M55HP_IRQS_130,IRQRTR_SII_66" cpuLineNum="130,130,66" type="Level">
          <irqDesc>UART6 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="UART7">
        <irq name="UART7_IRQ" cpuLine="M55HE_IRQS_131,M55HP_IRQS_131,IRQRTR_SII_67" cpuLineNum="131,131,67" type="Level">
          <irqDesc>UART7 interrupt request</irqDesc>
        </irq>
      </module>
      <module name="USB">
        <irq name="USB_IRQ" cpuLine="M55HE_IRQS_101,M55HP_IRQS_101,IRQRTR_SII_37" cpuLineNum="101,101,37" type="Level">
          <irqDesc>USB interrupt</irqDesc>
        </irq>
      </module>
      <module name="UTIMER0">
        <irq name="UTIMER_IRQ0" cpuLine="IRQRTR_SII_313,M55HE_IRQS_377,M55HP_IRQS_377" cpuLineNum="313,377,377" type="Level">
          <irqDesc>Channel 0, interrupt request 0</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ1" cpuLine="IRQRTR_SII_314,M55HE_IRQS_378,M55HP_IRQS_378" cpuLineNum="314,378,378" type="Level">
          <irqDesc>Channel 0, interrupt request 1</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ2" cpuLine="IRQRTR_SII_315,M55HE_IRQS_379,M55HP_IRQS_379" cpuLineNum="315,379,379" type="Level">
          <irqDesc>Channel 0, interrupt request 2</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ3" cpuLine="IRQRTR_SII_316,M55HE_IRQS_380,M55HP_IRQS_380" cpuLineNum="316,380,380" type="Level">
          <irqDesc>Channel 0, interrupt request 3</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ4" cpuLine="IRQRTR_SII_317,M55HE_IRQS_381,M55HP_IRQS_381" cpuLineNum="317,381,381" type="Level">
          <irqDesc>Channel 0, interrupt request 4</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ5" cpuLine="IRQRTR_SII_318,M55HE_IRQS_382,M55HP_IRQS_382" cpuLineNum="318,382,382" type="Level">
          <irqDesc>Channel 0, interrupt request 5</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ6" cpuLine="IRQRTR_SII_319,M55HE_IRQS_383,M55HP_IRQS_383" cpuLineNum="319,383,383" type="Level">
          <irqDesc>Channel 0, interrupt request 6</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ7" cpuLine="IRQRTR_SII_320,M55HE_IRQS_384,M55HP_IRQS_384" cpuLineNum="320,384,384" type="Level">
          <irqDesc>Channel 0, interrupt request 7</irqDesc>
        </irq>
      </module>
      <module name="UTIMER1">
        <irq name="UTIMER_IRQ10" cpuLine="IRQRTR_SII_323,M55HE_IRQS_387,M55HP_IRQS_387" cpuLineNum="323,387,387" type="Level">
          <irqDesc>Channel 1, interrupt request 10</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ11" cpuLine="IRQRTR_SII_324,M55HE_IRQS_388,M55HP_IRQS_388" cpuLineNum="324,388,388" type="Level">
          <irqDesc>Channel 1, interrupt request 11</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ12" cpuLine="IRQRTR_SII_325,M55HE_IRQS_389,M55HP_IRQS_389" cpuLineNum="325,389,389" type="Level">
          <irqDesc>Channel 1, interrupt request 12</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ13" cpuLine="IRQRTR_SII_326,M55HE_IRQS_390,M55HP_IRQS_390" cpuLineNum="326,390,390" type="Level">
          <irqDesc>Channel 1, interrupt request 13</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ14" cpuLine="IRQRTR_SII_327,M55HE_IRQS_391,M55HP_IRQS_391" cpuLineNum="327,391,391" type="Level">
          <irqDesc>Channel 1, interrupt request 14</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ15" cpuLine="IRQRTR_SII_328,M55HE_IRQS_392,M55HP_IRQS_392" cpuLineNum="328,392,392" type="Level">
          <irqDesc>Channel 1, interrupt request 15</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ8" cpuLine="IRQRTR_SII_321,M55HE_IRQS_385,M55HP_IRQS_385" cpuLineNum="321,385,385" type="Level">
          <irqDesc>Channel 1, interrupt request 8</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ9" cpuLine="IRQRTR_SII_322,M55HE_IRQS_386,M55HP_IRQS_386" cpuLineNum="322,386,386" type="Level">
          <irqDesc>Channel 1, interrupt request 9</irqDesc>
        </irq>
      </module>
      <module name="UTIMER2">
        <irq name="UTIMER_IRQ16" cpuLine="IRQRTR_SII_329,M55HE_IRQS_393,M55HP_IRQS_393" cpuLineNum="329,393,393" type="Level">
          <irqDesc>Channel 2, interrupt request 16</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ17" cpuLine="IRQRTR_SII_330,M55HE_IRQS_394,M55HP_IRQS_394" cpuLineNum="330,394,394" type="Level">
          <irqDesc>Channel 2, interrupt request 17</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ18" cpuLine="IRQRTR_SII_331,M55HE_IRQS_395,M55HP_IRQS_395" cpuLineNum="331,395,395" type="Level">
          <irqDesc>Channel 2, interrupt request 18</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ19" cpuLine="IRQRTR_SII_332,M55HE_IRQS_396,M55HP_IRQS_396" cpuLineNum="332,396,396" type="Level">
          <irqDesc>Channel 2, interrupt request 19</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ20" cpuLine="IRQRTR_SII_333,M55HE_IRQS_397,M55HP_IRQS_397" cpuLineNum="333,397,397" type="Level">
          <irqDesc>Channel 2, interrupt request 20</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ21" cpuLine="IRQRTR_SII_334,M55HE_IRQS_398,M55HP_IRQS_398" cpuLineNum="334,398,398" type="Level">
          <irqDesc>Channel 2, interrupt request 21</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ22" cpuLine="IRQRTR_SII_335,M55HE_IRQS_399,M55HP_IRQS_399" cpuLineNum="335,399,399" type="Level">
          <irqDesc>Channel 2, interrupt request 22</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ23" cpuLine="IRQRTR_SII_336,M55HE_IRQS_400,M55HP_IRQS_400" cpuLineNum="336,400,400" type="Level">
          <irqDesc>Channel 2, interrupt request 23</irqDesc>
        </irq>
      </module>
      <module name="UTIMER3">
        <irq name="UTIMER_IRQ24" cpuLine="IRQRTR_SII_337,M55HE_IRQS_401,M55HP_IRQS_401" cpuLineNum="337,401,401" type="Level">
          <irqDesc>Channel 3, interrupt request 24</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ25" cpuLine="IRQRTR_SII_338,M55HE_IRQS_402,M55HP_IRQS_402" cpuLineNum="338,402,402" type="Level">
          <irqDesc>Channel 3, interrupt request 25</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ26" cpuLine="IRQRTR_SII_339,M55HE_IRQS_403,M55HP_IRQS_403" cpuLineNum="339,403,403" type="Level">
          <irqDesc>Channel 3, interrupt request 26</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ27" cpuLine="IRQRTR_SII_340,M55HE_IRQS_404,M55HP_IRQS_404" cpuLineNum="340,404,404" type="Level">
          <irqDesc>Channel 3, interrupt request 27</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ28" cpuLine="IRQRTR_SII_341,M55HE_IRQS_405,M55HP_IRQS_405" cpuLineNum="341,405,405" type="Level">
          <irqDesc>Channel 3, interrupt request 28</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ29" cpuLine="IRQRTR_SII_342,M55HE_IRQS_406,M55HP_IRQS_406" cpuLineNum="342,406,406" type="Level">
          <irqDesc>Channel 3, interrupt request 29</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ30" cpuLine="IRQRTR_SII_343,M55HE_IRQS_407,M55HP_IRQS_407" cpuLineNum="343,407,407" type="Level">
          <irqDesc>Channel 3, interrupt request 30</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ31" cpuLine="IRQRTR_SII_344,M55HE_IRQS_408,M55HP_IRQS_408" cpuLineNum="344,408,408" type="Level">
          <irqDesc>Channel 3, interrupt request 31</irqDesc>
        </irq>
      </module>
      <module name="UTIMER4">
        <irq name="UTIMER_IRQ32" cpuLine="IRQRTR_SII_345,M55HE_IRQS_409,M55HP_IRQS_409" cpuLineNum="345,409,409" type="Level">
          <irqDesc>Channel 4, interrupt request 32</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ33" cpuLine="IRQRTR_SII_346,M55HE_IRQS_410,M55HP_IRQS_410" cpuLineNum="346,410,410" type="Level">
          <irqDesc>Channel 4, interrupt request 33</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ34" cpuLine="IRQRTR_SII_347,M55HE_IRQS_411,M55HP_IRQS_411" cpuLineNum="347,411,411" type="Level">
          <irqDesc>Channel 4, interrupt request 34</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ35" cpuLine="IRQRTR_SII_348,M55HE_IRQS_412,M55HP_IRQS_412" cpuLineNum="348,412,412" type="Level">
          <irqDesc>Channel 4, interrupt request 35</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ36" cpuLine="IRQRTR_SII_349,M55HE_IRQS_413,M55HP_IRQS_413" cpuLineNum="349,413,413" type="Level">
          <irqDesc>Channel 4, interrupt request 36</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ37" cpuLine="IRQRTR_SII_350,M55HE_IRQS_414,M55HP_IRQS_414" cpuLineNum="350,414,414" type="Level">
          <irqDesc>Channel 4, interrupt request 37</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ38" cpuLine="IRQRTR_SII_351,M55HE_IRQS_415,M55HP_IRQS_415" cpuLineNum="351,415,415" type="Level">
          <irqDesc>Channel 4, interrupt request 38</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ39" cpuLine="IRQRTR_SII_352,M55HE_IRQS_416,M55HP_IRQS_416" cpuLineNum="352,416,416" type="Level">
          <irqDesc>Channel 4, interrupt request 39</irqDesc>
        </irq>
      </module>
      <module name="UTIMER5">
        <irq name="UTIMER_IRQ40" cpuLine="IRQRTR_SII_353,M55HE_IRQS_417,M55HP_IRQS_417" cpuLineNum="353,417,417" type="Level">
          <irqDesc>Channel 5, interrupt request 40</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ41" cpuLine="IRQRTR_SII_354,M55HE_IRQS_418,M55HP_IRQS_418" cpuLineNum="354,418,418" type="Level">
          <irqDesc>Channel 5, interrupt request 41</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ42" cpuLine="IRQRTR_SII_355,M55HE_IRQS_419,M55HP_IRQS_419" cpuLineNum="355,419,419" type="Level">
          <irqDesc>Channel 5, interrupt request 42</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ43" cpuLine="IRQRTR_SII_356,M55HE_IRQS_420,M55HP_IRQS_420" cpuLineNum="356,420,420" type="Level">
          <irqDesc>Channel 5, interrupt request 43</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ44" cpuLine="IRQRTR_SII_357,M55HE_IRQS_421,M55HP_IRQS_421" cpuLineNum="357,421,421" type="Level">
          <irqDesc>Channel 5, interrupt request 44</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ45" cpuLine="IRQRTR_SII_358,M55HE_IRQS_422,M55HP_IRQS_422" cpuLineNum="358,422,422" type="Level">
          <irqDesc>Channel 5, interrupt request 45</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ46" cpuLine="IRQRTR_SII_359,M55HE_IRQS_423,M55HP_IRQS_423" cpuLineNum="359,423,423" type="Level">
          <irqDesc>Channel 5, interrupt request 46</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ47" cpuLine="IRQRTR_SII_360,M55HE_IRQS_424,M55HP_IRQS_424" cpuLineNum="360,424,424" type="Level">
          <irqDesc>Channel 5, interrupt request 47</irqDesc>
        </irq>
      </module>
      <module name="UTIMER6">
        <irq name="UTIMER_IRQ48" cpuLine="IRQRTR_SII_361,M55HE_IRQS_425,M55HP_IRQS_425" cpuLineNum="361,425,425" type="Level">
          <irqDesc>Channel 6, interrupt request 48</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ49" cpuLine="IRQRTR_SII_362,M55HE_IRQS_426,M55HP_IRQS_426" cpuLineNum="362,426,426" type="Level">
          <irqDesc>Channel 6, interrupt request 49</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ50" cpuLine="IRQRTR_SII_363,M55HE_IRQS_427,M55HP_IRQS_427" cpuLineNum="363,427,427" type="Level">
          <irqDesc>Channel 6, interrupt request 50</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ51" cpuLine="IRQRTR_SII_364,M55HE_IRQS_428,M55HP_IRQS_428" cpuLineNum="364,428,428" type="Level">
          <irqDesc>Channel 6, interrupt request 51</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ52" cpuLine="IRQRTR_SII_365,M55HE_IRQS_429,M55HP_IRQS_429" cpuLineNum="365,429,429" type="Level">
          <irqDesc>Channel 6, interrupt request 52</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ53" cpuLine="IRQRTR_SII_366,M55HE_IRQS_430,M55HP_IRQS_430" cpuLineNum="366,430,430" type="Level">
          <irqDesc>Channel 6, interrupt request 53</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ54" cpuLine="IRQRTR_SII_367,M55HE_IRQS_431,M55HP_IRQS_431" cpuLineNum="367,431,431" type="Level">
          <irqDesc>Channel 6, interrupt request 54</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ55" cpuLine="IRQRTR_SII_368,M55HE_IRQS_432,M55HP_IRQS_432" cpuLineNum="368,432,432" type="Level">
          <irqDesc>Channel 6, interrupt request 55</irqDesc>
        </irq>
      </module>
      <module name="UTIMER7">
        <irq name="UTIMER_IRQ56" cpuLine="IRQRTR_SII_369,M55HE_IRQS_433,M55HP_IRQS_433" cpuLineNum="369,433,433" type="Level">
          <irqDesc>Channel 7, interrupt request 56</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ57" cpuLine="IRQRTR_SII_370,M55HE_IRQS_434,M55HP_IRQS_434" cpuLineNum="370,434,434" type="Level">
          <irqDesc>Channel 7, interrupt request 57</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ58" cpuLine="IRQRTR_SII_371,M55HE_IRQS_435,M55HP_IRQS_435" cpuLineNum="371,435,435" type="Level">
          <irqDesc>Channel 7, interrupt request 58</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ59" cpuLine="IRQRTR_SII_372,M55HE_IRQS_436,M55HP_IRQS_436" cpuLineNum="372,436,436" type="Level">
          <irqDesc>Channel 7, interrupt request 59</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ60" cpuLine="IRQRTR_SII_373,M55HE_IRQS_437,M55HP_IRQS_437" cpuLineNum="373,437,437" type="Level">
          <irqDesc>Channel 7, interrupt request 60</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ61" cpuLine="IRQRTR_SII_374,M55HE_IRQS_438,M55HP_IRQS_438" cpuLineNum="374,438,438" type="Level">
          <irqDesc>Channel 7, interrupt request 61</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ62" cpuLine="IRQRTR_SII_375,M55HE_IRQS_439,M55HP_IRQS_439" cpuLineNum="375,439,439" type="Level">
          <irqDesc>Channel 7, interrupt request 62</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ63" cpuLine="IRQRTR_SII_376,M55HE_IRQS_440,M55HP_IRQS_440" cpuLineNum="376,440,440" type="Level">
          <irqDesc>Channel 7, interrupt request 63</irqDesc>
        </irq>
      </module>
      <module name="UTIMER8">
        <irq name="UTIMER_IRQ64" cpuLine="IRQRTR_SII_377,M55HE_IRQS_441,M55HP_IRQS_441" cpuLineNum="377,441,441" type="Level">
          <irqDesc>Channel 8, interrupt request 64</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ65" cpuLine="IRQRTR_SII_378,M55HE_IRQS_442,M55HP_IRQS_442" cpuLineNum="378,442,442" type="Level">
          <irqDesc>Channel 8, interrupt request 65</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ66" cpuLine="IRQRTR_SII_379,M55HE_IRQS_443,M55HP_IRQS_443" cpuLineNum="379,443,443" type="Level">
          <irqDesc>Channel 8, interrupt request 66</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ67" cpuLine="IRQRTR_SII_380,M55HE_IRQS_444,M55HP_IRQS_444" cpuLineNum="380,444,444" type="Level">
          <irqDesc>Channel 8, interrupt request 67</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ68" cpuLine="IRQRTR_SII_381,M55HE_IRQS_445,M55HP_IRQS_445" cpuLineNum="381,445,445" type="Level">
          <irqDesc>Channel 8, interrupt request 68</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ69" cpuLine="IRQRTR_SII_382,M55HE_IRQS_446,M55HP_IRQS_446" cpuLineNum="382,446,446" type="Level">
          <irqDesc>Channel 8, interrupt request 69</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ70" cpuLine="IRQRTR_SII_383,M55HE_IRQS_447,M55HP_IRQS_447" cpuLineNum="383,447,447" type="Level">
          <irqDesc>Channel 8, interrupt request 70</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ71" cpuLine="IRQRTR_SII_384,M55HE_IRQS_448,M55HP_IRQS_448" cpuLineNum="384,448,448" type="Level">
          <irqDesc>Channel 8, interrupt request 71</irqDesc>
        </irq>
      </module>
      <module name="UTIMER9">
        <irq name="UTIMER_IRQ72" cpuLine="IRQRTR_SII_385,M55HE_IRQS_449,M55HP_IRQS_449" cpuLineNum="385,449,449" type="Level">
          <irqDesc>Channel 9, interrupt request 72</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ73" cpuLine="IRQRTR_SII_386,M55HE_IRQS_450,M55HP_IRQS_450" cpuLineNum="386,450,450" type="Level">
          <irqDesc>Channel 9, interrupt request 73</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ74" cpuLine="IRQRTR_SII_387,M55HE_IRQS_451,M55HP_IRQS_451" cpuLineNum="387,451,451" type="Level">
          <irqDesc>Channel 9, interrupt request 74</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ75" cpuLine="IRQRTR_SII_388,M55HE_IRQS_452,M55HP_IRQS_452" cpuLineNum="388,452,452" type="Level">
          <irqDesc>Channel 9, interrupt request 75</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ76" cpuLine="IRQRTR_SII_389,M55HE_IRQS_453,M55HP_IRQS_453" cpuLineNum="389,453,453" type="Level">
          <irqDesc>Channel 9, interrupt request 76</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ77" cpuLine="IRQRTR_SII_390,M55HE_IRQS_454,M55HP_IRQS_454" cpuLineNum="390,454,454" type="Level">
          <irqDesc>Channel 9, interrupt request 77</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ78" cpuLine="IRQRTR_SII_391,M55HE_IRQS_455,M55HP_IRQS_455" cpuLineNum="391,455,455" type="Level">
          <irqDesc>Channel 9, interrupt request 78</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ79" cpuLine="IRQRTR_SII_392,M55HE_IRQS_456,M55HP_IRQS_456" cpuLineNum="392,456,456" type="Level">
          <irqDesc>Channel 9, interrupt request 79</irqDesc>
        </irq>
      </module>
      <module name="UTIMER10">
        <irq name="UTIMER_IRQ80" cpuLine="IRQRTR_SII_393,M55HE_IRQS_457,M55HP_IRQS_457" cpuLineNum="393,457,457" type="Level">
          <irqDesc>Channel 10, interrupt request 80</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ81" cpuLine="IRQRTR_SII_394,M55HE_IRQS_458,M55HP_IRQS_458" cpuLineNum="394,458,458" type="Level">
          <irqDesc>Channel 10, interrupt request 81</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ82" cpuLine="IRQRTR_SII_395,M55HE_IRQS_459,M55HP_IRQS_459" cpuLineNum="395,459,459" type="Level">
          <irqDesc>Channel 10, interrupt request 82</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ83" cpuLine="IRQRTR_SII_396,M55HE_IRQS_460,M55HP_IRQS_460" cpuLineNum="396,460,460" type="Level">
          <irqDesc>Channel 10, interrupt request 83</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ84" cpuLine="IRQRTR_SII_397,M55HE_IRQS_461,M55HP_IRQS_461" cpuLineNum="397,461,461" type="Level">
          <irqDesc>Channel 10, interrupt request 84</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ85" cpuLine="IRQRTR_SII_398,M55HE_IRQS_462,M55HP_IRQS_462" cpuLineNum="398,462,462" type="Level">
          <irqDesc>Channel 10, interrupt request 85</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ86" cpuLine="IRQRTR_SII_399,M55HE_IRQS_463,M55HP_IRQS_463" cpuLineNum="399,463,463" type="Level">
          <irqDesc>Channel 10, interrupt request 86</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ87" cpuLine="IRQRTR_SII_400,M55HE_IRQS_464,M55HP_IRQS_464" cpuLineNum="400,464,464" type="Level">
          <irqDesc>Channel 10, interrupt request 87</irqDesc>
        </irq>
      </module>
      <module name="UTIMER11">
        <irq name="UTIMER_IRQ88" cpuLine="IRQRTR_SII_401,M55HE_IRQS_465,M55HP_IRQS_465" cpuLineNum="401,465,465" type="Level">
          <irqDesc>Channel 11, interrupt request 88</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ89" cpuLine="IRQRTR_SII_402,M55HE_IRQS_466,M55HP_IRQS_466" cpuLineNum="402,466,466" type="Level">
          <irqDesc>Channel 11, interrupt request 89</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ90" cpuLine="IRQRTR_SII_403,M55HE_IRQS_467,M55HP_IRQS_467" cpuLineNum="403,467,467" type="Level">
          <irqDesc>Channel 11, interrupt request 90</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ91" cpuLine="IRQRTR_SII_404,M55HE_IRQS_468,M55HP_IRQS_468" cpuLineNum="404,468,468" type="Level">
          <irqDesc>Channel 11, interrupt request 91</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ92" cpuLine="IRQRTR_SII_405,M55HE_IRQS_469,M55HP_IRQS_469" cpuLineNum="405,469,469" type="Level">
          <irqDesc>Channel 11, interrupt request 92</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ93" cpuLine="IRQRTR_SII_406,M55HE_IRQS_470,M55HP_IRQS_470" cpuLineNum="406,470,470" type="Level">
          <irqDesc>Channel 11, interrupt request 93</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ94" cpuLine="IRQRTR_SII_407,M55HE_IRQS_471,M55HP_IRQS_471" cpuLineNum="407,471,471" type="Level">
          <irqDesc>Channel 11, interrupt request 94</irqDesc>
        </irq>
        <irq name="UTIMER_IRQ95" cpuLine="IRQRTR_SII_408,M55HE_IRQS_472,M55HP_IRQS_472" cpuLineNum="408,472,472" type="Level">
          <irqDesc>Channel 11, interrupt request 95</irqDesc>
        </irq>
      </module>
      <module name="QEC0">
        <irq name="QEC0_CMPA_IRQ" cpuLine="IRQRTR_SII_305,M55HE_IRQS_369,M55HP_IRQS_369" cpuLineNum="305,369,369" type="Level">
          <irqDesc>Channel 12 interrupt request at driver A</irqDesc>
        </irq>
        <irq name="QEC0_CMPB_IRQ" cpuLine="IRQRTR_SII_306,M55HE_IRQS_370,M55HP_IRQS_370" cpuLineNum="306,370,370" type="Level">
          <irqDesc>Channel 12 interrupt request at driver B</irqDesc>
        </irq>
      </module>
      <module name="QEC1">
        <irq name="QEC1_CMPA_IRQ" cpuLine="IRQRTR_SII_307,M55HE_IRQS_371,M55HP_IRQS_371" cpuLineNum="307,371,371" type="Level">
          <irqDesc>Channel 13 interrupt request at driver A</irqDesc>
        </irq>
        <irq name="QEC1_CMPB_IRQ" cpuLine="IRQRTR_SII_308,M55HE_IRQS_372,M55HP_IRQS_372" cpuLineNum="308,372,372" type="Level">
          <irqDesc>Channel 13 interrupt request at driver B</irqDesc>
        </irq>
      </module>
      <module name="QEC2">
        <irq name="QEC2_CMPA_IRQ" cpuLine="IRQRTR_SII_309,M55HE_IRQS_373,M55HP_IRQS_373" cpuLineNum="309,373,373" type="Level">
          <irqDesc>Channel 14 interrupt request at driver A</irqDesc>
        </irq>
        <irq name="QEC2_CMPB_IRQ" cpuLine="IRQRTR_SII_310,M55HE_IRQS_374,M55HP_IRQS_374" cpuLineNum="310,374,374" type="Level">
          <irqDesc>Channel 14 interrupt request at driver B</irqDesc>
        </irq>
      </module>
      <module name="QEC3">
        <irq name="QEC3_CMPA_IRQ" cpuLine="IRQRTR_SII_311,M55HE_IRQS_375,M55HP_IRQS_375" cpuLineNum="311,375,375" type="Level">
          <irqDesc>Channel 15 interrupt request at driver A</irqDesc>
        </irq>
        <irq name="QEC3_CMPB_IRQ" cpuLine="IRQRTR_SII_312,M55HE_IRQS_376,M55HP_IRQS_376" cpuLineNum="312,376,376" type="Level">
          <irqDesc>Channel 15 interrupt request at driver B</irqDesc>
        </irq>
      </module>
      <module name="SDMMC">
        <irq name="SDMMC_IRQ" cpuLine="M55HE_IRQS_102,M55HP_IRQS_102,IRQRTR_SII_38" cpuLineNum="102,102,38" type="Level">
          <irqDesc>SDMMC Interrupt request</irqDesc>
        </irq>
        <irq name="SDMMC_WAKEUP_IRQ" cpuLine="M55HE_IRQS_103,M55HP_IRQS_103,IRQRTR_SII_39" cpuLineNum="103,103,39" type="Level">
          <irqDesc>SDMMC Wakeup event interrupt request</irqDesc>
        </irq>
      </module>
      <module name="OSPI0">
        <irq name="OSPI0_IRQ" cpuLine="IRQRTR_SII_32,M55HE_IRQS_96,M55HP_IRQS_96" cpuLineNum="32,96,96" type="Level">
          <irqDesc>Combined interrupt request from OSPI0 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</irqDesc>
        </irq>
      </module>
      <module name="OSPI1">
        <irq name="OSPI1_IRQ" cpuLine="IRQRTR_SII_33,M55HE_IRQS_97,M55HP_IRQS_97" cpuLineNum="33,97,97" type="Level">
          <irqDesc>Combined interrupt request from OSPI1 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</irqDesc>
        </irq>
      </module>
      <module name="AES0">
        <irq name="AES0_IRQ" cpuLine="IRQRTR_SII_34,M55HE_IRQS_98,M55HP_IRQS_98" cpuLineNum="34,98,98" type="Level">
          <irqDesc>Combined interrupt request from AES0 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</irqDesc>
        </irq>
      </module>
      <module name="AES1">
        <irq name="AES1_IRQ" cpuLine="IRQRTR_SII_35,M55HE_IRQS_99,M55HP_IRQS_99" cpuLineNum="35,99,99" type="Level">
          <irqDesc>Combined interrupt request from AES1 routed to the interrupt controllers in the device. For more information on the internal interrupt requests, see Section OSPI Interrupt Requests.</irqDesc>
        </irq>
      </module>
      <module name="DMA1_SEC">
        <irq name="DMA1_IRQ0" cpuLine="M55HP_IRQS_0" cpuLineNum="0" type="Level">
          <irqDesc>Interrupt request 0. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ1" cpuLine="M55HP_IRQS_1" cpuLineNum="1" type="Level">
          <irqDesc>Interrupt request 1. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ10" cpuLine="M55HP_IRQS_10" cpuLineNum="10" type="Level">
          <irqDesc>Interrupt request 10. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ11" cpuLine="M55HP_IRQS_11" cpuLineNum="11" type="Level">
          <irqDesc>Interrupt request 11. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ12" cpuLine="M55HP_IRQS_12" cpuLineNum="12" type="Level">
          <irqDesc>Interrupt request 12. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ13" cpuLine="M55HP_IRQS_13" cpuLineNum="13" type="Level">
          <irqDesc>Interrupt request 13. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ14" cpuLine="M55HP_IRQS_14" cpuLineNum="14" type="Level">
          <irqDesc>Interrupt request 14. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ15" cpuLine="M55HP_IRQS_15" cpuLineNum="15" type="Level">
          <irqDesc>Interrupt request 15. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ16" cpuLine="M55HP_IRQS_16" cpuLineNum="16" type="Level">
          <irqDesc>Interrupt request 16. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ17" cpuLine="M55HP_IRQS_17" cpuLineNum="17" type="Level">
          <irqDesc>Interrupt request 17. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ18" cpuLine="M55HP_IRQS_18" cpuLineNum="18" type="Level">
          <irqDesc>Interrupt request 18. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ19" cpuLine="M55HP_IRQS_19" cpuLineNum="19" type="Level">
          <irqDesc>Interrupt request 19. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ2" cpuLine="M55HP_IRQS_2" cpuLineNum="2" type="Level">
          <irqDesc>Interrupt request 2. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ20" cpuLine="M55HP_IRQS_20" cpuLineNum="20" type="Level">
          <irqDesc>Interrupt request 20. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ21" cpuLine="M55HP_IRQS_21" cpuLineNum="21" type="Level">
          <irqDesc>Interrupt request 21. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ22" cpuLine="M55HP_IRQS_22" cpuLineNum="22" type="Level">
          <irqDesc>Interrupt request 22. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ23" cpuLine="M55HP_IRQS_23" cpuLineNum="23" type="Level">
          <irqDesc>Interrupt request 23. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ24" cpuLine="M55HP_IRQS_24" cpuLineNum="24" type="Level">
          <irqDesc>Interrupt request 24. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ25" cpuLine="M55HP_IRQS_25" cpuLineNum="25" type="Level">
          <irqDesc>Interrupt request 25. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ26" cpuLine="M55HP_IRQS_26" cpuLineNum="26" type="Level">
          <irqDesc>Interrupt request 26. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ27" cpuLine="M55HP_IRQS_27" cpuLineNum="27" type="Level">
          <irqDesc>Interrupt request 27. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ28" cpuLine="M55HP_IRQS_28" cpuLineNum="28" type="Level">
          <irqDesc>Interrupt request 28. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ29" cpuLine="M55HP_IRQS_29" cpuLineNum="29" type="Level">
          <irqDesc>Interrupt request 29. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ3" cpuLine="M55HP_IRQS_3" cpuLineNum="3" type="Level">
          <irqDesc>Interrupt request 3. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ30" cpuLine="M55HP_IRQS_30" cpuLineNum="30" type="Level">
          <irqDesc>Interrupt request 30. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ31" cpuLine="M55HP_IRQS_31" cpuLineNum="31" type="Level">
          <irqDesc>Interrupt request 31. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ4" cpuLine="M55HP_IRQS_4" cpuLineNum="4" type="Level">
          <irqDesc>Interrupt request 4. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ5" cpuLine="M55HP_IRQS_5" cpuLineNum="5" type="Level">
          <irqDesc>Interrupt request 5. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ6" cpuLine="M55HP_IRQS_6" cpuLineNum="6" type="Level">
          <irqDesc>Interrupt request 6. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ7" cpuLine="M55HP_IRQS_7" cpuLineNum="7" type="Level">
          <irqDesc>Interrupt request 7. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ8" cpuLine="M55HP_IRQS_8" cpuLineNum="8" type="Level">
          <irqDesc>Interrupt request 8. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ9" cpuLine="M55HP_IRQS_9" cpuLineNum="9" type="Level">
          <irqDesc>Interrupt request 9. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ_ABORT" cpuLine="M55HP_IRQS_32" cpuLineNum="32" type="Level">
          <irqDesc>DMAC aborted execution of a program thread.</irqDesc>
        </irq>
      </module>
      <module name="DMA1_NS">
        <irq name="DMA1_IRQ0" cpuLine="M55HP_IRQS_0" cpuLineNum="0" type="Level">
          <irqDesc>Interrupt request 0. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ1" cpuLine="M55HP_IRQS_1" cpuLineNum="1" type="Level">
          <irqDesc>Interrupt request 1. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ10" cpuLine="M55HP_IRQS_10" cpuLineNum="10" type="Level">
          <irqDesc>Interrupt request 10. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ11" cpuLine="M55HP_IRQS_11" cpuLineNum="11" type="Level">
          <irqDesc>Interrupt request 11. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ12" cpuLine="M55HP_IRQS_12" cpuLineNum="12" type="Level">
          <irqDesc>Interrupt request 12. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ13" cpuLine="M55HP_IRQS_13" cpuLineNum="13" type="Level">
          <irqDesc>Interrupt request 13. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ14" cpuLine="M55HP_IRQS_14" cpuLineNum="14" type="Level">
          <irqDesc>Interrupt request 14. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ15" cpuLine="M55HP_IRQS_15" cpuLineNum="15" type="Level">
          <irqDesc>Interrupt request 15. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ16" cpuLine="M55HP_IRQS_16" cpuLineNum="16" type="Level">
          <irqDesc>Interrupt request 16. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ17" cpuLine="M55HP_IRQS_17" cpuLineNum="17" type="Level">
          <irqDesc>Interrupt request 17. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ18" cpuLine="M55HP_IRQS_18" cpuLineNum="18" type="Level">
          <irqDesc>Interrupt request 18. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ19" cpuLine="M55HP_IRQS_19" cpuLineNum="19" type="Level">
          <irqDesc>Interrupt request 19. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ2" cpuLine="M55HP_IRQS_2" cpuLineNum="2" type="Level">
          <irqDesc>Interrupt request 2. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ20" cpuLine="M55HP_IRQS_20" cpuLineNum="20" type="Level">
          <irqDesc>Interrupt request 20. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ21" cpuLine="M55HP_IRQS_21" cpuLineNum="21" type="Level">
          <irqDesc>Interrupt request 21. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ22" cpuLine="M55HP_IRQS_22" cpuLineNum="22" type="Level">
          <irqDesc>Interrupt request 22. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ23" cpuLine="M55HP_IRQS_23" cpuLineNum="23" type="Level">
          <irqDesc>Interrupt request 23. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ24" cpuLine="M55HP_IRQS_24" cpuLineNum="24" type="Level">
          <irqDesc>Interrupt request 24. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ25" cpuLine="M55HP_IRQS_25" cpuLineNum="25" type="Level">
          <irqDesc>Interrupt request 25. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ26" cpuLine="M55HP_IRQS_26" cpuLineNum="26" type="Level">
          <irqDesc>Interrupt request 26. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ27" cpuLine="M55HP_IRQS_27" cpuLineNum="27" type="Level">
          <irqDesc>Interrupt request 27. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ28" cpuLine="M55HP_IRQS_28" cpuLineNum="28" type="Level">
          <irqDesc>Interrupt request 28. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ29" cpuLine="M55HP_IRQS_29" cpuLineNum="29" type="Level">
          <irqDesc>Interrupt request 29. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ3" cpuLine="M55HP_IRQS_3" cpuLineNum="3" type="Level">
          <irqDesc>Interrupt request 3. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ30" cpuLine="M55HP_IRQS_30" cpuLineNum="30" type="Level">
          <irqDesc>Interrupt request 30. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ31" cpuLine="M55HP_IRQS_31" cpuLineNum="31" type="Level">
          <irqDesc>Interrupt request 31. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ4" cpuLine="M55HP_IRQS_4" cpuLineNum="4" type="Level">
          <irqDesc>Interrupt request 4. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ5" cpuLine="M55HP_IRQS_5" cpuLineNum="5" type="Level">
          <irqDesc>Interrupt request 5. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ6" cpuLine="M55HP_IRQS_6" cpuLineNum="6" type="Level">
          <irqDesc>Interrupt request 6. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ7" cpuLine="M55HP_IRQS_7" cpuLineNum="7" type="Level">
          <irqDesc>Interrupt request 7. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ8" cpuLine="M55HP_IRQS_8" cpuLineNum="8" type="Level">
          <irqDesc>Interrupt request 8. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ9" cpuLine="M55HP_IRQS_9" cpuLineNum="9" type="Level">
          <irqDesc>Interrupt request 9. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA1_IRQ_ABORT" cpuLine="M55HP_IRQS_32" cpuLineNum="32" type="Level">
          <irqDesc>DMAC aborted execution of a program thread.</irqDesc>
        </irq>
      </module>
      <module name="DMA2_SEC">
        <irq name="DMA2_IRQ0" cpuLine="M55HE_IRQS_0" cpuLineNum="0" type="Level">
          <irqDesc>Interrupt request 0. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ1" cpuLine="M55HE_IRQS_1" cpuLineNum="1" type="Level">
          <irqDesc>Interrupt request 1. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ10" cpuLine="M55HE_IRQS_10" cpuLineNum="10" type="Level">
          <irqDesc>Interrupt request 10. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ11" cpuLine="M55HE_IRQS_11" cpuLineNum="11" type="Level">
          <irqDesc>Interrupt request 11. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ12" cpuLine="M55HE_IRQS_12" cpuLineNum="12" type="Level">
          <irqDesc>Interrupt request 12. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ13" cpuLine="M55HE_IRQS_13" cpuLineNum="13" type="Level">
          <irqDesc>Interrupt request 13. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ14" cpuLine="M55HE_IRQS_14" cpuLineNum="14" type="Level">
          <irqDesc>Interrupt request 14. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ15" cpuLine="M55HE_IRQS_15" cpuLineNum="15" type="Level">
          <irqDesc>Interrupt request 15. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ16" cpuLine="M55HE_IRQS_16" cpuLineNum="16" type="Level">
          <irqDesc>Interrupt request 16. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ17" cpuLine="M55HE_IRQS_17" cpuLineNum="17" type="Level">
          <irqDesc>Interrupt request 17. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ18" cpuLine="M55HE_IRQS_18" cpuLineNum="18" type="Level">
          <irqDesc>Interrupt request 18. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ19" cpuLine="M55HE_IRQS_19" cpuLineNum="19" type="Level">
          <irqDesc>Interrupt request 19. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ2" cpuLine="M55HE_IRQS_2" cpuLineNum="2" type="Level">
          <irqDesc>Interrupt request 2. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ20" cpuLine="M55HE_IRQS_20" cpuLineNum="20" type="Level">
          <irqDesc>Interrupt request 20. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ21" cpuLine="M55HE_IRQS_21" cpuLineNum="21" type="Level">
          <irqDesc>Interrupt request 21. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ22" cpuLine="M55HE_IRQS_22" cpuLineNum="22" type="Level">
          <irqDesc>Interrupt request 22. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ23" cpuLine="M55HE_IRQS_23" cpuLineNum="23" type="Level">
          <irqDesc>Interrupt request 23. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ24" cpuLine="M55HE_IRQS_24" cpuLineNum="24" type="Level">
          <irqDesc>Interrupt request 24. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ25" cpuLine="M55HE_IRQS_25" cpuLineNum="25" type="Level">
          <irqDesc>Interrupt request 25. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ26" cpuLine="M55HE_IRQS_26" cpuLineNum="26" type="Level">
          <irqDesc>Interrupt request 26. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ27" cpuLine="M55HE_IRQS_27" cpuLineNum="27" type="Level">
          <irqDesc>Interrupt request 27. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ28" cpuLine="M55HE_IRQS_28" cpuLineNum="28" type="Level">
          <irqDesc>Interrupt request 28. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ29" cpuLine="M55HE_IRQS_29" cpuLineNum="29" type="Level">
          <irqDesc>Interrupt request 29. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ3" cpuLine="M55HE_IRQS_3" cpuLineNum="3" type="Level">
          <irqDesc>Interrupt request 3. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ30" cpuLine="M55HE_IRQS_30" cpuLineNum="30" type="Level">
          <irqDesc>Interrupt request 30. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ31" cpuLine="M55HE_IRQS_31" cpuLineNum="31" type="Level">
          <irqDesc>Interrupt request 31. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ4" cpuLine="M55HE_IRQS_4" cpuLineNum="4" type="Level">
          <irqDesc>Interrupt request 4. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ5" cpuLine="M55HE_IRQS_5" cpuLineNum="5" type="Level">
          <irqDesc>Interrupt request 5. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ6" cpuLine="M55HE_IRQS_6" cpuLineNum="6" type="Level">
          <irqDesc>Interrupt request 6. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ7" cpuLine="M55HE_IRQS_7" cpuLineNum="7" type="Level">
          <irqDesc>Interrupt request 7. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ8" cpuLine="M55HE_IRQS_8" cpuLineNum="8" type="Level">
          <irqDesc>Interrupt request 8. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ9" cpuLine="M55HE_IRQS_9" cpuLineNum="9" type="Level">
          <irqDesc>Interrupt request 9. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ_ABORT" cpuLine="M55HE_IRQS_32" cpuLineNum="32" type="Level">
          <irqDesc>DMAC aborted execution of a program thread.</irqDesc>
        </irq>
      </module>
      <module name="DMA2_NS">
        <irq name="DMA2_IRQ0" cpuLine="M55HE_IRQS_0" cpuLineNum="0" type="Level">
          <irqDesc>Interrupt request 0. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ1" cpuLine="M55HE_IRQS_1" cpuLineNum="1" type="Level">
          <irqDesc>Interrupt request 1. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ10" cpuLine="M55HE_IRQS_10" cpuLineNum="10" type="Level">
          <irqDesc>Interrupt request 10. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ11" cpuLine="M55HE_IRQS_11" cpuLineNum="11" type="Level">
          <irqDesc>Interrupt request 11. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ12" cpuLine="M55HE_IRQS_12" cpuLineNum="12" type="Level">
          <irqDesc>Interrupt request 12. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ13" cpuLine="M55HE_IRQS_13" cpuLineNum="13" type="Level">
          <irqDesc>Interrupt request 13. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ14" cpuLine="M55HE_IRQS_14" cpuLineNum="14" type="Level">
          <irqDesc>Interrupt request 14. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ15" cpuLine="M55HE_IRQS_15" cpuLineNum="15" type="Level">
          <irqDesc>Interrupt request 15. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ16" cpuLine="M55HE_IRQS_16" cpuLineNum="16" type="Level">
          <irqDesc>Interrupt request 16. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ17" cpuLine="M55HE_IRQS_17" cpuLineNum="17" type="Level">
          <irqDesc>Interrupt request 17. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ18" cpuLine="M55HE_IRQS_18" cpuLineNum="18" type="Level">
          <irqDesc>Interrupt request 18. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ19" cpuLine="M55HE_IRQS_19" cpuLineNum="19" type="Level">
          <irqDesc>Interrupt request 19. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ2" cpuLine="M55HE_IRQS_2" cpuLineNum="2" type="Level">
          <irqDesc>Interrupt request 2. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ20" cpuLine="M55HE_IRQS_20" cpuLineNum="20" type="Level">
          <irqDesc>Interrupt request 20. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ21" cpuLine="M55HE_IRQS_21" cpuLineNum="21" type="Level">
          <irqDesc>Interrupt request 21. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ22" cpuLine="M55HE_IRQS_22" cpuLineNum="22" type="Level">
          <irqDesc>Interrupt request 22. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ23" cpuLine="M55HE_IRQS_23" cpuLineNum="23" type="Level">
          <irqDesc>Interrupt request 23. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ24" cpuLine="M55HE_IRQS_24" cpuLineNum="24" type="Level">
          <irqDesc>Interrupt request 24. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ25" cpuLine="M55HE_IRQS_25" cpuLineNum="25" type="Level">
          <irqDesc>Interrupt request 25. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ26" cpuLine="M55HE_IRQS_26" cpuLineNum="26" type="Level">
          <irqDesc>Interrupt request 26. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ27" cpuLine="M55HE_IRQS_27" cpuLineNum="27" type="Level">
          <irqDesc>Interrupt request 27. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ28" cpuLine="M55HE_IRQS_28" cpuLineNum="28" type="Level">
          <irqDesc>Interrupt request 28. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ29" cpuLine="M55HE_IRQS_29" cpuLineNum="29" type="Level">
          <irqDesc>Interrupt request 29. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ3" cpuLine="M55HE_IRQS_3" cpuLineNum="3" type="Level">
          <irqDesc>Interrupt request 3. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ30" cpuLine="M55HE_IRQS_30" cpuLineNum="30" type="Level">
          <irqDesc>Interrupt request 30. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ31" cpuLine="M55HE_IRQS_31" cpuLineNum="31" type="Level">
          <irqDesc>Interrupt request 31. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ4" cpuLine="M55HE_IRQS_4" cpuLineNum="4" type="Level">
          <irqDesc>Interrupt request 4. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ5" cpuLine="M55HE_IRQS_5" cpuLineNum="5" type="Level">
          <irqDesc>Interrupt request 5. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ6" cpuLine="M55HE_IRQS_6" cpuLineNum="6" type="Level">
          <irqDesc>Interrupt request 6. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ7" cpuLine="M55HE_IRQS_7" cpuLineNum="7" type="Level">
          <irqDesc>Interrupt request 7. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ8" cpuLine="M55HE_IRQS_8" cpuLineNum="8" type="Level">
          <irqDesc>Interrupt request 8. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ9" cpuLine="M55HE_IRQS_9" cpuLineNum="9" type="Level">
          <irqDesc>Interrupt request 9. One per DMA request interface (32 in total).</irqDesc>
        </irq>
        <irq name="DMA2_IRQ_ABORT" cpuLine="M55HE_IRQS_32" cpuLineNum="32" type="Level">
          <irqDesc>DMAC aborted execution of a program thread.</irqDesc>
        </irq>
      </module>
      <module name="BOD">
        <irq name="BOD_IRQ" cpuLine="IRQRTR_SII_36,M55HP_IRQS_100,M55HE_IRQS_100" cpuLineNum="36,100,100" type="Level">
          <irqDesc>Voltage below threshold</irqDesc>
        </irq>
      </module>
      <module name="MHU_SECPU_M55HE_0_RX">
        <irq name="MHU_SECPU_M55HE_0_RX_IRQ" cpuLine="M55HE_IRQS_37" cpuLineNum="37" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HE_SECPU_0_TX">
        <irq name="MHU_M55HE_SECPU_0_TX_IRQ" cpuLine="M55HE_IRQS_38" cpuLineNum="38" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_SECPU_M55HE_1_RX">
        <irq name="MHU_SECPU_M55HE_1_RX_IRQ" cpuLine="M55HE_IRQS_39" cpuLineNum="39" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HE_SECPU_1_TX">
        <irq name="MHU_M55HE_SECPU_1_TX_IRQ" cpuLine="M55HE_IRQS_40" cpuLineNum="40" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HP_M55HE_0_RX">
        <irq name="MHU_M55HP_M55HE_0_RX_IRQ" cpuLine="M55HE_IRQS_41" cpuLineNum="41" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HE_M55HP_0_TX">
        <irq name="MHU_M55HE_M55HP_0_TX_IRQ" cpuLine="M55HE_IRQS_42" cpuLineNum="42" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HP_M55HE_1_RX">
        <irq name="MHU_M55HP_M55HE_1_RX_IRQ" cpuLine="M55HE_IRQS_43" cpuLineNum="43" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HE_M55HP_1_TX">
        <irq name="MHU_M55HE_M55HP_1_TX_IRQ" cpuLine="M55HE_IRQS_44" cpuLineNum="44" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_SECPU_M55HP_0_RX">
        <irq name="MHU_SECPU_M55HP_0_RX_IRQ" cpuLine="M55HP_IRQS_37" cpuLineNum="37" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HP_SECPU_0_TX">
        <irq name="MHU_M55HP_SECPU_0_TX_IRQ" cpuLine="M55HP_IRQS_38" cpuLineNum="38" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_SECPU_M55HP_1_RX">
        <irq name="MHU_SECPU_M55HP_1_RX_IRQ" cpuLine="M55HP_IRQS_39" cpuLineNum="39" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HP_SECPU_1_TX">
        <irq name="MHU_M55HP_SECPU_1_TX_IRQ" cpuLine="M55HP_IRQS_40" cpuLineNum="40" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HE_M55HP_0_RX">
        <irq name="MHU_M55HE_M55HP_0_RX_IRQ" cpuLine="M55HP_IRQS_41" cpuLineNum="41" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HP_M55HE_0_TX">
        <irq name="MHU_M55HP_M55HE_0_TX_IRQ" cpuLine="M55HP_IRQS_42" cpuLineNum="42" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HE_M55HP_1_RX">
        <irq name="MHU_M55HE_M55HP_1_RX_IRQ" cpuLine="M55HP_IRQS_43" cpuLineNum="43" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
      <module name="MHU_M55HP_M55HE_1_TX">
        <irq name="MHU_M55HP_M55HE_1_TX_IRQ" cpuLine="M55HP_IRQS_44" cpuLineNum="44" type="Level">
          <irqDesc>Interrupt</irqDesc>
        </irq>
      </module>
    </irqs>
    <dreqs>
      <module name="LPTIMER0">
        <dreq name="LPTIMER0_DMA_REQ" dmaLine="DMA0_REQ_0,DMA2_REQ_0">
          <dreqDesc>Request to DMA0 controller</dreqDesc>
        </dreq>
      </module>
      <module name="LPTIMER1">
        <dreq name="LPTIMER1_DMA_REQ" dmaLine="DMA0_REQ_1,DMA2_REQ_1">
          <dreqDesc>Request to DMA0 controller</dreqDesc>
        </dreq>
      </module>
      <module name="LPTIMER2">
        <dreq name="LPTIMER2_DMA_REQ" dmaLine="DMA0_REQ_2,DMA2_REQ_2">
          <dreqDesc>Request to DMA0 controller</dreqDesc>
        </dreq>
      </module>
      <module name="LPTIMER3">
        <dreq name="LPTIMER3_DMA_REQ" dmaLine="DMA0_REQ_3,DMA2_REQ_3">
          <dreqDesc>Request to DMA0 controller</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER0">
        <dreq name="UT0_T0_DMA_REQ" dmaLine="DMA0_REQ_0,DMA1_REQ_8">
          <dreqDesc>UT0_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT0_T1_DMA_REQ" dmaLine="DMA0_REQ_1,DMA1_REQ_9">
          <dreqDesc>UT0_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER1">
        <dreq name="UT1_T0_DMA_REQ" dmaLine="DMA0_REQ_2,DMA1_REQ_10">
          <dreqDesc>UT1_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT1_T1_DMA_REQ" dmaLine="DMA0_REQ_3,DMA1_REQ_11">
          <dreqDesc>UT1_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER2">
        <dreq name="UT2_T0_DMA_REQ" dmaLine="DMA0_REQ_4,DMA1_REQ_12">
          <dreqDesc>UT2_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT2_T1_DMA_REQ" dmaLine="DMA0_REQ_5,DMA1_REQ_13">
          <dreqDesc>UT2_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER3">
        <dreq name="UT3_T0_DMA_REQ" dmaLine="DMA0_REQ_6,DMA1_REQ_14">
          <dreqDesc>UT3_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT3_T1_DMA_REQ" dmaLine="DMA0_REQ_7,DMA1_REQ_15">
          <dreqDesc>UT3_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER4">
        <dreq name="UT4_T0_DMA_REQ" dmaLine="DMA0_REQ_8">
          <dreqDesc>UT4_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT4_T1_DMA_REQ" dmaLine="DMA0_REQ_9">
          <dreqDesc>UT4_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER5">
        <dreq name="UT5_T0_DMA_REQ" dmaLine="DMA0_REQ_10">
          <dreqDesc>UT5_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT5_T1_DMA_REQ" dmaLine="DMA0_REQ_11">
          <dreqDesc>UT5_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER6">
        <dreq name="UT6_T0_DMA_REQ" dmaLine="DMA0_REQ_12">
          <dreqDesc>UT6_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT6_T1_DMA_REQ" dmaLine="DMA0_REQ_13">
          <dreqDesc>UT6_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="UTIMER7">
        <dreq name="UT7_T0_DMA_REQ" dmaLine="DMA0_REQ_14">
          <dreqDesc>UT7_T0 DMA request</dreqDesc>
        </dreq>
        <dreq name="UT7_T1_DMA_REQ" dmaLine="DMA0_REQ_15">
          <dreqDesc>UT7_T1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="QEC0">
        <dreq name="QEC0_DMA_REQ" dmaLine="DMA0_REQ_4">
          <dreqDesc>QEC0 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="QEC1">
        <dreq name="QEC1_DMA_REQ" dmaLine="DMA0_REQ_5">
          <dreqDesc>QEC1 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="QEC2">
        <dreq name="QEC2_DMA_REQ" dmaLine="DMA0_REQ_6">
          <dreqDesc>QEC2 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="QEC3">
        <dreq name="QEC3_DMA_REQ" dmaLine="DMA0_REQ_7">
          <dreqDesc>QEC3 DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="GPIO3">
        <dreq name="GPIO3_0_DMA_REQ" dmaLine="DMA0_REQ_0">
          <dreqDesc>GPIO3 pin 0 request</dreqDesc>
        </dreq>
        <dreq name="GPIO3_1_DMA_REQ" dmaLine="DMA0_REQ_1">
          <dreqDesc>GPIO3 pin 1 request</dreqDesc>
        </dreq>
        <dreq name="GPIO3_2_DMA_REQ" dmaLine="DMA0_REQ_2">
          <dreqDesc>GPIO3 pin 2 request</dreqDesc>
        </dreq>
        <dreq name="GPIO3_3_DMA_REQ" dmaLine="DMA0_REQ_3">
          <dreqDesc>GPIO3 pin 3 request</dreqDesc>
        </dreq>
        <dreq name="GPIO3_4_DMA_REQ" dmaLine="DMA0_REQ_4">
          <dreqDesc>GPIO3 pin 4 request</dreqDesc>
        </dreq>
        <dreq name="GPIO3_5_DMA_REQ" dmaLine="DMA0_REQ_5">
          <dreqDesc>GPIO3 pin 5 request</dreqDesc>
        </dreq>
        <dreq name="GPIO3_6_DMA_REQ" dmaLine="DMA0_REQ_6">
          <dreqDesc>GPIO3 pin 6 request</dreqDesc>
        </dreq>
        <dreq name="GPIO3_7_DMA_REQ" dmaLine="DMA0_REQ_7">
          <dreqDesc>GPIO3 pin 7 request</dreqDesc>
        </dreq>
      </module>
      <module name="GPIO4">
        <dreq name="GPIO4_0_DMA_REQ" dmaLine="DMA0_REQ_8">
          <dreqDesc>GPIO4 pin 0 request</dreqDesc>
        </dreq>
        <dreq name="GPIO4_1_DMA_REQ" dmaLine="DMA0_REQ_9">
          <dreqDesc>GPIO4 pin 1 request</dreqDesc>
        </dreq>
        <dreq name="GPIO4_2_DMA_REQ" dmaLine="DMA0_REQ_10">
          <dreqDesc>GPIO4 pin 2 request</dreqDesc>
        </dreq>
        <dreq name="GPIO4_3_DMA_REQ" dmaLine="DMA0_REQ_11">
          <dreqDesc>GPIO4 pin 3 request</dreqDesc>
        </dreq>
        <dreq name="GPIO4_4_DMA_REQ" dmaLine="DMA0_REQ_12">
          <dreqDesc>GPIO4 pin 4 request</dreqDesc>
        </dreq>
        <dreq name="GPIO4_5_DMA_REQ" dmaLine="DMA0_REQ_13">
          <dreqDesc>GPIO4 pin 5 request</dreqDesc>
        </dreq>
        <dreq name="GPIO4_6_DMA_REQ" dmaLine="DMA0_REQ_14">
          <dreqDesc>GPIO4 pin 6 request</dreqDesc>
        </dreq>
        <dreq name="GPIO4_7_DMA_REQ" dmaLine="DMA0_REQ_15">
          <dreqDesc>GPIO4 pin 7 request</dreqDesc>
        </dreq>
      </module>
      <module name="GPIO7">
        <dreq name="GPIO7_0_DMA_REQ" dmaLine="DMA0_REQ_16">
          <dreqDesc>GPIO7 pin 0 request</dreqDesc>
        </dreq>
        <dreq name="GPIO7_1_DMA_REQ" dmaLine="DMA0_REQ_17">
          <dreqDesc>GPIO7 pin 1 request</dreqDesc>
        </dreq>
        <dreq name="GPIO7_2_DMA_REQ" dmaLine="DMA0_REQ_18">
          <dreqDesc>GPIO7 pin 2 request</dreqDesc>
        </dreq>
        <dreq name="GPIO7_3_DMA_REQ" dmaLine="DMA0_REQ_19">
          <dreqDesc>GPIO7 pin 3 request</dreqDesc>
        </dreq>
        <dreq name="GPIO7_4_DMA_REQ" dmaLine="DMA0_REQ_20">
          <dreqDesc>GPIO7 pin 4 request</dreqDesc>
        </dreq>
        <dreq name="GPIO7_5_DMA_REQ" dmaLine="DMA0_REQ_21">
          <dreqDesc>GPIO7 pin 5 request</dreqDesc>
        </dreq>
        <dreq name="GPIO7_6_DMA_REQ" dmaLine="DMA0_REQ_22">
          <dreqDesc>GPIO7 pin 6 request</dreqDesc>
        </dreq>
        <dreq name="GPIO7_7_DMA_REQ" dmaLine="DMA0_REQ_23">
          <dreqDesc>GPIO7 pin 7 request</dreqDesc>
        </dreq>
      </module>
      <module name="GPIO8">
        <dreq name="GPIO8_0_DMA_REQ" dmaLine="DMA0_REQ_24">
          <dreqDesc>GPIO8 pin 0 request</dreqDesc>
        </dreq>
        <dreq name="GPIO8_1_DMA_REQ" dmaLine="DMA0_REQ_25">
          <dreqDesc>GPIO8 pin 1 request</dreqDesc>
        </dreq>
        <dreq name="GPIO8_2_DMA_REQ" dmaLine="DMA0_REQ_26">
          <dreqDesc>GPIO8 pin 2 request</dreqDesc>
        </dreq>
        <dreq name="GPIO8_3_DMA_REQ" dmaLine="DMA0_REQ_27">
          <dreqDesc>GPIO8 pin 3 request</dreqDesc>
        </dreq>
        <dreq name="GPIO8_4_DMA_REQ" dmaLine="DMA0_REQ_28">
          <dreqDesc>GPIO8 pin 4 request</dreqDesc>
        </dreq>
        <dreq name="GPIO8_5_DMA_REQ" dmaLine="DMA0_REQ_29">
          <dreqDesc>GPIO8 pin 5 request</dreqDesc>
        </dreq>
        <dreq name="GPIO8_6_DMA_REQ" dmaLine="DMA0_REQ_30">
          <dreqDesc>GPIO8 pin 6 request</dreqDesc>
        </dreq>
        <dreq name="GPIO8_7_DMA_REQ" dmaLine="DMA0_REQ_31">
          <dreqDesc>GPIO8 pin 7 request</dreqDesc>
        </dreq>
      </module>
      <module name="GPIO9">
        <dreq name="GPIO9_0_DMA_REQ" dmaLine="DMA1_REQ_24">
          <dreqDesc>GPIO9 pin 0 request</dreqDesc>
        </dreq>
        <dreq name="GPIO9_1_DMA_REQ" dmaLine="DMA1_REQ_25">
          <dreqDesc>GPIO9 pin 1 request</dreqDesc>
        </dreq>
        <dreq name="GPIO9_2_DMA_REQ" dmaLine="DMA1_REQ_26">
          <dreqDesc>GPIO9 pin 2 request</dreqDesc>
        </dreq>
        <dreq name="GPIO9_3_DMA_REQ" dmaLine="DMA1_REQ_27">
          <dreqDesc>GPIO9 pin 3 request</dreqDesc>
        </dreq>
        <dreq name="GPIO9_4_DMA_REQ" dmaLine="DMA1_REQ_28">
          <dreqDesc>GPIO9 pin 4 request</dreqDesc>
        </dreq>
        <dreq name="GPIO9_5_DMA_REQ" dmaLine="DMA1_REQ_29">
          <dreqDesc>GPIO9 pin 5 request</dreqDesc>
        </dreq>
        <dreq name="GPIO9_6_DMA_REQ" dmaLine="DMA1_REQ_30">
          <dreqDesc>GPIO9 pin 6 request</dreqDesc>
        </dreq>
        <dreq name="GPIO9_7_DMA_REQ" dmaLine="DMA1_REQ_31">
          <dreqDesc>GPIO9 pin 7 request</dreqDesc>
        </dreq>
      </module>
      <module name="LPGPIO">
        <dreq name="LPGPIO_0_DMA_REQ" dmaLine="DMA2_REQ_24">
          <dreqDesc>LPGPIO pin 0 request</dreqDesc>
        </dreq>
        <dreq name="LPGPIO_1_DMA_REQ" dmaLine="DMA2_REQ_25">
          <dreqDesc>LPGPIO pin 1 request</dreqDesc>
        </dreq>
        <dreq name="LPGPIO_2_DMA_REQ" dmaLine="DMA2_REQ_26">
          <dreqDesc>LPGPIO pin 2 request</dreqDesc>
        </dreq>
        <dreq name="LPGPIO_3_DMA_REQ" dmaLine="DMA2_REQ_27">
          <dreqDesc>LPGPIO pin 3 request</dreqDesc>
        </dreq>
        <dreq name="LPGPIO_4_DMA_REQ" dmaLine="DMA2_REQ_28">
          <dreqDesc>LPGPIO pin 4 request</dreqDesc>
        </dreq>
        <dreq name="LPGPIO_5_DMA_REQ" dmaLine="DMA2_REQ_29">
          <dreqDesc>LPGPIO pin 5 request</dreqDesc>
        </dreq>
        <dreq name="LPGPIO_6_DMA_REQ" dmaLine="DMA2_REQ_30">
          <dreqDesc>LPGPIO pin 6 request</dreqDesc>
        </dreq>
        <dreq name="LPGPIO_7_DMA_REQ" dmaLine="DMA2_REQ_31">
          <dreqDesc>LPGPIO pin 7 request</dreqDesc>
        </dreq>
      </module>
      <module name="I2C0">
        <dreq name="I2C0_DMA_RX_REQ" dmaLine="DMA0_REQ_24">
          <dreqDesc>I2C0 receive request</dreqDesc>
        </dreq>
        <dreq name="I2C0_DMA_TX_REQ" dmaLine="DMA0_REQ_28">
          <dreqDesc>I2C0 transmit request</dreqDesc>
        </dreq>
      </module>
      <module name="I2C1">
        <dreq name="I2C1_DMA_RX_REQ" dmaLine="DMA0_REQ_25">
          <dreqDesc>I2C1 receive request</dreqDesc>
        </dreq>
        <dreq name="I2C1_DMA_TX_REQ" dmaLine="DMA0_REQ_29">
          <dreqDesc>I2C1 transmit request</dreqDesc>
        </dreq>
      </module>
      <module name="I2C2">
        <dreq name="I2C2_DMA_RX_REQ" dmaLine="DMA0_REQ_26">
          <dreqDesc>I2C2 receive request</dreqDesc>
        </dreq>
        <dreq name="I2C2_DMA_TX_REQ" dmaLine="DMA0_REQ_30">
          <dreqDesc>I2C2 transmit request</dreqDesc>
        </dreq>
      </module>
      <module name="I2C3">
        <dreq name="I2C3_DMA_RX_REQ" dmaLine="DMA0_REQ_27">
          <dreqDesc>I2C3 receive request</dreqDesc>
        </dreq>
        <dreq name="I2C3_DMA_TX_REQ" dmaLine="DMA0_REQ_31">
          <dreqDesc>I2C3 transmit request</dreqDesc>
        </dreq>
      </module>
      <module name="I2S0">
        <dreq name="I2S_0_DMA_RX_REQ" dmaLine="DMA0_REQ_24">
          <dreqDesc>I2S0 Receive 
DMA request</dreqDesc>
        </dreq>
        <dreq name="I2S_0_DMA_TX_REQ" dmaLine="DMA0_REQ_28">
          <dreqDesc>I2S0 Transmit 
DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="I2S1">
        <dreq name="I2S_1_DMA_RX_REQ" dmaLine="DMA0_REQ_25">
          <dreqDesc>I2S1 Receive 
DMA request</dreqDesc>
        </dreq>
        <dreq name="I2S_1_DMA_TX_REQ" dmaLine="DMA0_REQ_29">
          <dreqDesc>I2S1 Transmit 
DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="I2S2">
        <dreq name="I2S_2_DMA_RX_REQ" dmaLine="DMA0_REQ_26">
          <dreqDesc>I2S2 Receive 
DMA request</dreqDesc>
        </dreq>
        <dreq name="I2S_2_DMA_TX_REQ" dmaLine="DMA0_REQ_30">
          <dreqDesc>I2S2 Transmit 
DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="I2S3">
        <dreq name="I2S_3_DMA_RX_REQ" dmaLine="DMA0_REQ_27">
          <dreqDesc>I2S3 Receive 
DMA request</dreqDesc>
        </dreq>
        <dreq name="I2S_3_DMA_TX_REQ" dmaLine="DMA0_REQ_31">
          <dreqDesc>I2S3 Transmit 
DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="LPI2S">
        <dreq name="LPI2S_DMA_RX_REQ" dmaLine="DMA0_REQ_14,DMA2_REQ_14">
          <dreqDesc>LPI2S Receive 
DMA request</dreqDesc>
        </dreq>
        <dreq name="LPI2S_DMA_TX_REQ" dmaLine="DMA0_REQ_15,DMA2_REQ_15">
          <dreqDesc>LPI2S Transmit 
DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="I3C">
        <dreq name="I3C_DMA_RX_REQ" dmaLine="DMA0_REQ_20,DMA2_REQ_20">
          <dreqDesc>I3C receive request</dreqDesc>
        </dreq>
        <dreq name="I3C_DMA_TX_REQ" dmaLine="DMA0_REQ_21,DMA2_REQ_21">
          <dreqDesc>I3C transmit request</dreqDesc>
        </dreq>
      </module>
      <module name="PDM">
        <dreq name="PDM_DMA_REQ" dmaLine="DMA0_REQ_31">
          <dreqDesc>PDM DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="LPPDM">
        <dreq name="LPPDM_DMA_REQ" dmaLine="DMA0_REQ_30,DMA2_REQ_19">
          <dreqDesc>LPPDM DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="SPI0">
        <dreq name="SPI0_DMA_RX_REQ" dmaLine="DMA0_REQ_16">
          <dreqDesc>SPI0 receive DMA request</dreqDesc>
        </dreq>
        <dreq name="SPI0_DMA_TX_REQ" dmaLine="DMA0_REQ_20">
          <dreqDesc>SPI0 transmit DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="SPI1">
        <dreq name="SPI1_DMA_RX_REQ" dmaLine="DMA0_REQ_17">
          <dreqDesc>SPI1 receive DMA request</dreqDesc>
        </dreq>
        <dreq name="SPI1_DMA_TX_REQ" dmaLine="DMA0_REQ_21">
          <dreqDesc>SPI1 transmit DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="SPI2">
        <dreq name="SPI2_DMA_RX_REQ" dmaLine="DMA0_REQ_18">
          <dreqDesc>SPI2 receive DMA request</dreqDesc>
        </dreq>
        <dreq name="SPI2_DMA_TX_REQ" dmaLine="DMA0_REQ_22">
          <dreqDesc>SPI2 transmit DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="SPI3">
        <dreq name="SPI3_DMA_RX_REQ" dmaLine="DMA0_REQ_19">
          <dreqDesc>SPI3 receive DMA request</dreqDesc>
        </dreq>
        <dreq name="SPI3_DMA_TX_REQ" dmaLine="DMA0_REQ_23">
          <dreqDesc>SPI3 transmit DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="LPSPI">
        <dreq name="LPSPI_DMA_RX_REQ" dmaLine="DMA0_REQ_12,DMA0_REQ_24,DMA2_REQ_12">
          <dreqDesc>LPSPI receive DMA request</dreqDesc>
        </dreq>
        <dreq name="LPSPI_DMA_TX_REQ" dmaLine="DMA0_REQ_13,DMA0_REQ_25,DMA2_REQ_13">
          <dreqDesc>LPSPI transmit DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="OSPI0">
        <dreq name="OSPI0_DMA_RX_REQ" dmaLine="DMA0_REQ_16">
          <dreqDesc>OSPI0 receive request</dreqDesc>
        </dreq>
        <dreq name="OSPI0_DMA_TX_REQ" dmaLine="DMA0_REQ_18">
          <dreqDesc>OSPI0 transmit request</dreqDesc>
        </dreq>
      </module>
      <module name="OSPI1">
        <dreq name="OSPI1_DMA_RX_REQ" dmaLine="DMA0_REQ_17">
          <dreqDesc>OSPI1 receive request</dreqDesc>
        </dreq>
        <dreq name="OSPI1_DMA_TX_REQ" dmaLine="DMA0_REQ_19">
          <dreqDesc>OSPI1 transmit request</dreqDesc>
        </dreq>
      </module>
      <module name="CPI">
        <dreq name="CAM_VSYNC_DMA_REQ" dmaLine="DMA0_REQ_26">
          <dreqDesc>CPI VSYNC DMA request</dreqDesc>
        </dreq>
        <dreq name="CAM_HSYNC_DMA_REQ" dmaLine="DMA0_REQ_27">
          <dreqDesc>CPI HSYNC DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="LPCPI">
        <dreq name="LPCAM_VSYNC_DMA_REQ" dmaLine="DMA2_REQ_16">
          <dreqDesc>LPCPI VSYNC DMA request</dreqDesc>
        </dreq>
        <dreq name="LPCAM_HSYNC_DMA_REQ" dmaLine="DMA2_REQ_17">
          <dreqDesc>LPCPI HSYNC DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="CDC">
        <dreq name="CDC_VSYNC_DMA_REQ" dmaLine="DMA0_REQ_28">
          <dreqDesc>CDC VSYNC DMA request</dreqDesc>
        </dreq>
        <dreq name="CDC_HSYNC_DMA_REQ" dmaLine="DMA0_REQ_29">
          <dreqDesc>CDC HSYNC DMA request</dreqDesc>
        </dreq>
      </module>
      <module name="ADC120">
        <dreq name="ADC120_DONE1_DMA_REQ" dmaLine="DMA0_REQ_4,UT_EVENT_4,DMA2_REQ_4">
          <dreqDesc>All samples taken</dreqDesc>
        </dreq>
      </module>
      <module name="ADC121">
        <dreq name="ADC121_DONE1_DMA_REQ" dmaLine="DMA0_REQ_5,UT_EVENT_5,DMA2_REQ_5">
          <dreqDesc>All samples taken</dreqDesc>
        </dreq>
      </module>
      <module name="ADC122">
        <dreq name="ADC122_DONE1_DMA_REQ" dmaLine="DMA0_REQ_6,UT_EVENT_6,DMA2_REQ_6">
          <dreqDesc>All samples taken</dreqDesc>
        </dreq>
      </module>
      <module name="ADC24">
        <dreq name="ADC24_DONE0_DMA_REQ" dmaLine="DMA0_REQ_10,UT_EVENT_10,DMA2_REQ_10">
          <dreqDesc>Averaged sample ready</dreqDesc>
        </dreq>
        <dreq name="ADC24_DONE1_DMA_REQ" dmaLine="DMA0_REQ_11,UT_EVENT_11,DMA2_REQ_11">
          <dreqDesc>All samples taken</dreqDesc>
        </dreq>
      </module>
      <module name="CMP0">
        <dreq name="CMP0_DMA_REQ" dmaLine="DMA0_REQ_0,UT_EVENT_0,DMA1_REQ_0">
          <dreqDesc>Comparator result changed</dreqDesc>
        </dreq>
      </module>
      <module name="CMP1">
        <dreq name="CMP1_DMA_REQ" dmaLine="DMA0_REQ_1,UT_EVENT_1,DMA1_REQ_1">
          <dreqDesc>Comparator result changed</dreqDesc>
        </dreq>
      </module>
      <module name="CMP2">
        <dreq name="CMP2_DMA_REQ" dmaLine="DMA0_REQ_2,UT_EVENT_2,DMA1_REQ_2">
          <dreqDesc>Comparator result changed</dreqDesc>
        </dreq>
      </module>
      <module name="CMP3">
        <dreq name="CMP3_DMA_REQ" dmaLine="DMA0_REQ_3,UT_EVENT_3,DMA1_REQ_3">
          <dreqDesc>Comparator result changed</dreqDesc>
        </dreq>
      </module>
      <module name="LPCMP">
        <dreq name="LPCMP_DMA_REQ" dmaLine="DMA2_REQ_18">
          <dreqDesc>Comparator output changed</dreqDesc>
        </dreq>
      </module>
      <module name="BOD">
        <dreq name="BOD_DMA_REQ" dmaLine="DMA0_REQ_7,UT_EVENT_7,DMA2_REQ_7">
          <dreqDesc>Voltage below threshold</dreqDesc>
        </dreq>
      </module>
    </dreqs>
  </vendorExtensions>
</device>
